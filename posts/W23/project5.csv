post_id|subject|content|unique_views|good_question|visibility|i_answer|s_answer|num_followups
lfxdvvbwy6z4uv|P5 FAQ and Overview Session|"Refer to this post for Frequently Asked Questions regarding Project 5. Please keep the followups related to questions in this post only. The FAQ will be updated as the project progresses, so please check back here before posting a new question!. . Overview Session: Monday, 4/3 from 8-9pm. Slides: https://docs.google.com/presentation/d/1vyD7xIkS6ly1c5rQNaEH1xHY-UfPlQgg33X3MhZOAoQ/edit#slide=id.g101d43c8276_0_158. Zoom: https://umich.zoom.us/j/94564930578. Recording: https://umich.zoom.us/rec/share/f3hvM9tgSNkB8hKtzhn22H1vgbadboYxjO_uXhL23dE0RCuE2Iu18tzODuy1GjQr.3UxBNLz-L4rxBCxb. . Q: I've never worked with maps before.  Where can I get a crash course about map functionality?. A: Staff last semester made a p5 walkthrough video! Check it out here!  In addition, another staff member made this video a few years ago detailing a general overview of what they are and how you can use them.  In addition here is a playlist for additional help related to p5..  . Q: Should I use my Map.h implementation in the driver?. A: DO NOT DO THIS. Your implementation of Map is inefficient, and will cause problems down the road. Use the standard library implementation of map instead. (#include <map>) Great documentation can be found at http://www.cplusplus.com/reference/map/map/map/. . Q: I want to test if an Iterator points to a nullptr, how can I do this?. A: You're probably trying to compare the iterator to nullptr like this: ASSERT_EQUAL(iter, nullptr);. Because these two aren't of the same type, the unit testing framework will probably complain. Instead see if you can compare two objects of the same type - Iterator - which have the same value..  . Q: What is less? What is std::less<T>? How do I use less? . A: less is a private member variable of BST.. . It is an instance of a comparator class whose type is Compare. Compare is a template type. std::less<T> is a functor class in the stl that compares two elements of type T using the < operator. By default, Compare will be std::less<T>.. . In the BinarySearch_compile_check.cpp, there is an example of a BST with the default Compare and a BST with a custom comparator. . . . In the first case, the template will be instantiated like . Node *root;. std::less<int> less;. In the second case, the template will be instantiated like . Node *root;. DuckWealthLess less;. . Q: What could be a cause of incorrect accuracy? . A: Make sure you're properly handling duplicate words. Make sure ties are properly handled. Make sure log-probabilities are not being rounded due to being stored in an incorrect type..  . Q: How do I record ""For each label L and word w, the number of posts with label L that contain w""? . A: You'll need a more complex data structure, since you'll need to store three pieces of information - the label, the word, and the count. There are at least two different ways to do this. Hint: The key type and/or value type of a map can be a class..  . Q: Why do my test cases compile on Caen but not the autograder?. A: Double check that you haven't broken the public interface and added a public function. Also, do not put using namespace std in a header file..  . Q: What's a csvstream and how do I use it? . A: There are three really helpful examples at https://github.com/awdeorio/csvstream..  . Q: Do we need to check for duplicates in our check_sorting_invariants_impl?. A: Your check_sorting_invariants_impl checks for a valid BST. A tree with duplicates is not a valid binary search tree. The most definitive and unambiguous description of the invariant you need to check for is described in the sorting invariants section of the spec. To be extra clear, if you were to call check_sorting_invariants on a tree that has duplicates in the right subtree, it should return false..  . Q: VSCode syntax highlighting is breaking on BinarySearchTree.h and Map.h!. A: This appears to be a bug in VSCode 1.33 regarding default template parameters. We've found a few workarounds, probably the simplest of which is to add a comment to the template declaration:. .  . Q: How fast does my code need to run?. A: You should aim for the large test case to run within a minute or so. For reference, the instructor solution takes about 5 seconds on this test case..  . Q: My code is too slow. What might be the reason?. A: Common sources of slowness include:. . Processing a post more than once (including reading it more than once or saving all the data in a vector).. . Iterating over a map to find something rather than using [] or find().. . Passing strings or containers by value.. . Iterating by value in a range-based for loop.. . Q: How can I check if a node equals nullptr? How can I set a node to nullptr?. A: You can check if a node is nullptr by: ”node_ptr == nulptr” or “!node_ptr”. You can create a node that is nullptr by doing “Node* node_ptr = nullptr”.. . Q: What does “no matching function call” mean?. A: This error means that some of your types or parameters to a function call are wrong. Let’s take a function like the vector pushback function, which is used like this “vec.pushback(5)”. If you tried to call “vec.pushback()” it would get a no matching function call because there is no vector pushback function that doesn’t take in any parameters. This same logic applies to constructors. Check the error to see what function is being improperly called and what parameters it takes..  . Q: What is a false positive?. A: A false positive is when the test case passed on your code, however, it your code is still buggy. The test case passed because there was a logical error in your test case so that it wouldn’t reveal the bug in your code. If you have one of these errors, I would suggest re-evaluating the logic of your test case. Come of office hours if you would like more indepth help on it!"|340|0|active|||1
lg35xk4j3gv4ob|UNKNOWN ERROR|Hi there. Everytime I make BinarySearchTree_public_test.exe and ./BinarySearchTree_public_test.exe, I get this thing in my terminal and have no idea what it is:. . . . It just loops like this...|3|0|private|||2
lg35mstjhdr5q0|returning in copy_nodes_impl|. . Would my implementation here cause any error? Especially the return copy_nodes_impl(n) statement? I'm getting an error and am not sure if it's from this function.|4|0|private|Since you're passing in the same node n again in the recursive call, how would data for the left and right nodes get copied?||0
lg34ubm6maf104|Empty_impl implementation|For empty_impl, is it considered empty if there is a root node (not nullptr), but left and right do not exist? Or is that considered not empty?|24|0|active|That is a non-empty tree with height 1.||0
lg347e496fk6mu|find_impl doesn&#39;t compile &#34;non-void function does not return a value in all control paths&#34;|"im getting the error  ""non-void function does not return a value in all control paths"" when tryin to run public tests. I followed the walkthrough for all the scenarios smh"|21|0|active|Make sure your function returns a value in every if/else if/else block. Even if logically a branch can never be executed, it should still return a value because compilers don't understand logic!. . Example:. bool foo(int a) {.   if (a < 0) return false;.   if (a >= 0) return true;.   // logically the code never reaches here but it should .   // still return something because from the syntax point of.   // view, the code could reach here. }. Solution: either return some garbage value there or preferably use if else wisely. bool foo(int a) {.   if (a < 0) return false;.   return true;. }. or . bool foo(int a) {.   if (a < 0) return false;.   else return true;. }. ||0
lg322q1vvi45kd|testing the tree deconstructor|how can we test the tree deconstructor?|30|1|active|See @3835.||0
lg2zpj0lqvf6zb|How do we test the destructor of BTS?|Do we need to test the destructor for our BTS?|41|1|active|BTS Destructor?. ||0
lg2ydxx4uc255r|resolved|. resovlved|32|0|active|resolved||0
lg2y5bczaf34|How could we create an instance of Key_compare?|I just wonder where could we find some additional instructions about how to do so, since I am trying to go through the walkthrough of the P5 map.h but do not get the way to create the instance. Any help are appreciated! Thanks a lot!|43|0|active|Just like Compare in BinarySearchTree.h, Key_Compare is the name of the comparator class. You could create an instance by doing Key_Compare less;||0
lg2xuaw4iwk1ed|insert_impl require clause|I was looking at the insert_impl require clause and I saw that item is not already in the tree. Would it be a good idea to use the find function to check that clause, or should I create a helper function to look through the tree (E.g., contain function), or is there a better way to do this check? |50|0|active|The find function literally does what a contains function does. I personally use it to check the required clause in my insert_impl.||0
lg2xq2v6dt725l|csvstream|I am confused about which way I should use the >> operator for csvstream. . It looks like one will read row into a map (I assume between column entries and their associated header) and one will read a row into a vector pairing entries with their header. Which one do I use? Am I correct about what they do? Thanks!|30|0|active|The github link provided for the csvstream.h library (https://github.com/awdeorio/csvstream) goes into detail on how to use both. The first example shows how to read into a map whereas the third shows how to read into a vector (such that the order of values read is maintained).||0
lg2vf48dhy93ru|insert_impl question|For insert_impl, when we insert a new node, are we inserting it at the bottom of the tree as a leaf node all the time and then sorting the tree after, or are we inserting the node in such a way that preserves the sorting invariant? If it is the latter case, I'm struggling to keep the function elegant and it becomes a mess of if else statements and temp nodes that get deleted.|46|0|active|You should insert in a way that preserves sorting invariant. Realistically, it is always going to be inserted at the bottom of some branch. If you use recursion well, there will be just a few if...else... statements and they are definitely manageable.||0
lg2uz0f5asd16g|Seg Fault in copy function|Hello, we are getting a seg fault when the copy constructor is called in BinarySearchTree_compile_check.cpp. I stepped through the copy_nodes_impl function and it failed on the line where we copied the right subtree. Not sure what's going wrong here but any help would be appreciated!. |3|0|private|||1
lg2uqo5ngzf4rn|less in find_impl function|We are getting an error message when we call less in our find_impl function and we are not sure what it means. Can anyone help us? |37|0|active|node->datum should work||0
lg2qwy53yzp35k|Check Sorting Invariant|When we are checking for sorting invariant, how do we tackle the issue of certain elements on the left of the root being greater than the root. For example, how would you check this:. .                 10    .              /      \ .         5             .        /  \           .     3                 .    /  \               .       25              .      /  \             . . Obviously, the tree is not sorted as 25 > 5, 10. How would we consider the value 10 or 5 when we are dealing with the node with datum three? The only way I can think of is to find the maximum element on the left side of the tree and then check that against your current node's datum. And for the right side, to find the minimum and check against your current node's datum.. . Is this the right track? Can we add in helper functions for this? Any recommendations would be great!|69|2|active|"""The only way I can think of is to find the maximum element on the left side of the tree and then check that against your current node's datum. And for the right side, to find the minimum and check against your current node's datum."" - This is exactly right, and the test case you gave is exactly why.. . Interesting question I found in follow-ups: max and min functions assume that the invariant holds. How can we use them for checking invariant?. A: Since we are using recursion, we are going all the way to leaf nodes before the recursive functions return. At the end of the day, we can always get a node whose left and right subtrees are both valid. Worst case: a leaf node always has its left and right subtrees valid (both nullptr). Then max and min functions work perfectly fine on this node since the invariant does hold.. Then your algorithm works perfectly fine on this node.. If the invariant does not hold at this level, then it will return false and propagates the false all the way up. Eventually the function correctly returns false.. If the invariant holds at this level, then this new, one node larger, tree becomes valid, so max and min functions can be correctly used on this new tree. We return to the previous case, and the recursion continues working its way up. Eventually, it either hits a false somewhere in between, or has to return true at the end, validating the tree.. . In the example you gave, when you call max on the left subtree of the tree rooted at 5, it would correctly return 25 since that left subtree is valid. Then 25 > 5 and the function returns false."||1
lg2p7ywh81p3a7|Binary Search Tree test cases|I am a bit confused on how to write test cases for BinarySearchTree.h. In specific, I am unsure how to call functions. Also, I am unsure how to check if the function operated properly. Any guidance on how I should proceed?|56|0|active|the functions are static so they can be called without an instance of the class. Plus the iterator class uses the implementations you write so you could check out those functions too. Also it is worth looking at the compile check to get an idea of how to use the ADT. ||0
lg2p63zrbem37e|Less function|I get this error when I run make BinarySearchTree_compile_check.exe. Could someone help to explain what's causing the error? Thanks!. |57|1|active|Are you declaring the comparator as a private member variable? ||1
lg2kw9w21ga7g7|Classifier: Error Checking for Files that cannot be opened|"According to the specs, ""If any file cannot be opened, print out the following message, where filename is the name of the file that could not be opened"": cout << ""Error opening file: "" << filename << endl;. . Does this mean that if both testing and training files cannot be opened, we have to print the error message twice? Also, if the training file opens properly, but the testing does not, does that mean we run the output for the training, and then print the error message or do we straight away return the error message because one of the files couldn't be opened?"|43|0|active|. Does this mean that if both testing and training files cannot be opened, we have to print the error message twice?. . No, we would print the error for the first file that fails, then exit. We would probably attempt to open the training file first.. . . Also, if the training file opens properly, but the testing does not, does that mean we run the output for the training, and then print the error message or do we straight away return the error message because one of the files couldn't be opened?. . In the case of failure, we would probably want to know early before we do a bunch of work and end up having to throw it away (like the case where we do all the training but then exit because the test file doesn't open). In other words, you should check that both files open before training.||0
lg2jlmxcag45de|Could anyone rank the difficulty of the functions in bst.h?|want to get an idea. lots of thanks:)|94|1|active|Personally insert > find >= check_invariant > traverse > everything else. All the other functions are pretty straightforward if you attended lecture.||0
lg2jhogt1vx49m|Additional Map Tests|"I would like to write additional tests for Map.h. I created a new file, Map_tests.cpp, to do this. Does anyone know how to modify the Makefile to support ""make Map_tests.exe"" so I can run them? Thanks!"|53|0|active|Thanks for pointing this out, we are currently aware that the Makefile does not support this and planning to get this fixed.. . For now, you can add the following lines to your Makefile:. . Map_tests.exe: Map_tests.cpp Map.h BinarySearchTree.h. 	$(CXX) $(CXXFLAGS) $< -o $@. . . Add these lines around line 38, between BinarySearchTree_tests.exe and %_public_test.exe - so your Makefile should look something like:. . .... BinarySearchTree_tests.exe: BinarySearchTree_tests.cpp BinarySearchTree.h.  $(CXX) $(CXXFLAGS) $< -o $@. . Map_tests.exe: Map_tests.cpp Map.h BinarySearchTree.h.  $(CXX) $(CXXFLAGS) $< -o $@. . %_public_test.exe: %_public_test.cpp %.h.  $(CXX) $(CXXFLAGS) $< -o $@. . ...||0
lg2hpt5e46h4ah|Tests|We can add duplicates by dereferencing an iterator. Is this something we should prevent?|63|0|active|Short answer: no.. . From the starter files (comment on iterator dereference overload):. .     // WARNING:  Dereferencing an iterator returns an element from the tree.     //           by reference, which could be modified. It is the.     //           responsibility of the user to ensure that any.     //           modifications result in a new value that compares equal.     //           to the existing value. Otherwise, the sorting invariant.     //           will no longer hold.. As the developer creating this data type, it is our responsibility to provide an interface for the user. If the user decides to do something that doesn't conform to the provided interface, then whatever happens is the responsibility of the user (not the developer).||0
lg2806avkab78a|Creating nodes on the stack vs on the heap|Should we be using the new keyword in our BST implementations? Should we be using dynamic memory, or just creating instances of node structs?|76|0|active|Since nodes are dynamically allocated, you should use the new keyword and put them on the heap. This also means that you will need to delete all nodes in the destructor.||0
lg1s92vxh0czb|Where can we find the correct output of the compile_check.cpp for BST?|Any clues are appreciated! Thanks a lot!|71|0|active|The correct output is... no output, haha. The compile check just ensures that your BST code compiles, and doesn't actually print anything. If you're getting errors when running it, that's a problem—otherwise, you're good to go (with the compile check, at least).If you're actually looking to test your code, there's a basic public test you can compile and run (BinarySearchTree_public_test.cpp, if I remember correctly). On top of this public test, you should be writing your own test cases to submit to the autograder (you need to catch 16 out of the 19 possible bugs for your own tests).||1
lg1q09ppbg75p|What to return in copy_notes_impl function|Hi there. I'm not really sure what to return in the copy_nodes_impl function... . . |11|0|private|The copy_nodes_impl function needs to return a Node pointer:. . static Node * copy_nodes_impl(Node *node)  ||0
lg1kr55knhu221|Binary Search Tree: min_greater_than_impl function|Hello, for my min_greater_than_impl function (in BinarySearchTree.h), I am getting an error when I run the compile check that my function does not return in all control paths. I went over this with an IA in office hours today, and we tried adding a return node statement before the function ended which caused a segmentation fault. So I am not sure about the specific issue, and would appreciate any help. I have attached my function implementation below (this is posted privately). . |11|0|private|Nothing stands out as incorrect for your implementation for the min_greater_than_impl function, so I am wondering if the issue you re getting is from somewhere else in your code. Have you tried writing your own test cases for other functions or stepping through the compile check using the debugger? Also identifying what line in the compile check is giving you issues would be a helpful start.||0
lg1dr76ugmz6f1|How to destroy_nodes_impl|"How do we ""free the memory"" for a specific node. I have an idea of the recursive structure of the function, but what do you do to the current node to ""free the memory""? What does that mean? Do we use the 'delete' keyword? (I would assume not, since nodes are on the stack and not heap) "|92|0|active|Nodes are created on the heap (using the new keyword), so they must be destroyed in the destructor (using the delete keyword) : ) See the student answer and followups for more ideas on how to do this||1
lg1cdl1u4oe7gd|Error in get check_sorting_invariant_impl|. . Not sure how to fix this error. Are we not able to use less to compare the max element in the tree and the current node?|88|1|active|I think this is an issue with converting the constant Node from check_sorting_invariant_impl to a non_constant Node used in the Max function. However, I also have this issue and need help finding a solution.||0
lg1bji9cn8d3z6|running into BinarySearchTree_public_test.cpp error(?)|"both terminal and xcode console spams me with ""3""s when running the public test; anyone have any idea why? :C. "|77|0|active|"Since the tree is printed using the ++ operator (I believe) something is probably going wrong inside of the ""&operator++"" code. This means your implementation of either ""min_element_impl"" or ""min_greater_than_impl"" is not working properly."||0
lg1a2aq5bxc5hw|Map.h Compile Error|I am getting a compile error when I try to make the Map compiler check file. I am also getting an error for it on autograder. Below is a screenshot. I did not change any implementations I shouldn't have so I am confused.  |67|0|active|"You need to implement the ""operator()"" for the PairComp class in order for the code to compile properly.See @3793 on how to use ""Key_compare"" inside of the ""operator()"" function."||1
lg18urbnpzh5og|Bugs|How many total bugs are there to catch?|112|0|active|19||1
lg0zuhx0udz3c4|memory leak|Does anyone know how I can fix this memory leak? |114|0|active|Did you initialize your left and right pointers properly?||1
lg0z35m5ou52of|project 5 compared to project 4|Hello, I am a bit worried about this project. In relation to project 4 is project 5 harder? I found the last project pretty challenging and wanted to know how students responded to this project in the past.. . Thank you :)|260|8|active|It depends what you find challenging -- P5 has a somewhat similar structure to P4 in that you create your own BST and Map data structures, then use the STL implementations of those data structures for the ML driver. Generally we say the driver for P5 requires you to think more independently than the other driver functions you've implemented so far. . . I'd recommend sitting down and trying to put something down and seeing what parts may be difficult, and if you get stuck feel free to make a more specific piazza post or come to OH.||0
lg0w8ixxmi44qz|Iterators for Map.h|Hello, I am currently unsure about how to implement the Iterator begin function in map.h (I know how to create an iterator for linked lists but I am not sure how to create an iterator the first key pair value in a map). Any help would be appreciated|6|0|private|Under the hood, the Map uses a BST that stores key/value pairs. Does your BinarySearchTree.h have any helpful Iterator functions you can call (ie. begin)? (it's simpler than you think)||0
lg08s476eek2sj|BST Compile Check: no match for &#39;operator&lt;&#39;|"After implementing each of the functions within the BST file, our compile check doesn't seem to pass. It seems to be an issue with the < operator and possibly std::less. Here are the errors we are getting. It seems to all derive from that first error of :. . /usr/include/c++/11/bits/stl_function.h:400:20: error: no match for ‘operator<’ (operand types are ‘const Duck’ and ‘const Duck’).   400 |       { return __x < __y; }.       |                ~~~~^~~~~. We use the less than operator like such:. . std::less<T> {} (x, y). . . Edit: As per instructor's answer -- fixed by using less like less(x,y) rather than as above."|108|0|active|In your impl functions, you should use the custom less passed in, instead of std::less. Otherwise, those functions won't work for compile check since std::less can't compare two Duck instances.||0
lg05oxwghmk6yl|Compare Less ?|What exactly is the Compare object and how do we use it to “compare”? It’s in a few of the functions in the bst.h and I don’t know how to use it |122|0|active|See @3764I'd also recommend looking at some of the lecture notes, as they cover it there too to some extent.||0
lg04py89vo741r|bst.h Error - call to non static member function|. Hi, im trying to use the check_sorting_invariant function, calling it recursively like :. . check_sorting_invariant(node->right, less). but I am getting this error, that Im confused with. Any help?. . |78|0|active|"It looks like you're calling the wrong function here; ""check_sorting_invariant"" is a public member function of your BinarySearchTree; the function you want to be calling here is ""check_sorting_invariant_impl"", which is your implementation of the sorting invariant check."||0
lfzyl8utwo74m0|Size_t|Why are we returning size_t for the height and size function instead of int like we did for linked lists?|101|0|active|It doesn't really make sense for a height/size of something to be negative, so we return a size_t, which is always non-negative, to best represent the value.. You should always be extra careful to not assign a negative value to a size_t, otherwise it will overflow and return an extremely large value. It also means that when you see a size that is unreasonably large, you should check if you've accidentally let it be negative.||0
lfzyg2h3yrb4dk|Key_compare - error: no match for call to|"How are you meant to use the ""Key_compare"" functor?. . Right now, if I return ""true"" or ""false"" from my operator() implementation for PairLess in Map.h, the compile check runs just fine. However, the moment I try to actually compare the two values (such as ""return Key_compare(lhs.first, rhs.first);""), the compile check fails with a message like the following:. . In file included from Map_compile_check.cpp:5:. Map.h: In instantiation of ‘bool Map<Key_type, Value_type, Key_compare>::PairLess::operator()(const Pair_type&, const Pair_type&) const [with Key_type = std::__cxx11::basic_string<char>; Value_type = int; Key_compare = std::less<std::__cxx11::basic_string<char> >; Map<Key_type, Value_type, Key_compare>::Pair_type = std::pair<std::__cxx11::basic_string<char>, int>]’:. BinarySearchTree.h:653:13:   required from ‘static BinarySearchTree<T, Compare>::Node* BinarySearchTree<T, Compare>::min_greater_than_impl(BinarySearchTree<T, Compare>::Node*, const T&, Compare) [with T = std::pair<std::__cxx11::basic_string<char>, int>; Compare = Map<std::__cxx11::basic_string<char>, int>::PairLess]’. BinarySearchTree.h:200:45:   required from ‘BinarySearchTree<T, Compare>::Iterator& BinarySearchTree<T, Compare>::Iterator::operator++() [with T = std::pair<std::__cxx11::basic_string<char>, int>; Compare = Map<std::__cxx11::basic_string<char>, int>::PairLess]’. Map_compile_check.cpp:98:7:   required from here. Map.h:44:18: error: no matching function for call to ‘std::less<std::__cxx11::basic_string<char> >::less(const std::__cxx11::basic_string<char>&, const std::__cxx11::basic_string<char>&)’.    44 |           return Key_compare(lhs.first, rhs.first);.       |                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In file included from /usr/include/c++/11/string:48,.                  from Map_compile_check.cpp:3:. /usr/include/c++/11/bits/stl_function.h:395:12: note: candidate: ‘constexpr std::less<std::__cxx11::basic_string<char> >::less()’.   395 |     struct less : public binary_function<_Tp, _Tp, bool>.       |            ^~~~. /usr/include/c++/11/bits/stl_function.h:395:12: note:   candidate expects 0 arguments, 2 provided. /usr/include/c++/11/bits/stl_function.h:395:12: note: candidate: ‘constexpr std::less<std::__cxx11::basic_string<char> >::less(const std::less<std::__cxx11::basic_string<char> >&)’. /usr/include/c++/11/bits/stl_function.h:395:12: note:   candidate expects 1 argument, 2 provided. /usr/include/c++/11/bits/stl_function.h:395:12: note: candidate: ‘constexpr std::less<std::__cxx11::basic_string<char> >::less(std::less<std::__cxx11::basic_string<char> >&&)’. /usr/include/c++/11/bits/stl_function.h:395:12: note:   candidate expects 1 argument, 2 provided. In file included from Map_compile_check.cpp:5:. Map.h: In instantiation of ‘bool Map<Key_type, Value_type, Key_compare>::PairLess::operator()(const Pair_type&, const Pair_type&) const [with Key_type = Duck; Value_type = std::__cxx11::basic_string<char>; Key_compare = DuckWealthLess; Map<Key_type, Value_type, Key_compare>::Pair_type = std::pair<Duck, std::__cxx11::basic_string<char> >]’:. BinarySearchTree.h:653:13:   required from ‘static BinarySearchTree<T, Compare>::Node* BinarySearchTree<T, Compare>::min_greater_than_impl(BinarySearchTree<T, Compare>::Node*, const T&, Compare) [with T = std::pair<Duck, std::__cxx11::basic_string<char> >; Compare = Map<Duck, std::__cxx11::basic_string<char>, DuckWealthLess>::PairLess]’. BinarySearchTree.h:200:45:   required from ‘BinarySearchTree<T, Compare>::Iterator& BinarySearchTree<T, Compare>::Iterator::operator++() [with T = std::pair<Duck, std::__cxx11::basic_string<char> >; Compare = Map<Duck, std::__cxx11::basic_string<char>, DuckWealthLess>::PairLess]’. Map_compile_check.cpp:99:7:   required from here. Map.h:44:18: error: no matching function for call to ‘DuckWealthLess::DuckWealthLess(const Duck&, const Duck&)’.    44 |           return Key_compare(lhs.first, rhs.first);.       |                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Map_compile_check.cpp:20:7: note: candidate: ‘constexpr DuckWealthLess::DuckWealthLess()’.    20 | class DuckWealthLess {.       |       ^~~~~~~~~~~~~~. Map_compile_check.cpp:20:7: note:   candidate expects 0 arguments, 2 provided. Map_compile_check.cpp:20:7: note: candidate: ‘constexpr DuckWealthLess::DuckWealthLess(const DuckWealthLess&)’. Map_compile_check.cpp:20:7: note:   candidate expects 1 argument, 2 provided. Map_compile_check.cpp:20:7: note: candidate: ‘constexpr DuckWealthLess::DuckWealthLess(DuckWealthLess&&)’. Map_compile_check.cpp:20:7: note:   candidate expects 1 argument, 2 provided. make: *** [Makefile:43: Map_compile_check.exe] Error 1. This error makes no sense, as all of the ""no matching function for call to"" errors HAVE matching function calls (""DuckWealthLess::DuckWealthLess(const Duck&, const Duck&)"", for example, is defined exactly as it says it needs to be inside of the compile check function; the class is the same, the arguments are the same, all of it). I don't understand how the ""Key_compare"" functor is meant to be used.. . Any help is appreciated."|88|0|active|Answering my own question here, but apparently you need to use the following instead:. . Key_compare()(lhs.first, rhs.first);. ||0
lfzwoaq5a375wq|For each label W and word C, the number of posts with label  C that contain  W.|"In this information we can have some keys that their value is 0 right? And we would have a total of |C| * |W| keys?"|59|0|active|If you are asking about the number of keys in the map where you use to store such information, yes, as you need to iterate through every unique combination of label $$C$$ and word $$w$$.||0
lfzw0wn1t591ug|Invariants|For the insert function, we need to implement this keeping in mind the sorting invariant. Do we also need to keep in mind the duplicates invariant when implementing or do we just assume that no duplicate values will be inserted. |96|0|active|The requires clause ensures that no duplicates will be added to the tree. You don't need to verify this yourself :)||0
lfzvmngxc47xt|Project 5|Hello, I was wondering if there were any big changes to project 5 for this semester compared to fall 22 semester. I'm unfortunately retaking the class and was wondering.|4|0|private|||0
lfzuc5ku8371ao|Confusion about root node|I am a bit confused about the root node. When we insert a new element into the tree, it looks like the root node is set to point at that element. So am I correct in saying that the root changes after each insertion, or am I missing something? Thanks!. . . . I am just confused since size() starts from the root, so when I insert an element, the root changes to that element and the size is always stuck at 1. |101|0|active|"Your implementation of ""insert_impl"" should return the root node, with all of its leaves updated to point to their proper children (including the newly inserted child). If your size is always 1 after using the included ""insert"" method, there's something wrong with your implementation of ""insert_impl""."||1
lfzrz9sk2rq51f|min_greater_than_impl|I'm a bit confused about how to approach the algorithm for min_greater_than_impl with only one recursive call. Does anyone have any pointers in the right direction?|97|0|active|You'll actually need two recursive calls (only one of which will be called for each recursion, however). One goes down the left path, and the other goes down the right path. Think about when you would need to go down one path or the other, based on the sorting invariant.Once you've found the correct Node, it should be returned all the way back up the chain. You just need to determine when you've found the right Node (think about the difference between when you go left and find a nullptr, vs. when you go right and encounter a nullptr; in one of these cases, you've found the correct Node that should be returned all the way back up, and in the other you're looking at a value that's too large).It's also worth noting that you should return a nullptr immediately if the node you are looking at is null.||0
lfzrkvsicks15x|Project 5 lecture knowledge|Do we know enough to do all of project 5? And if not, what parts of the project can we do right now and what date/lecture will we know enough to complete the whole project? I want to start on this early ASAP, but I understand that it might be like P4 where we had to wait for the linked lists and iterator lecture.|121|4|active|You can always read the lecture notes for some pointers on a lot of the project-related concepts (usually only takes ~15 minutes or so, which is great if you're trying to get a head start). The lecture notes sometimes implement the functions you need for you, which is a nice bonus.I can't speak on the whole project, but for BST and its tests you really only need to understand recursion.||0
lfzrgibl4kx690|less function call|. Currently, I'm calling my less function like this in my BinarySearchTree.h and its giving me compile errors on the autograder, I went to the website of the previous post about calling the less function and followed that format and it gave me errors. The bellow writing would return true if thing1 were less than thing2. I'm just confused on how to call less in my program, any help would be appreciated.. . less<T>{}(thing1, thing2). |89|0|active|"The format ""less(thing1, thing2)"" should work to test if thing1 is less than thing2. "||1
lfzl9yce8137oa|project 5 changes|I was trying to get an idea of time, and was just wondering if project 5 had changed much from last semester?|146|0|active|The project is the same!||0
lfzl5z0t3h47m2|insert_impl|Can we assume that the inserted element into the tree is not going to be contained in the root node. Or do we have to account for insertion of the same item into the tree that is contained in the root node.|123|0|active|I recommend you read over the invariants for BST :)||0
lfyp9mlolvy4tu|Less Comparator|Hello, I wasn't sure about the specific syntax for using the less comparator to compare two values.|7|0|private|The comparator takes in two objects of the same type and perform comparison based on the `||0
lfyok4w0hccbj|In what format do we need to the read the csv file?|"I am confused because in train_small.csv it is in the format ""n,unique_views,tag,content"", but in the other ones it is in ""tag,content"""|110|1|active|You only need the tag and content columns. You can use the provided csvstream.h library (https://github.com/awdeorio/csvstream) which allows you to easily read in specific columns and their values||0
lfxggypk3qv5f5|how does copy_nodes_impl work?|. For copy_nodes_impl(), do we create a new node that has the same structure and we connect the top node to the new node?. |154|0|active|I believe it's creating a new node structure, that is identical, but they are not connected in any way. The function is used in the copy constructor and = operator.||2
lfx3jm3elar17|Error in Value_type() in map.h|Can someone explain to me why do I have this error?. .  |121|0|active|You might want to construct your pair using this notation: `{k, Value_type()}` or use `std::make_pair`||1
lfx21sbaldj7m0|height_impl - do we need to make a max function?|if so, how do we go about doing it?|146|0|active|"If by max function, you mean a function that returns the datum of the Node with the largest value, then this doesn't seem helpful for the height_impl function.. Side note: if you did want to create such a max function, we would just have to find the ""right-most"" child. We can do this because of the sorting invariant.. . If by max function you mean a function that, given two integers (eg. heights), returns the larger integer, then this seems like something you may need. You could implement such n algorithm yourself using if statements or use std::max"||0
lfwuob54upc19j|Compare Less Operator|Hi,. Is there a simple example of how to use the Compare std::less operator in bst.h with static types such as ints or strings so I know how to implement it correctly? Thank you|193|2|active|I found this website quite useful:. https://www.fluentcpp.com/2019/10/29/stdless-and-its-modern-evolution/||1
lfwl029xx6c30g|P5 Question|Which file should I begin with? I am so lost on where to start :/|247|0|active|I would do BST.h and then write your own BST_tests to heavily debug it (because the next part depends upon it).. I would then do map.h and then finally the driver.. Although the driver you will use the STL library.||1
lfua1it1cbk39i|Fix for this error|I keep getting this error  when I test my api. I was wondering if anyone had a fix for this problem?. . |180|1|active|||2
lfslb63wkk5235|project 5 release date|When will the autograder for project 5 be released?|188|0|active|Likely later this week or early next week after the end of P4.||0

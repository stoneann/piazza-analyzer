post_id|subject|content|unique_views|good_question|visibility|i_answer|s_answer|num_followups
lef4rjf96gd7c9|Midterm Mega Thread|"Hello everyone!. . To make your studying easier, we are going to compile references to all the questions that have been asked about the midterm. We will be updating this post regularly so come back and check this post when you have a question!. . Here is what we ask of the students:. 1. Use this post to see if it has been answered already. 2. If it hasn't been answered, post the question in a single piazza post WITH A SCREENSHOT OF THE QUESTION. Title the piazza post with the exact question number (ex : "" Fall 2019 Q1A "" ). 3. Explain why you are confused. It is easier for us to create an accurate explanation if you give us a specific topic to address rather than ""how do I do this"". . Happy studying!!. . Logistics. Room assignments - @2360, @2333Material - 1 - 10 inclusive (meaning lecture 10 is included). Fall 2019. Q0 - @2485, @2526, @2529, @2538, @2554, @2555, @2556, @2647Q1 - @2535, @2545, @2631Q2 - @2465 @2424, @2486, @2540, @2673, @2675, @2720Q3 - @2492, @2530, @2544, @2546, @2717Q4 - @2431, @2444, @2495, @2525, @2539Q10- @2404. Spring 2019. Q0 - @2551, @2552, @2597, @2615, @2661, @2663, @2666, @2680, @2682, @2685, @2686, @2715Q1 - @2505, @2506, @2548, @2689, @2716Q2 - @2568Q3 - @2659, @2660Q4 - @2591, @2593, @2523, @2550, @2558, @2570, @2591, @2593, @2688Q7- @2461, . Spring 2018. Q0 - @2623Q1 - @2700Q2A - @2670Q2B - @2695Q2C - @2639Q3B - @2678, @2739Q3C - @2644Q4B - @2564, @2640Q4C - @2641Q7 - @2741Q9 - @2575, @2677Q10 - @2643Q11 - @2692Q16 - @2579Q17 - @2612Q18 - @2589Q21 - @2581Q27 -@2547. Practice Exam. 1B - @24694C - @24744E - @2493. Midterm Review. A.2 - @2735A.3 - @2736. Labs. Lab 2 - @2483, @2480. Use of const: @2395. Operator precedence: @2392. Complicated pointers: @2443. Operator ++: @2480, @2486. "|953|5|active|||3
lfq07ca3sjg257|midterm grade showing missing|It's been weeks since the midterm so I am a little a little confused why it still shows missing on canvas. Also, are the curved grades released yet?|145|0|active|Curved grades are not released. This is why it shows as missing. You can calculate your own curved grade using the grade calculator and formula at @3013.||0
lfn0xacip3a77i|curved exam score|when will our curved exam score be reflected on canvas |150|3|active|soon||0
lfifr85h2797i9|Exam Regrade|"I'm finding more students who have problem with 4b in midterm. Here's the problem:. The solution said that we need to write a custom constructor but in my opinion, it is optional. Here's my argument:. the question didn't tell us to write a constructor but just ""store two strings on creation"". Here if I just use the default constructor (without declaring any constructors), I will also store two strings when I create my object (I store two empty strings when creating the object). So the question asks me to store two strings and I obey the command.. My grader gives some feedback to me (I'm grateful for his patience with me), and here's my response to them:. . 1) grader: you need a constructor to take in any meaningful input, which is why you're required to have a constructor for this question.. Me: Though we need a constructor to take in any meaningful input, the question just asks us to ""store two strings on creation"". I have obeyed the rules and it will be frustrating to get no points. The point I concluded with Professor James today is that we ""should"" include a constructor, but that is not totally necessary because we also get two strings (empty string) by default.. . 2) grader: The 4b requirement specifically states this: ""Stores 2 strings on creation, an input path and an output path."" While your solution will store two empty strings because of the string default initialization, therefore fulfilling the first part of the requirement, you do not store an input and output path on creation, which can only be done with a custom constructor definition that accepts two strings representing the input and output path.. Me: The knowledge that what is an ""input path"" and what is a ""output path"" is not the content of our courses or is not specified in our classes. And the interface of the classes and previous questions in the exam didn't explain or specify what an ""input path"" or ""output path"" needs to be. The path can be an empty string. Why not? When we students are taking the exams we know nothing about what an ""input path"" is. “Input path"" and ""output path"" are just names or variables. If they have a special meaning, then that meaning is not a content of EECS280 before the exam. . . 3) professor: The existing rubrics is consistent with the pattern we have discussed in lecture. And the question is internally consistent with the Register Class.. Me:For not being consistent to the class: The problem is exams are a set of commands. And we need to obey those commands to get each point. But we don't always have to follow the pattern we discussed in class. There is a slide that teaches us that the creation of a derived class object will automatically call the constructor of the base class and the default constructor of the derived class.. For the register problem: There is a constructor defined in register class. But this has no relation to the Work Class. There's no instruction like ""create a work class similar to Register class"" or ""create a work object like the register class"".. . . If anyone has doubt on my solutions, I'm happy to answer that questions. I'm looking for anyone who has the same problem with me and agree on my arguments."|255|2|active|"The exam question was written in a way to lead you to the correct solution without explicitly stating the solution. The word ""store"" refers to explicit assignments here (ex. x = 5) and the goal here was to recognize that ""store ... on creation"" refers to a constructor since it is run at object creation. While the strings will be default initialized as empty without specifying a constructor, this renders the class useless because there is no mechanism to change the class member variables to anything other than an empty string, and this is a reasonable learning objective to test in this question. The Message_factory() function in 4c also offers a hint to how the Work class is supposed to be initialized -- taking two parameters in the constructor. As for the ""input path""/""output path"" discussion, exam questions are usually application questions and knowing what these are is not really a requirement for answering the question, only that there are two strings that need to be initialized through the constructor. It is also reasonable to extrapolate what these terms might mean considering that we've discussed input/output files and streams in the course and presumably dealt with directory paths while using your terminal for your projects. I apologize if the question requirements felt vague when you were taking the exam but the rubric for 4b is final. We'll work on making the question statements clearer for the final."||5
lfhh36hbez13sy|Midterm Question 1f Regrades|Over the last few hours we've regraded question 1f on the midterm. Under no circumstances will your score go down from this regrade.. Some regrade requests cited slides that show references denoted with squares and dotted lines when referring to a variable in another stack frame. The goal of the question is to test an understanding of the differences between pointers and references. The reason this is tested is that it's a difficult, but important topic. C++ is not doing you any favors with the overloading of operator &. Before an object, the & will take the address of that object; the result is a pointer.. . . int x = 0;. // &x is a pointer to an integer (specifically x). int &y = x; . // y is another name for x. It does not contain the address of x, and does not point to x in spite of looking really similar.. Complaints for this shortsightedness of C++ can be directed to: https://www.stroustrup.com/bio.html. For the sake of transparency, here are the differences between pointers and references 1f was meant to test for. I'll color what this meant for grading:. . References are unlike pointers in that they cannot change what they refer to. . . // PROBLEM 1F WITH POINTERS. 1     int main() {. 2         int i = 10;   // Let's say the value of i (10) is stored at memory address 0x100. 3         int *p1 = &i; // p1 will hold a value of 0x100. 4         int j = *p1;  // Let's say the value of j (10) is stored at memory address 0x200. 5         j = 5;        //. 6         int *p2 = &j; // p2 will hold a value of 0x200. 7         p1 = p2;      // p1 will now hold a value of 0x200. 8         int *p3 = p2; // p3 will hold a value of 0x20. 9     }. In the above case:. i = 10. p1 = 0x200. j = 5. p2 = 0x200. p3 = 0x200. . . // PROBLEM 1F WITH REFERENCES. 1     int main() {. 2         int i = 10;   // Let's say the value of i is stored at memory address 0x100. 3         int &r1 = i;  // r1 is now equivalent to i. They are aliases. Anywhere you use one can be interchanged with the other.. 4         int j = r1;   // (same as j = i). Let's say the value of j is stored at memory address 0x200. 5         j = 5;        // Note, j is not an alias to r1. 6         int &r2 = j;  // r2 is now equivalent to j.. 7         r1 = r2;      // KEY INSIGHT: r1 = r2 is the same as i = j (since they're aliases). r1 is STILL a reference to i.. 8         int &r3 = r2; // r3 is now equivalent to r2 and to j . 9     }. In the above case:. i = r1 = 5. j = r2 = r3 = 5. . . Since references cannot change what they refer to, they MUST be initialized to refer to an object. This is why the following is true:. . // COMPILES. int x = 0;. int* ptr;. ptr = &x;. . // DOES NOT COMPILE. int y = 0;. int& ref; // Not initialized. ref = y;. . $${\color{Emerald}{Grading}}$$. r1 should not change the object it refers to.. . . References are unlike pointers in that they do not take their own memory. . . According to the C++ standard,. . It is unspecified whether or not a reference requires storage.. . With optimizations turned on, they often do not. Unlike pointers which hold an address in memory, references don't hold anything themselves -- they're just another name for a variable that DOES hold a value. They are not allocated on the stack, or the heap, or at all and will have the same address as the object they refer to.. . References are implemented that way as to provide abstraction: you can implement your swap function without any of the mess that comes with working with pointers. In exchange, you have a bit less control over how they work. Control vs ease-of-use is a balance you'll find yourselves needing to contend with in your own projects, just like speed vs memory, and peanut butter vs jelly on a sammie.. . $${\color{Emerald}{Grading}}$$. References should not be shown to allocate memory (denoted by boxes in memory diagrams).. . . References are unlike pointers in that their relationship is commutative, meaning changing one will change the other:. In other words,. . int main(){.   int x = 0;     // x = 0 .   int* ptr = &x; // x = 0, ptr = 0x100.   x = 1;         // x = 1, ptr = 0x100. }. whereas. . int main(){.   int x = 0;    // x = 0.   int& ref = x; // x = ref = 0.   x = 1;        // x = ref = 1. }. References are also transitive in that no matter how many references to references to references to references exist, it's still exactly the same as the original variable.. In other words,. . int main(){.   int x = 0; .   int& ref1 = x;.   int& ref2 = ref1;.   int& ref3 = ref2;.   int& ref4 = ref3;.   int& ref5 = ref4;.   ref4 = 1; // Still the same as x = 1 . }. $${\color{Emerald}{Grading}}$$. r3 is a reference to r2, but it's also a reference to j. A good way to show this if you like drawing lines in memory diagrams is to ensure, your lines are dotted and do not have a point, as points note a 1-way relationship rather than a 2-way one.. . Conclusion:. There are a lot of ways to draw a memory diagram. And in a class with so many sources of information, sometimes those can get mixed up. Truthfully, while we encourage a set of standards, communicating your systems is discretionary. As an engineer, so long as your work is communicating your message effectively, you're doing a great job.  Some diagrams show boxes for references when working across difference stack frames, some choose to use dotted lines without arrows to denote the two-way relationship of a reference, some don't show boxes at all. Some show boxes with crosses in them.. . We don't want to take points away if your solution is communicating effectively.. . For the sake of question 1f, we went ahead and gave extra credit to students who received partial credit but displayed an understanding of the above concepts. Specifically:. If empty boxes with dotted lines were used, that will earn points.If empty boxes with solid lines were used but were explicitly designated as references in another way, that will earn points.If boxes were not empty, but dotted lines without arrowheads were used (or other demonstrated two-way relationship), that will earn points.. Going forward, we'll strive to make the expected format clearer without giving away answers.. . Any further suggestions as to how we can better format exams can be directed to eecs280 staff email or anonymously at https://tally.so/r/3qLKl5. . Bonus difference between references and pointers:. There's no such thing as a null reference.|266|0|active|||0
lfhf5hpbs7t1e8|Mid term regrade request|Hi I just received the feedback regarding my mid-term exam regrade request. It's Q23 3b. I don't think the comment justifies the points taken off. I assume this feedback intends to give an edge case where we have three elements in an array, where the first two are valid while the last one is invalid. In my solution, this situation will still work since my solution keeps recursing until all invalid elements go to the end of the array. If we have three valid elements in this array, then we will directly end without doing recursion. Finally assume we have two valids in the first part and the third one is invalid. Then this program will also end directly without invoking recursion. I think my answer does not have any problem in that regard. Recursion is indeed something that is not coverred in the class so far, but I don't believe this is a valid reasong for taking off all these points.|15|0|private|||0
lfha4lkzhts7j7|Why my curved score is lower than my raw score?||191|0|active|The formula that we use for calculating our curve (Z-score) can sometimes produce a curved score lower than the raw score. Rest assured, your *higher* score will be used in the final grade (in your case, the raw score).||0
lfewtrvvjh587|Question on Midterm 4b|Hello, I submitted a regrade request for 4b but I was rejected. However, I still want to argue a bit for this question..  The comments I got from the regrade request are as follows:. . “Without a constructor for Work, you don't have a meaningful way to store data. So inputpath, outputpath, and id aren't initialized in your class. The constructor is a necessary part of the class for your functions to behave correctly.”. . I think even though we do not have a constructor for Work, the default constructor would still work, right? And in my hand written code I had string inputpath and string outputpath initialized in the private section of the class. . In this case, inputpath and outputpath can still be stored by Message1.inputpath = ..... and Message1.outputpath = .... in functions, right?. . I am still a noob in 280, so please forgive me if I am wrong about my argument, I am willing to learn!. |136|0|active|"With the default constructor, your code would still compile, but it would not work as intended. The Work class is meant to take in an input path and output path when constructed and use these within the handle() function.. . In your submission, you had a string for inputpath and a string for outputpath as private member variables, but these were not initialized with values. This would need to be done within a constructor. I'm not 100% sure what you mean by ""inputpath and outputpath can still be stored by Message1.inputpath = ..... and Message1.outputpath = .... in functions"" but this does not seem like an approach that would solve this."||1
lfbgstt1oew3yq|Exam Regrade|If I posted a regrade yesterday (3.15) and the grader didn't response me until 3.16 which passes the ddl, can I have a follow up discussion or regrade on that question? It's unfair because I have posted it right after the release of grades. But the grader just didn't response to me for a whole day and the deadline is coming soon. If he/she just give a response that is not reasonable, how can I follow up the regrade process?|210|0|active|There shouldn’t be any arguing as to what points you get, and post regrade-scores should be final. Many graders may only view the regrade request after the deadline passes, and that is not at all against policy. If you disagree with your grade for some reason after a question has been regraded, I’d advise you to go to proffice hours.||2
lfbgf017nfh48u|Midterm Exam Corrections|Hey everyone!. . We've adjusted the rubric for questions 1e.3 and 2c.2. In particular, we are accepting answers (c) and (d) for 1e.3 and making (d) worth 0 points for 2c.2. Please take a look at the updated answer key in the Midterm folder for further clarification. . . These changes have been applied to your exams on Gradescope.. . |579|3|active|||4
lfah0i762e55yu|Midterm Questions|Is there any way to view the questions on the midterm, or does gradescope only show our answers?|135|0|active|The W23 question packet is at the bottom of this folder. You can follow along your test with it to see what the questions were asking: https://drive.google.com/drive/u/1/folders/1-h6H-59uXPHdGJcz0yKi2JPEVk8gzhs2||0
lfadq4ibgjyfd|Question 3b|"I didn't get the point for ""Correct incrementing for traversal (using traversal by pointer)"". What does that mean exactly? Was it incorrect to do i++ instead of ++i?"|96|0|active|i remember the question says u must traversal by pointer not index||0
lfa9nrhfbcr3fl|Regrade Policy on Pseudocode during FRQ|Can you receive points for writing pseudocode during the FRQ ?|128|0|active|Depends on the rubric, but for most questions no.||0
lfa9i41fx5h62f|Regrade Requests|Is it possible to lose more points than originally from a regrade request?|141|0|active|It is possible. We will literally re-grade the problem you submit a regrade request for. If we find a major error that is previously neglected, we will adjust scores to reflect that.||0
lfa7r9zy6fs2dn|midterm 3c line 9|"Hello! I read over the solution and rubric for 3c and am wondering why what I did was not correct pointer arithmetic and what the difference (functionally) between my answer and the solution is. bugfixline9.JPG. . Solution:. for (Item* ptr = items; ptr != items + C; ++ptr). . My answer:. for (Item* ptr = items; ptr < ptr + c; ++ptr). . Is the issue with the fact that i used < instead of != or is the issue the items + C versus ptr + C? Since I set the pointer ptr equal to items, what would be the difference between items + c and ptr + c? I didn't get the point for ""Correctly uses pointer arithmetic to detect end of loop"" but I did get the point for correctly uses c to determine the upper bound of loop (Must include C after a “<” or other correct bounding comparison operator). Just hoping to clarify my understanding so I don't make the mistake in the future. Thanks!. "|12|0|private|Each time ptr gets incremented, the upper bound ptr + c gets incremented as well, so ptr  < ptr + c is always true, resulting in an infinite loop.||0
lfa1jjt7zr63a6|midterm question 1b2 why is the pointer pass by value and not reference?||131|0|active|This is an intentionally tricky question. Remember that the value of a pointer is an address. So when you pass like pointer as we do in the question, we are passing a copy of the value. This is evident because if we then did `++mat` within the function, the pointer that was passed in would not get changed (i.e. it would remain pointing to the same matrix)||1
lf9vx0dp5pd2tt|Question Inconsistency 3b)|"For question 3b), I was misled by the text around the question, before the RME. I was trying to respect all parts of the question including the ""Note that the other two elements still technically exist at the end of the array after the function call, but we ignore them and their order."" Which I thought meant that the invalid prices should still exist at the end of the array at the end, with the integer returned being the place of the last valid price.. . Using the given example, and the instructor solution, ""Cookies"" would be eliminated from the array, not moved to the end as implied by ""the other two elements still technically exist at the end of the array"". I thought of something similar to the instructor solution, but discarded the idea since it would not leave the invalid prices at the end of the array. . . I submitted a re-grade request, but have since realized that may not be the proper platform for this question.  Uniquename: clararh UMID: 98978532"|10|0|private|Both swapping and just copying are accepted for this question. What specifically were you marked down on?. . Note: a re-grade request would be a proper way to get a response. An instructor should leave a response when responding to the regrade request. If it is not answered properly, you should follow up here :).||1
lf9rpm1hamd6pf|question 4c|for this question would you have to use the delete operator if you did. message_factory(network[i])->handle();. instead of using the new operator?|139|0|active|I believe the function message_factory is written to return a new object. ||0
lf98tj9rybf5h3|Question 3a - &#34;checking for sentinel after c-string ends&#34; clarification|"Hi, I was just wondering what ""checking for sentinel after c-string ends"" means in code context. In the exam key, I only see it being checked in the while loop (while (*(++price))) and possibly at the end condition (... && !price[3]). In my exam code, I used traversal by pointer that used a for loop with a condition that dereferenced a pointer (sentinel evaluates to false in the truth table, so for loop terminates, thus checking for it?). Would this not be checking for a sentinel value after c-string ends? Just trying to see if I should submit a regrade request, thank you!"|157|1|active|I believe that should constitute getting the point. I'd make the regrade request and state whatever you said here.||0
lf93vjol73u532|Midterm question 4c tested beyond the scope of the exam|"Midterm question 4c requires us to use ""delete"" at the end, and -2 points are deducted if we don't use it. I think this is unfair because the instructor said the exam content would only be everything on and before polymorphism, but ""new"" and ""delete"" were taught after polymorphism. Since they were not said to be on the exam, we shouldn't expect them to be on the exam, and the instructors should suppose us to know nothing about ""new"" and ""delete"" for completing the midterm. As someone who follows the rule of the course, I absolutely didn't review it and never expected it to be tested on the midterm. I believe it is unfair that the exam tests us on this concept and even deducts 2 points if we don't know about it."|226|16|active|"The exams do not only test content explicitly covered in lecture, but also any knowledge gained from completing course projects. Since ""new"" and ""delete"" were used in project 2, students should be able to apply their understanding of ""new"" and ""delete"" from project 2 to the exam question -- mainly, that ""new"" should always be paired with a ""delete""."||0
lf90xz3pzls46|Midterm Problem 3c|Hey, for problem 3c on the midterm, I corrected the error in line 9 as:. . . for (Item* ptr = items; ptr < items + C; ++ptr). According to the solutions, the answer is:. . . . for (Item* ptr = items; ptr != items + C; ++ptr). . Shouldn't my code also result in an equivalent traversal by pointer. If not, why does it differ?. . I lost a point for the rubric item:. + 1 pt Grading comment: Correctly uses pointer arithmetic to detect end of loop. . Thank you!|13|0|private|That should be an equivalent answer and you should get points for that.. . Please submit a regrade request on gradescope!||0
lf906nomuiw54j|Question about 3(c)|Dear instructors,. . Hope this post finds you well. I have a question about 3(c) for the midterm.. . Since it is a new type of question that I never practiced before, I did not know how to approach the solution during the exam. Although I tried hard, the errors I identified were unnecessarily errors but the code I would not write for this type of question. Since the line numbers and bug fixes did not match the solution key, I lost 6 points on this question.. . Although it is my fault not to identify the correct lines and fix the bugs, is it possible that you may grant 0.5 or 1 point for my effort and for not leaving blank answers? Also, may I suggest that you may provide us with some options for possible wrong line numbers in the final exam if we will have this question type again? I feel like identifying potential wrong code could be subjective, although I can fix the bugs immediately if I am given the line of buggy code. . . Sorry for making this long post. Please know that I am not complaining at all and I want to thank you all for your great, enlightening instruction. I just feel pitiful for trying hard but losing most points on 3(c) although I should have known the answer. Thank you!. . Best regards,. Bowen|16|0|private|Hey Bowen,. . We appreciate your thoughtful post. Unfortunately, in a class of over 1500 students we can't make any exceptions with points to ensure a fair policy to everyone.. . We will, however, take your feedback into account while creating the final exam and appreciate your time giving us feedback!. . Thanks,. . EECS 280 Staff||0
lf8zx64bnvb2bn|midterm problem 3c|"Can the is stream not read in strings like "" ""? My solution for 3c is:. is >> items[i].name >> "" "" >> items[i].price >> endl;. and it was marked wrong, and the only difference between my solution and the correct answer is the additional "" "". Thanks in advance."|176|0|active|Reading from istreams skips all whitespace.||0
lf8z0w4sysr5m7|Exam Score|Where can you find the curved mean and the curved standard deviation? Thank you.|293|0|active|it says on the curved score calculator note that you can assume an average curved mean of 81% and an average curved std of 9%||1
lf8yeyuaqtq5xv|Question 1e-3 Solution|"For Question 1e part 3, the solutions say the value of y is ""a reference to w"" after line 4 executes, but I would argue that is the type  of y, and its value is undefined, since cout << y would produce undefined behavior at that point as w was not initialized.  Am I missing something here?"|172|16|active|We plan to correct the solution here and accept two answers.  To offer a full explanation: `y` is a reference to `w`.  `y` refers to an object whose value is undefined.||3
lf8y1nfrt6q5jo|Question 15 1f|Was the syntax for this covered in class? The way I tackled this question was to just put the variables in a vertical line by order of declaration. Because reference variables are aliases and don't actually store something in memory, I just didn't put in some sort of placeholder address/value, and made the reference variable name directly referencing i/j. Wouldn't an actual pointer be holding an address in memory?. . Either way, I know we covered pointers in memory in class/lab, but what lecture covered reference variables in memory? I think I must've missed it.|148|1|active|it's on lecture 1 or 2||1
lf8xkbo9eg3113|curved grade|when and where can we see the grade of the curved midterm exam score?|295|0|active|At the very earliest, the curved exam score will be decided after all regrades have been completed, which will be in several days.||0
lf8xj5uu2gl3go|How to use the grade calculator on the website?|Hi,. . I am trying to calculate my grade but I got results that make me confused. Because when I tested it by entering the maximum grade of each section, it still shows the final grade is E. Did I do something wrong? Can someone help me with this please? |197|1|active|Are you entering your scores as percents or decimals? For example, for 100% you should input 100, and not 1, and for 98.2% you should input 98.2, not .982||0
lf8x9hmmesqyn|Question 3b Declaring two Pointers to Traverse?|"On question 3b, Gradescope states that you must "". . . . . Initialize first traversal Item pointer (for traversal by pointer)"" and ""Initialize second traversal Item pointer (or counter)"". The exam solution uses a while loop then with these two pointers.. . . . . . What is wrong with using a for loop and only declaring one traversal pointer? My loop header is like this:. for(int *ptr = itemList; ptr < itemList + numItems; ptr++). . Would this not work effectively?. . This could also be a grading error, since I created a counter variable at the start of the function to count the number of valid items to return at the end of the problem, but I want to make 100% certain. Thanks!"|168|1|active|I did basically the same thing and didn't get any points. I did int idx = 0 and then increment it and my for loop is same as yours except I used item *ptr = itemList instead of int *ptr||1
lf8wy5bni19153|1e.3|Hi, I was wondering if there is any way I can argue that the answer to multiple choice 1e.3 is c: undefined. I chose this because the question asked about the value of y. Wouldn't the value of y be undefined, while y itself is the reference to w. |5|0|private|If you believe the grading was incorrect, please submit a regrade request through gradescope!||0
lf8wvwuwwgv3m4|Grade Question|"Hello, I calculated my grades on the website and it said below the threshold to earn C or better. However, in the spec, it says that ""To pass EECS 280 with a C or better, your total weighted project score must be at least 60.0%, and your total weighted curved exam score must be at least 70.0%. 65.0% (adjusted for W23)"". . . So which one is correct? Can anyone explain this please? "|263|0|active|so your overall all grade in the class, including labs an all must be at least a C. In addition your average exam score must be a 65 (with curve), and your average project scores must be above 60.  You need to meet all three components to pass 280. (I think)||0
lf8wtl1umwh1t2|Midterm Grades Released|Midterm grades have been released to Gradescope! If you have any problems viewing your grades, please email eecs280staff@umich.edu. NOTE: Regrade requests are open now. You have the next 48 hours to submit regrade requests. Due: Thursday 3/16 @ 8pm.. Midterm exam question and answer packet are in the Midterm folderMidterm exam corrections are in @3064. If you would like to calculate your curved score and estimate a letter grade, you can go to https://eecs280.org/calculator.html.. . Please use the following statistics (before corrections) for your calculation. The CURVE_MEAN is 81% and the CURVE_STDEV is 9% for the midterm.. . Statistics (before corrections):Minimum: 10.0Maximum: 100.0Mean: 68.86Median: 72.75Standard Deviation: 16.79. . Statistics (after corrections):Minimum: 11.0Maximum: 100.0Mean: 70.23. Median: 73.88. Standard Deviation: 17.17. . |800|2|active|||2
lf8wkn16845da|Question 4c|Can someone explain why I can’t declare a pointer outside of the loop and then reuse it after deleting the old one?|8|0|private|I don't see why you can't declare it outside the for loop, I would request a regrade.||0
lf8wi5dxcmf5zq|Curve google sheet|Made this sheet to curve the exam, just make a copy to use.. . https://docs.google.com/spreadsheets/d/1sUpvbJeNkeqSN5c38IAPGaEJS_5BWJkI9bA4vLFzHF0/edit?usp=sharing . . Don't know id this is exactly right, just followed what website said.. . |293|10|active|||3
lf8w3odbzks1i9|Question 2c.2 mistake|According to the answer key, ACDE are correct, but Gradescope takes off points for the answer choice D. |219|0|active|The original exam solutions were incorrect, the answer key has now been updated.||1
lf8vrscpo8cfj|Exam one raw score|Hey, quick question, are the exam scores curved at all, or is our raw score our actual score. |309|3|active|It says that a curved score will be posted on canvas but you can estimate your curved score using the calculator on the eecs280 website that was attached in the email ||2
lf8vo907vka5v3|points off for question i got right?|hi i got points off for question 2c.2 but my answer is exactly the same as the solution key?|7|0|private|Please submit a regrade request if you believe the grading was incorrect -- it's easier for us to keep track of that way.||0
lf7q1tsab093m9|Exam Solution Posted|Hey everyone,. . The exam solution is now posted under the Exam folder in the EECS 280 Google Drive. We're working on wrapping up grading by tomorrow.. . Have a great night!. . EDIT unpin|669|2|active|||6
lf7lxn8bdgz677|Exam Scores|Does anybody know what day and around what time midterm scores are coming out?|278|0|active|They stated in one of the notes they plan to release them tomorrow night.||0
lf0kwyf11jy3qv|Curve?|Someone on reddit said the average would be curved to 70%, is that true?|14|0|private|From the syllabus,. . After each exam, we may adjust your score to account for the difficulty of the exam. In general, our goal is a mean in the low 80's. We will never adjust scores downward.. ||0
lf0avpty3t0275|spring 2019 Q1-c|Could you explain why inside the longest_string is argv+3 and argc-3? Thank you!. |260|0|active|This is because argv + 3 will always be the first string you are looking at, the first three arguments are the file name, the output text and the integer (and always will be). Since agrc is the amount of arguments, there will always be 3 less than argc in the array of strings you are trying to find the longest of. ||0
lf09p3jilinvv|spring 2019 0c 1|. Could you explain why Q1 has an error? thank you!. |183|0|active|There's no constructor that takes 2 parameters :)||0
lf08qrua98c9g|Admin response|Is it possible for an admin to check the admin email? I wanted to know something before the exam today at 7. Thank you!|314|0|active|||0
lf08gmjtkp61xv|Spring 2018 MC Q13|The answer is nothing (option e) but I don’t understand the explanation they gave us in the solution. Can someone explain ?|148|0|active|argv[1] is pointer to ‘o’ in one\0. This is a c style string where there is a null pointer at the end. When you increment by 3, you reach the null char. Trying to cout a pointer pointing to null char prints nothing.||0
lf08bkoyz1y1wg|Lost Mcard|Hi! I lost my Mcard, so would it be okay to show up to the midterm with my UM ID memorized and with other forms of identification (i.e. drivers license)?|280|0|active|If you can't find your M-Card, then yes, that's likely best||0
lf085poo1ne4fa|What is the difference between Compule Error and Undefined|For MC, I keep seeing these two options but I don’t really know how to differ them |149|0|active|Compile error kind of means the code has some syntax errors and it cannot compile. Undefined means that the code compiles (meaning syntax is right) but there are parts in the code that produce behavior we cannot expect. For example, accessing outside an array is undefined since we don’t know what’s there.||0
lf084npg6ke3fz|Spring 2019 frq 3c: how is num_artists&#43;&#43; be getting the next artist?|I thought the order of precedence was that it does -> first, and then increments. So, wouldn't be getting the wrong index in this case? Or am I interpreting the ordering wrong? (actually I do think xyz++ comes first, and then the ->). . |106|0|active|It first initialize, then increment the num_artists. It wouldn't get the wrong index.||1
lf081a5ohtp69m|fall2019 0b problem 10|May I ask why 0b problem 10 is b? I think it shoud have a '0/' at the end.|76|0|active|Check out @2404. Follow up if you have any additional questions!||0
lf07agzfgav5cm|Derived Class|Can derived classes access private variables of the parent class?|118|0|active|No.||0
lf06wcixxi93ey|Spring 2019 4d|for the last one in 4d, I understand sound_effect() is a virtual function, but when ptr->play(), since there's no play() in FighterBot class, it calls the play in Robot class. So for the sound_effect inside the Robot::play, how could it run the sound_effect from Fighter bot?. . |83|0|active|sound_effect() is a virtual function that is overridden in the FighterBot class.. . This means that the function is going to check the dynamic type of this -> (the pointer to the object that invoked the function).. . In our case, the dynamic type is a FighterBot so it will call the FighterBot function.||0
lf06oq1sggh6tu|memory diagram|Are we required to include address information in the memory diagram?|124|0|active|||0
lf065yz6dz0h5|string length|Hello,. . In exams, if we will use length() function on a string, do we need to case it to int? Thank you!|109|0|active|||0
lf063j8sqx570d|Spring 2019 4b|"Why there's no ""Toy::"" before we call get_year_made? It's a public function from base class. . . . . . From spring 2018 4c, here the derived class giftcard use ""MoneyContainer::"" when calling public function transact() from its base class MoneyContainer. it's a similar case, so I'm kinda confused.. "|108|1|active|In the first example, consider the two classes Robot and Toy. In class Robot, there is no function called getYearMade(). So, when we call getYearMade() in class Robot, the compilers knows we are referring to the one in the base class since it is the only getYearMade() that exists. To sum this up, we don't include Toy:: cause we don't need it in this case.. . This is not the same as the second example however.. In the second example, we have two classes MoneyContainer and GiftCard. But notice, how each of these classes has their own version of transact(double amount). So, the compiler doesn't know if we are referring to the one in the base class or derived class. To help the compiler figure out the one we are referring to, we use MoneyContainer::transact(amount).. . Extra Info:. To go more in depth with this second example, we can recognize that we actually need MoneyContainer:: for our function to work correctly.. To help understand why this is the case, consider what would happen if we removed the scope resolution operator from the function call..  First, suppose we have some GiftCard gc;. Then, suppose we called gc.transact(5.5). This would cause an infinite loop. Because of our function call, the compiler will look at the dynamic type of the object (since the function is virtual I believe) and it would see that the dynamic type is GiftCard. As a result, it would call the transact function in GiftCard over and over again.||0
lf060f31jbcm3|Similar expressions in terms of arrays and pointers|"Hello,. . I just want to check my understanding of certain expressions where they look very similar but have different effects. . . const char *arr[5] = {""hi"", ""hello"", ""hey"", ""hi hi"", ""hola""};. cout << arr[1]; // prints hi **type in original post, this should print hello. cout << &arr[1]; // prints address of hellocout << arr[1] + 1; // prints ellocout << arr[1][2]; // prints lcout << *arr[3];  // prints only the first letter of hi hi, so h. . Am I correct in what each prints? Also, are there any other examples that I might've missed? "|73|0|active|"This looks mostly good.. . Some things I noticed in your answers though:. . Your first statement prints hello, not hi (but I believe this is just a typo since in your second answer you say that arr[1] gives ""hello""). . The second statement doesn't technically print the address of hello since ""hello"" is multiple chars that each live at their own place in memory. So, instead, it is probably more accurate to say that it prints the address of the first character"||0
lf05fxzr9fe75m|atoi() function|do we have to include #include <cstdlib> in our response while using atoi()? |101|0|active|I do believe it is recommended yes. Most midterm questions will tell you when you should just assume things are #included IIRC.||0
lf05araqn052yd|spring 2016 5b|why does C cout false? . I figured out that is_loud is non-virtual, so it will look up in static type. Is it the reason?. |61|0|active|yes I think so||1
lf056vtwnfp5t|override keyword|Given that we can't use the virtual keyword when defining a member function outside of the class, are we also prohibited from using the override keyword in this case?|71|0|active|That's correct! The same restriction applies to the override keyword.||0
lf04jbjjsmuk4|Spring 2018 3c|Would I be breaking the interface of the runner class if I have Runner_set_time(&race->runneres[id], time); in replace of what's written here:. |63|0|active|Runner_set_time(&race->runners[id], time) doesn't necessarily do what the RME asks.. . The code above assumes that runners is indexed by id. That is to say, runner with id 0 lives at index 0, runner with id 1 lives at index 1, etc.. . However, it doesn't seem like this is necessarily the case. So, to ensure our code works, we must use Runner_get_id();||0
lf04f1aap6y4x0|Spring 2019 1A Explain *ptr in for loop|Can you explain why this syntax makes sesne.. I understand you can have something like while(*ptr){}, does that same logic hold for FOR loops? why not have ptr < some end ptr?. for(const char *ptr = strings[i]; *ptr; ++ptr) {++count;}|70|0|active|(*ptr) is basically saying (ptr < null character)||1
lf03304pwqh6gk|Spring 2019 0b #1|"int * apple(int a, int *b) {a += 1;b += 1;return &a;}1. int x = 2; int y = 3;apple(x, &y);cout << x << "" "" << y << endl;Since apple(x,&y) returns the address of a, which is a local variable, why does this not result in undefined behavior?"|83|0|active|It wasn’t assigned to anything. Hence, there is no way to access it. Accessing it is the undefined behavior part||0
lf02s65anne1de|Cant find my room AH AUD B|I was looking online to try to find where my exam room is but when I search AH AUD B a bunch of different locations show up. Could someone help me find the building this is?|118|0|active|If you enter Haven hall from the diag, walk straight past the vending machines, and fishbowl. It'll be to your left, there are 4 auditoriums there. ||0
lf02puyegw33h9|Spring 2016 1c|why the answer is varA? I thought it was varE. |60|0|active|varE is a reference and not a pointer. It’s another name for a char. Recall that arrays decay into pointers, hence a pointer-to-char can also be interpreted as a pointer to the first element in an array of char.||1
lf02bfn16o13qn|Fall 2019 1a|In this question, wouldn't the first for loop that copies from pos to the end also copy the null terminator then from src? Wouldn't we want to end the loop one short of the actual end of src to avoid copying the null terminator since we'll want to add it at the end on our own? When I ran it through an actual program online, it copied the null terminator and added an extra space.. . |71|1|active|The first for-loop in the solution function does not copy over the null terminator. This is because the str_len function does not include the null-terminator as part of its size. Adding the null terminator at the end of the function is necessary for making dst a valid C-string. ||0
lf01weloaej7o7|Spring 2019 Q0c|"Here print is a public function of the class, but the question says that assume these snippets are outside the class, so why don't we need the ""::"" when we call print()?. . "|66|0|active|print() is not a static function. Since you have an object, you can call the print() function for that object.||1
lf01era8ntr3kn|Spring 2019 0b1&amp;2|Why these two would not cause compiler error? apple and banana are not void function, they have a return type, but here they are just directly called.. . |69|0|active|Just because a function returns something doesn't mean you need to use it. It's questionable style, but you're allowed to do it.||1
lf00xyg5vtu7pe|Undefined behavior when printing address of a character|Why does printing out the address of ch result in undefined behavior when ch has an address in memory?. . |92|0|active|It's undefined behavior because cout sees this as the starting address of a C-string, since you have passed it a char *. Since this variable does not end in null terminating character, it will have undefined behavior.  ||1
lf00xc8s7u57bl|lab content|. May I ask why 's' changed to '/0' but not 2 change to '0/' after ptr increment by one? The memory diagram still shows that ptr points to 2 after increment by one.|88|0|active|It's hard to tell without the original source code (Lobster replaced the variable deference with its actual address), but something like a postfix increment could've happened (the dereference uses the old value of `ptr` but `ptr` is still incremented).||0
lezxconz1wm4gu|Are constructors of base class inherited from derived class|I saw an explanation on an earlier message but I am still a bit confused can someone clarify? |95|1|active|They are not inherited. They are called implicitly when you create a new instance of a derived class.||0
lezx9vmsspox9|fall 2019 4c|In the answer to this, they initialize hingeOpen before aspectRatio, but in the Laptop class private members, aspectRatio comes before (above) hingeOpen. I thought we were supposed to initialize them in order of appearance. Does it go from bottom to top or does the order not matter?|98|0|active|@2713||0
lezx74ukir13t3|Spring 2018 4c - override|"Can we omit the ""override"" after (double amount) here?. . "|104|1|active|The `override` keyword is always optional, but a good practice to include. Your code will still compile/run the same with or without it if everything else is correct.||0
lezwtnefnim2ob|Fall 2019 1a|Can someone explain what does *(dst+dst_idx++) do? How can we split it into two statements? I'm really bad at understanding ++x and x++ since eecs183.... . |76|0|active|I'm not sure why they combine statements and make it unnecessarily difficult to understand. Pretty sure that line could be broken down like this:. . . *(dst + dst_idx) = *it;. dst_idx++;. ||0
lezwk0rpgai60e|Question 3B on review sheet|Would we be able to use indexing and a temp variable for this problem since it did not specify using indexing by pointer? For instance would this code be valid? |74|0|active|||1
lezwe8yshdzk|Explain please|"For this function, why would the bold lines not be included in the for loop?void readFromStream(istream &is, int N) {string str;while(is >> str) {cout << str;cout<<"","";for(int i=1; i<N; i++) is >> str;}}"|93|0|active|Because the for loop's purpose is skipping these words||0
lezw6vdy6z82lp|const char* cstr = &#34;Hello&#34;;|"When declaring a C-string as a string literal like. . . const char* cstr = ""Hello"";. is the ""const"" necessary to compile? I understand it would be bad practice to remove the const, since that would lead to dangerous potential changes, but can the code compile without the const?"|74|0|active|g++ alone without the -Werror flag will throw a warning but still compile. The makefiles we get with the projects use the -Werror flag, so it won't compile with warnings present. ||0
lezvwxnwj5941y|Sp19 1a Solution Error?|. As far as I can tell, for the case [“abc”, “a”], this solution would return a pointer to “a” because it looks at the length and finds 1 > 0. Wouldn’t the initial length need to be set to the length of the first string and not 0?|80|1|active|Yes, you are correct. It looks like this code actually skips counting the length of the first string and assigns it 0. A couple ways you could get around this is by initializing ‘length’ to be the length of longest before iteration. Even simpler, you could change the bounds of your ‘for-loop’ to include index 0:for(int i = 0; i < num_strings; ++i){||1
lezvwsvi3xg3kq|Spring 2018 Q4c|Do we always need scope operator (::) to access public function of base class?. . . |70|0|active|Not always. If “transact” was a member function of the GiftCard class (and we wanted to call that function), we could just do “transact(amount)”. The reason that “MoneyContainer::” is added here is because it tells the compiler which namespace it should search for to find the “transact” function. In this case, it would call “MoneyContainer”’s “transact” function.||1
lezvdlhl6ro7df|Midterm question clarification|"I saw a lot of ""You may not..."" in practice exams, do they mean we shouldn't do something(like, if we use strlen we would get points down) or we can still use them but it's not necessary?"|110|0|active|When it says “You may not”, you are not allowed to use it (i.e., if the question states “You may not use strlen()”, you would lose points for using strlen()).||0
lezvccuwppm45o|Spring 18 3(b)|Hello,. . For 3b, can I do this to update runners:. . Runner r;. Runner_init (r, name, gender, id);. .... race -> runners.push_back(r);. num_runners++;|64|0|active|Runners, in this case, is not a vector. Rather, it is an array, and although the two are very similar, they are not the same. As such, it would be best to do something like:race->runners[num_runners++] = r;||0
lezv6xffiz62s7|Spring2018 Q3c - new pointer variable?|I didn't create a new pointer runner, instead, I use if(Runner_get_id(&race->runners[i]) == id){...}, will I get points off?. . |46|0|active|Probably not, considering that the question doesn’t explicitly ask you to create a pointer. As long as you respect the interface for the Runner ADT, you should be good.||0
lezv1f8gaop1ni|Can someone explain when to use virtual and what it does with override?|I found the explanation on the review session very very confusing and would like some clarification. |73|0|active|I personally just don't use them in any functions in derived class...||0
lezutw7h4ck5av|Can a non virtual function be overridden if it is marked override?||63|0|active|No, it will override the virtual function in the base class (assuming the non-virtual function is in a derived class and there is a virtual function with the same signature in the base class). Non-virtual functions cannot be overridden by other functions. ||0
lezutqd2k9137l|Function Override|When dealing with function overriding when do we need to include the word override and when can we leave it out? |55|0|active|Override is technically optional, but is good practice to include. Either way, your code should still be able to compile and run normally. See @2853||0
lezur7g2a9q6xs|Spring 2018 Q3b|Why we don't need to increment num_runners by 1 after we initialize the runner?. |49|2|active|It is being incremented in the Runner_init(...) line. When indexing runners, the solution uses num_runners++, which means that after the new runner is initialized, num_runners is incremented by 1||0
lezu7d207a34y0|calling const vs non-const functions|For this example, how do you call the void greet() const function, as opposed to the void greet() function? Thanks!. . |52|0|active|It chooses greet() const when it's called on a const Person object.||0
lezsbbc69mw2je|derived class pointers|Using the bird examples from lecture, if we have a pointer that is pointing to a Duck can assign a pointer that points to a Chicken to it? like dPtr = cPtr? or dPtr = &chicken? |63|0|active|"I don't think so as this would violate the ""is a"" relationship. "||1
lezo2tbx5gc5xw|confused about this for loop|how does this for loop work?. . |85|2|active|See @2716||0
lezbwuoxue13it|Spring 2018 FRQ 3B|When calling runner_init, why do we have a address-of operator when race is already a pointer?. . The solution shows runner_init(&race->runners[race->num_runners++], ....|62|0|active|When you use the square brackets [], it is dereferenced and becomes an object rather than a pointer. So, you would need to use & to turn it back into a pointer.||0
lezatnw14eajj|Spring 19 problem3|By having a pointer f_ptr, why are we using & instead of * to set the value of new artist in the second solution? I mean, we have a pointer and we want to set value to an element in array, why not dereference?. |48|0|active|||0
lez9m50790j3ff|Practice Exam F19 Q1B|Screenshot_2023-03-08_005132.png. . For the first if statement in main() where we're checking for if there are enough arguments. Why do we say (argc != 2 & argc != 3)?. . Why don't we say if (argc < 2) or (argc != 1 && argc != 2)? Do either of these 2 solutions work? If not, why?. |85|0|active|Those two solutions would not have the same intended effect. argc includes the name of the executable, so if you want one or two extra arguments, your would check that argc is 2 or 3. Checking 1 or 2 would not work as having no arguments would have argc = 1.||1
lez9ixvha782rp|Spring 2018, Q21|Hi,. . Could anyone please explain why choice A (count << flower << endl) is incorrect? Thank you!|71|0|active|"I just figured it out and I think it's helpful to leave the question here. The reason is that Flower doesn't override ""<<"" operator so we can't print it out. However, we can print out the address/pointer of Flower since it's simply some numbers."||0
lez9enhsx066k6|Spring 2019 0c - 5|I put error for this one which is correct, but I'm not sure if my reasoning is accurate. I said it had to be an error because there were no private or public member variables that allowed an array of certain length to be declared. Is this correct or is there another reason as to why there would be a compile error here?. |84|0|active|That's incorrect. The reason why this produces an error is because when this snippet makes the array, it tries to create RollerCoaster objects using a default constructor that does not exist. So, if a default constructor existed or if each element was constructed using one of the given constructors manually, you could create an array of RollerCoaster objects.||0
lez90t7ktbky1|Compile Error: binding a non-constant reference to a prvalue|int arr[3] = {1,2,3};. int &b = &arr;. int *c = &arr;. . The compiler says that I cannot bind a non-constant reference to a prvalue. What does this mean?. . |53|0|active|"This is really off topic but I was bored and looked it up anyway.. . . int &b = &arr;. Above, you're trying to pass the reference to an array's pointer. It's like asking for the address of an address? Because passing the name of the array is the equivalent of passing a reference to its first element, it's the equivalent of saying:. . int &b = &(&arr[0]);. Which just doesn't make sense. This has no identity (and is moveable), so it's called a prvalue, or a pure value.. When I tried it in my compiler I got the error ""Error (active) E0461 initial value of reference to non-const must be an lvalue"". An lvalue is a value that has an identity (and isn't moveable).. . ""Lvalue and Rvalue refer to the left and right side of the assignment operator. The Lvalue (pronounced: L value) concept refers to the requirement that the operand on the left side of the assignment operator is modifiable, usually a variable. Rvalue concept pulls or fetches the value of the expression or operand on the right side of the assignment operator. For example:. . age = 39. "". . Instead you want to do:. . int arr[3] = {1,2,3};. int &b = *arr; // dereference the array, which is a pointer . Now b is a reference to an lvalue. Yay."||0
lez8q628ire6x2|spring 2019 0a|In #1, why is x still printed out as 2 and not 3? Doesn't its value increment? Also, how does returning &x impact the answer?. |65|0|active|For x, it is passed in by value as a so the increment made is not saved. The return statement does not matter to part 1, it's return isn't assigned to a variable so it isn't even saved. ||0
lez8egad8uh52p|Spring 2019 Q0a6|Could someone explain why this is wrong? Thanks.. |60|0|active|This is false because it is possible to change the value pointed to by ptr2 since ptr2 is not a const. So the value of object pointed to by ptr2 (5) is changed to the value pointed to by ptr1 (2).||0
lez80od2ojg2ry|Initializer list for structs, vs for classes?|"Are these two kinda different?. . For example, with structs, we have something like. Person Joe = {13, ""joe""}. . But for a class, it's the member initializer list:. Person Joe(). : age(15) { }. or like. Person Joe (int age_in). : age(age_in) { }. . Are these two things kind of different? As in, is the way we do it different btw structs and classes like this? Or else when would we use one or the other?"|78|0|active|For a class, the member initializer list is part of a constructor member function, assigning values to member variables. With structs, there are no private members so you can directly initialize the variables if you want to without going through an interface or Person_init function, for example. I think functionally, the two methods of initializing variables are pretty much the same, it's just that with structs you can do it from outside the struct while with classes things are more protected. . You should use a member initializer list in class constructors and when initializing a base class when working with polymorphism. You're actually required to with the base class initialization. . If possible, when working with structs, it's best practice to use a defined Person_init function to respect the interface, but directly initializing is also technically allowed. ||0
lez7ho04zq65if|Finding Lecture Recordings|I am struggling right now, to find some the lecture recordings. I was hoping to be able to find some of the course recordings as well as the review session from yesterday to hear the discussions. If anyone is up and able to help me find them, I would greatly appreciate it!|75|0|active|If you go to eecs280.org, you should see the play button next to in-person under lecture tab. If you click that, you should find all the live recordings so far!. ||0
lez76y5vzgz5hl|question about command line|I am confused about the index and increment of argv pointer.. For instance, if we want to access the second c string in argv, we can just use argv[1].. but what about argv++, does that will get the same result?|49|0|active|Since argv is an array of char pointers, that will work since you would increment the 8 bytes from the start of the array to the next char pointer. ||0
lez6psp4lr16xo|lecture notes about pointers clarification?|"hi, i was reading over the lecture notes to review for the exam & i'm confused about this example. i understand why the new get_address function works (has parameter &x instead of x like the example before (was the exact same code just with the parameter difference), which results in UB), however i don't understand how this code even compiles. at the line ""int * ptr = get_address(a);"" wouldn't the program not work because you're passing in the value a, rather than the reference &a, and thus the input doesn't match the required function parameter? can someone just explain why this would work? thanks! . . "|68|0|active|"There isn't a typo, this code is valid. When parameters are a reference type, we can think of this as meaning we must pass a variable into this function.. . To see this more clearly, read the parameter from right to left. The parameter x is a reference to an integer. So, to satisfy this, we must pass something that that ""references"" some chunk of memory AKA an already declared variable.. . Alternative Train of Thought: when we have a parameter such as int &x, we are telling the compiler to NOT make a copy of the variable in the function calls stack frame.  But, we still want to be able to refer to this variable x in our function body. So, to keep our promise of not making a copy, we must give the function an already declared variable to use for x."||0
lez6aq7k5am1co|Spring 18 FRQ 2b: why can we do &#43;&#43;begin if begin is const?|Actually is this because the const int * begin means that we can change where we're pointing to, but not the value? And ++begin follows this, where we're changing where it's pointing to.. . |52|0|active|I would read it like this.. . The integer that begin points to is constant. But, that doesn't mean we can't change where begin is pointing to.||0
lez5j7rxm3251s|Spring 2019, 4b|"Hello,. . For 4b, can I use getters to decrease battery level instead of doing ""battery -= 20""? I also noticed that the getter method is const, does this mean that I can't use it in this case? Thank you!"|60|0|active|Get returns a value equal to the battery level. This means you aren't actually accessing the battery level variable at all when you use the getter, so you don't want to use it in this case. Getter functions generally don't change the value of a private variable, which is why it's declared as const. ||0
lez5i0njm0r23w|Spring 2019 Q4|How would we implement this fighterBot constructor? Since name and yearMade are private variables of the Robot and Toy class respectively, I thought the only we can initialize them is to call the Toy constructor. |54|0|active|You would call the constructor for Robot, and pass in both values. That way, when the robot ctor executes, it automatically calls the Toy ctor to initialize year.. . Generally, we only call the ctor for the base class immediately above the class we're working in. If all ctors in a series of derived classes follow this rule, we naturally run up the chain of command (ike the example above) when we initialize an object and make sure the right classes store the right values. ||0
lez5foloby23wz|Array vs pointer arithmetic|Does it matter which implementation strategy we use on the test? I've been solving the review questions using pointer arithmetic, but the solutions are using array arithmetic.|50|1|active|It doesn't matter which strategy you use unless it's specified in the problem to do it a certain way. As long as your solution works!||0
lez57885u8k6u7|Dereferencing a null pointer (nullptr)|Why is it NOT a compile error? But I think undefined behavior?|77|0|active|It's not a compile error but a runtime error. This is because at compile time, the computer doesn't actually know if the pointers that are being dereferenced are null or not - the values are only actually updated when we begin running the program and changing things around.||1
lez54prhogl2h3|Override|"What happens if we override a derived class function that has the same signature as the base class function, but takes in a different parameter?. Here is an example: . . class Bird {.   ....   virtual void talk() const;. };. . void Bird::talk() const {.   cout << ""bawwk"" << endl;. }. . class Chicken : public Bird {.   ....   void talk(string name_in) const override {.     cout << ""bawwk"" << endl;.   }. }. Does this work?"|66|0|active|I believe you would get an issue because of your inclusion of override.. . Override will check the base class to make sure the signature (not just the name) matches. Since the signatures don't match due to difference in parameters, you will get a compiler error.||0
lez532edo463vf|Why is string argv[ ] the same/why does it also work?|Are c++ strings also basically just arrays of chars? Or no? Not sure if that's related to why this is string argv[ ] also works.|61|0|active|string is a class given to us by c++. Conceptually, you can think of a string as a sequence / list of characters. But, in the actual underlying code / implementation for the class, I do not believe that they are actually arrays of characters. There is much more information online but string is implemented with buffers.. . string argv[] doesn't compile when used as a parameter for the main function. You could say that outside of the parameter of main, this declaration is valid. It gives you an array of strings that happens to be titled argv. However, I believe that in the parameter for main, argv can only be written as char * argv[] or char **argv[] as that is the parameter type that is expected by the compiler.||1
lez4ivudaooxx|spring 2019 3c|In the solution to this question, I'm confused about why we use &f_ptr -> artists[fptr -> num_artists++] instead of using f_ptr -> artists[fptr -> num_artists++]. f_ptr is a pointer, why do we still need to use &f_ptr->? . |38|0|active|When you use the arrow (->) on a pointer, you're dereferencing that pointer to get the value. Without the &, you're passing in a value (an artist in an array) when you want to be passing in the address of the artist instead, which is why you include &.. . It seems a little repetitive since you're dereferencing a pointer, accessing an object's data, then converting back into an address, but this is how we can obtain the pointer to the artist we want all in one call.||0
lez4i1x5u7f3dw|Spring 2018 Exam Written Problem 2a|Instead of result = array + i; on the fourth line, would we be allowed to say result = array[i]? Or would that set it equal to the value and not the address?. . . |45|0|active|You need the address, so you could do result = &array[i]||0
lez4gj1yuaf4l9|Spring 2018 Q2b|"If I create a pointer like this, would it be fine? it says ""Your implementation may nor create any new arrays or other containers"", would this be considered creating a new container?. . . . int count = 0;. for(const int*ptr = begin; ptr < end; ++ptr){. if (*ptr == item){. count ++;. }. }. return count;"|50|0|active|Yeah that's fine. You're making a pointer to a const int, which isn't an array or any kind of container. ||0
lez4d20nq12296|spring 2019 0b 5|I am not quite clear why arr == banana(*arr, arr) is true. I know that banana(*arr, arr) returns the address of c, which is the reference of arr. So can we assume that the address of a variable b, which is the reference of a, is the same as the address of variable a? . |70|1|active|@2666||1
lez4asgh1fj239|for loop without initialization|I saw many for loop without initialization in the key. what does they mean?. |34|0|active|The begin variable already exists, so it does not need to be initialized. For example, these are the same (except in the second one, the scope of i is only in the for loop):. . . int i = 0;. for (; i < 3; i++) {.   //.... }. . . for (int i = 0; i < 3; i++) {.   //.... }. ||0
lez48ez2s0w6za|spring 2019 0a 2|I'm confused about what a function returning a local variable by reference mean. Can you give me a specific example? And why is it true?. |60|1|active|Lets say you make a function like so:. . int& func() {.     int i = 1;.     return i;. }. . and in some other function you have:. . int& x = func();. . This won't work because the lifetime is local, so as soon as the function ends, the variable i is deleted, and now x points to an object that doesn't exist.||0
lez3uds0gpk59u|Spring 2018 FR 4c|Could anyone plz explain what is meant by the RME and why the return looks like that? Thanks in advance! I felt quite confused about what we should do here.. |67|0|active|For the transaction to add money to your balance, the amount must be positive. This is why we make sure amount is <= 0, as this is how we guarantee we're not adding to the balance. Secondly, we just call the other transact() from the base class (using the scope resolution operator, as this is how we don't accidentally recursively call the transact we're implementing), because it handles the rest of the behavior we want. ||0
lez3u177czy3v2|question about running a inheritance example on the lobster|"I've tried to run an L09.1_Birds example on Lobster. But my code of Chicken c(""Myrtle"") caused an error. But I'm confused about what was wrong. Can you give me an explanation?. . Also, I notice that in the Base Bird class, the constructer is Bird(const string &name_in) while in the derived Chicken class, the ctor is Chicken(string name_in). I understand that we pass by reference in the Bird constructor class instead of making a copy. But I am curious about whether there are differences in the implementation of calling the ctor that is passed by reference and calling the ctor that is passed by creating a copy. If the string is passed by reference in the ctor, can we create a variable like Bird b(""Big Bird""), or do we need to create a string s = ""Big Bird"" and then create it like Bird b(s)?. "|35|0|active|||0
lez3qcpwuqh23x|Shouldn&#39;t this give me the wrong output? (missing null char at end of c string)|Here, my str is missing a null char. But, it still prints 3 as the length, which is correct.. . Why is it actually getting the right length? I thought it was suppose to be undefined behavior, with the while loop in strlength since it might not appropriately stop after our reading. Unless it's by luck, or something else is playing a role?. . |47|0|active|||0
lez26hs7zm35t2|Spring 2018 Q21|"I chose E - None of the above and I have no idea why the it's C. How are we gonna cout the ""&flower""? It's not a single value like int or double, I think the only way to print it is to call a print function because we can't cout it directly, so I'm confused here.. . "|52|0|active|In C you are printing a pointer, which is always valid.||0
lez1wspuqsg666|Fall 2019 4d part 2|Why does the second part result in a compiler error?. . . |61|0|active|There is no argument for MakePhoneCall which requires an argument||0
lez16wivi822wx|Liskov Substitution Principle - Subtypes v. Derived Classes|"I am a bit confused on the difference between a subtype and a derived type/class..... It seems we defined a subtype as a type that has ALL functionality of the base class and then can have additional functionality as well. In lecture 10, a derived type was then just stated to ""inherit some members"" of the base class. I am confused because I thought that a derived class had to inherit all functionality of the base class and then could add more functionality as well, but the definitions above I re-read from lecture 10 seem to contradict this. Am I mixing these two up somehow?"|42|0|active|||0
lez0zgty8b92av|fall 2019 0a 7|"Could someone explain what this explanation means for question 0a part 7? For reference, the statement was ""Although not all abstract data types (ADTs) are implemented as structs, all structs are examples of ADTs. """|67|0|active|I think it means that their wording was unclear so they would give points no matter what you chose.||0
lez0yk6lqz46v7|spring 2019 q4|resolved|40|0|active|Resolved.||0
lez0xn6e47t5sm|call stack|I'm wondering if it's a runtime property. |35|0|active|||0
lez0w3y9z6x4d|Fall 2019 Q0a #2|. Why is it int and not int *?|51|0|active|Dereferencing the address of an integer gets you an integer.||0
lez0pregg5v7u|Midterm Anxiety|Hello everyone, this is a personal note and has nothing to do with the contents of the exam..  . I've gotten to talk to a lot of you over the past few months, but it's easy to feel lost in the crowd when classes are so big. Hopefully you've found some satisfaction in your work. Maybe you've decided programming wasn't what you enjoyed most. That's okay too..  . I've been working on my degree for 7 years now (not all at UM), and over those years I've been suspended after failing all of my classes in one semester (that one was at UM). It happens..  . Some of you may be feeling awesome about this class. I'm so happy that you've found your place here and I hope to see you again before I graduate. You belong. I encourage you to keep looking for your fun in all the projects you face. As you get further, these projects are going to be increasingly open ended in this class and beyond. Past that, I encourage you to work on your own projects (I made a Twitch plays Super Auto Pets bot that uses OpenCV image recognition). The real learning is gonna happen when you do the things you love..  . Some of you may be feeling not awesome about this class. It's easy to forget that these topics are meant to be difficult. I've had a ton of office hours this semester in which I'm just as stumped as you guys and I've been teaching these topics for a long time. I've heard a lot of people mention feeling left behind. More often then not, if you come to me with a question, you're not the only one to have it. I can substantiate that claim with an overwhelming amount of anecdotal evidence. You belong just as much. CS is a huge space, and there's room for anyone that wants to be there. If you're struggling, my best advice is to meet other students. Y'all are a really friendly group. If you need help doing so, feel free to let me know, and I'll do my best to help. If you're struggling, also remember that your professors have all struggled with this content at some time. Your value is not your grade. It says nothing about you. You're all full people! Some of you play tennis, some of you are on the med track and just need this class for credit, some of you make jewelry, and some of you would just rather be reading a book on a Thursday than type at a desk. An A changes who you are just as much as an F (or E here I guess) -- Not One Bit. .  . With that said, best of luck on the midterm, I hope you get the grade you're striving for. If you don't, you're just as much part of this community and you've got the rest of the semester to figure it out and if you don't by then, you've also got future semesters..  . Remember that you're more important than any of your classes. Remember to eat well, and to get good sleep. It'll help with performance, but really, it'll just make you happier..  . Feel free to reach out anytime. I'm on the class discord, and the class website, and the class piazza, and in the front row of class.|804|77|active|||0
leyzj1cnd9n6kz|SP18 3c|Is it possible to pass i, a pointer to Runner, into function Runner_get_id, which takes a const pointer to Runner?|44|0|active|Yes, you can always pass a pointer to a parameter that takes a const pointer of the same type, but you cannot do so the other way around.||0
leyyzwbwc7y731|Spring 2019 4b: Scope resolution operator|Why do we not need the scope resolution operator when calling get_year_made()? . why wouldn't we have to do Toy::get_year_made()? . |51|1|active|I think it's because `get_year_made()` gets inherited by `Robot`, so you can call Robot's version and Toy's implementation will get called.||0
leyyrw00zi26bx|Fall 19 Q2b|I use iteration by pointer instead of index, is it ok?. . . My solution:. . int max = array[0];. int min = array[0];. for (int *ptr = array; ptr < array + length; ++ptr){.  if(*ptr < min){.    min = *ptr;. }.  if (*ptr > max){.    max = *ptr;. }. }. return max - min;. |56|0|active|ptr has to be a const int *ptr. Otherwise, I think it's fine.||0
leyyjjrojnquv|spring 19 1c|. why the parameters of longest_string is argv+3, and argc-3? . I think argv is the array of c-string pointers. does pointer + 3 meaningful?|57|0|active|This is what's called pointer arithmetic. Here by adding 3, you move the pointer 3 places to the back. In this case, argv+3 now points at the array which stores the c-string at position 3 (argv[3]).||1
leyy2lcjf5f6gq|SP18 Q2b|I wonder whether using a pointer to iterate like what I wrote is correct or not.Thanks!|45|0|active|Correct answer seen below by Nidhil!||1
leyxplja3ou44u|Spring 2019 0c Q3|"Consider the following RollerCoaster class:. . . class RollerCoaster {.   private:.     string name;.     int height_to_ride;.     int intensity_level;.   public:.     RollerCoaster(const string &name);.     RollerCoaster(const string &name, int height, int intensity);.     bool can_ride_coaster(int my_height) const;.     int get_intensity_level() const;.     void increase_intensity_level();.     void print() const;. };. . . . . . . . 3. const RollerCoaster r3(""Valravn"");. . r3.print();. . . . Why is the answer for 3 ""No Error""?. Aren't variables height_to_ride and intensity_level in r3 undefined?. How can we print undefined variables?. "|81|0|active|I'd have to see the context for this.. There would definitely not be any compilation errors for printing uninitialized values like that, the question is would the program crash? The answer is yes, but only if you're lucky. When a member is uninitialized, it just has the value of whatever junk used to be there. If that value is invalid, you might get a crash (great). If it's not, then your program might just keep going. The most common value of uninitialized integers is simply 0 (I can explain why if you want). So, if they happen to be 0, then you've got yourself a fun bug to try to find later.||0
leyxi576y7c78i|practice exam B2|My ans for B2 is slightly different from the answers given by the instructor in terms of the way the loop runs. I didn't find any mistake in it but I still want to make sure if it is correct. Can anyone help me to take a look. Thanks:) |57|0|active|Looks good to me :)||0
leywxv2vxqe6j6|Pass by ref|If an argument is pass by reference, does a variable parameter need to be passed into it in order to compile?|80|0|active|"I believe I understand what you mean. If you have a function like. . ```. void foo(string& s). ```. . You could not call it like. . ```. foo(""blah""). ```. . Because `""blah""` is a string literal and cannot be bound to a variable. Instead, you would have to do. . ```. string blah = ""blah"". foo(blah). ```"||1
leywqct6ln036k|Do we need to know how to draw memory diagrams in the exam?||78|1|active|Since it was in the first few lectures, it's fair game for the exam.||0
leywjc9k41y219|Virtual in derived: if we don&#39;t write virtual in derived class, do we must include &#34;override&#34;?|Since it's technically optional to not write the word virtual in the derived class, do we need to write the word override then? Or, is both optional in this case?|57|0|active|"No I don't think so. The ""override"" keyword just tells the compiler to double check for you. It is good practice to include it but you don't absolutely need it."||0
leywbjg8ciz3x7|Q12 Spring 2018 exam|wondering how ne ends up being the result - confused on what adding 1 does and how adding an integer works with it - thanks!. Screen_Shot_2023-03-07_at_6.40.09_PM.png|57|0|active|"argv[1] gives you the c-string ""one"". If you add 1 to it. ```. argv[1] + 1. ```. then argv[1] decays into a pointer pointing at the letter 'o' (by pointer arithmetic). When added with 1, it now points at the letter 'n'. . Because of the special case of printing an array of characters, instead of printing the address of 'n', it now prints the entire array of characters starting from 'n' until '\0'. This results in ""ne"" being printed."||0
leyw5y047zx4a8|Fall 2019 Q1a|Rather than doing it < src + str_len(src), can we write *it instead? (for (const char *it = src + pos; *it; it++)). . |71|1|active|Yes, this should be okay. While the null character itself cannot be de-referenced, a pointer to a null character is no different than a pointer to any other character.. . If you'd like to toy around with a demo, I just made one to double check:. https://onlinegdb.com/zq3iPdmyA||0
leyw2mh7i7g3fj|are we supposed to know the compilation process|are we supposed to know all these commands and how to use them for the midterm?. . The Compilation Process. Consider the compilation command above. The elements of the command are:. . g++ is the C++ compiler we are invoking.. . The --std=c++11 argument tells it to compile according to the C++11 language standard.. . The -pedantic argument tells the compiler to adhere strictly to the C++ standard. Without this flag, compilers often provide extensions or allow behavior that is not permitted by the standard.. . The -g argument tells the compiler to produce an executable that facilitates debugging.. . The -Wall argument asks the compiler to generate warnings about possible programming errors.. . The -Werror argument configures the compiler to treat warnings as errors, so that it does not compile code that has warnings.. . The arguments -o main.exe tell the compiler to produce the output file main.exe.. . The remaining three arguments are the source files for our program – p1_library.cpp, stats.cpp, and main.cpp.. |88|2|active|I'm not speaking as to the contents of this exam.. . However, I will say that at the end of the day, our goal is for you to understand complicated concepts well enough to make projects on your own. . That means knowing what compilation is, how your code turns into something your computer can run, and that the command line is a great tool to do all of these things.. . Memorizing the meaning of the -g flag when running the g++ compiler is not a learning objective of EECS 280. You'd forget it by semester's end and I'd just google it everytime I saw it. That's okay.||0
leyvrh1daad2x8|spring 2019 FRQ 2a: how does this give the LAST occurrence of the item?|How does doing array + i give the pointer to the last occurrence? For example, if it was 4, 2, 3, 4, and we want to find 4, wouldn't it be found at index 0? so array + 0 is still array? But, the last occurrence is actually at the end there.. . . |56|0|active|Oh wait, it is because it doesn't return? It'll keep going, so finally at the end it'll give the last occurence.. . I had a different implementation where I started from the back, so as soon as I saw a matching item, I returned a ptr. This also works right?||0
leyvqgskw2h3t3|Fall 2019 Q4e Reference Parameters|I thought the reason for the compile error was due to a direct value being passed in to the function, when the parameters require a reference (for brand). Is it always possible to pass in direct values into reference type parameters?. . |49|0|active|"Pass by reference is not the same thing as declaring a reference to a variable. Pass by reference means that anything you do to that variable within the function is done directly on that object, rather than a copy of it. In this case, passing in ""Google"" means that the constructor reads directly from the string and does not make a local copy of its value.. . So yes, it is always ok to pass in some variable you defined to a function as a pass-by-reference."||0
leyv9rzkgr34xh|spring 18: FRQ 1a: why does having just chars and str in my while loop make a seg fault?|I was just playing around with my answer, and I realized that it was wrong since I didn't have *chars and *str in the while loop conditions.. . I just want to clarify why it's a seg fault?. . I thought char and str were already pointers, so I wanted to compare to make sure it hasn't reached the null char yet.. . But wait I think I just realized my mistake: is it because the pointer is just getting the address, not seeing the element at what it's pointing to. So it never sees if it equals the null char.. . 1. Also, it's a null char, not a null ptr, which I think also led to my misunderstanding right? (if it was a null ptr we were looking to stop at, then this current implementation is fine right?). 2. I somehow thought the pointer was gonna decay even more, to get the actual value. But this doesn't happen right?. . |83|0|active|1. I believe your understanding is correct. In your code, chars and str are always pointers pointing to some memory (not nullptr). It will try to dereference memory outside your array if you traverse pass the null character. To end a while loop when encountering a null character, just do. ```. while(*chars) {...}. ```. A null character has an ASCII value of 0, which evaluates to false in the while() condition, so you can safely exit a while loop without causing a segfault.. . 2. A pointer never automatically decays to get the value at the address it stores. You need to dereference the pointer (*ptr) to get the actual value.||1
leyuuzr0xl32ax|Spring 2019 FRQ 4d|Why does this compile? Play is only defined in the robot class, and since its virtual, shouldn't the compiler take into account the dynamic type of ptr (fighter bot) and look for Play() in the fighter bot class?. |88|0|active|If the function is not found in the class of the dynamic type, it will try the dynamic type's base class. If it's not there, it will keep working its way up until it gets back to the static type and call the first version it sees.||1
leytm6q2vj02f0|4d|Screen_Shot_2023-03-07_at_5.24.08_PM.png. Is this a compiler error because no parameter is given or because the function is non virtual so the static and dynamic type is a device and that wouldn't work.|80|0|active|The function called is non-virtual.. . It will look in the class of the static type (in this case Device). In device, there is no function defined as makePhoneCall() so you get an error. Note that the compiler never even considers other defined function in Phone.. . But going off your first point, you are right that there is no parameter given. If we had a virtual function in the base class that took one parameter, then the fact that there is no parameter given in the function call would be an issue.. . But again, to clarify, the base class has no function makePhoneCall() which is why this is an issue specifically||1
leyt5mo2lzho7|Can you convert ifstream to istream?|"I know that functions with an istream as a parameter can accept sstreams and fstreams for some unknown reason, and a pointer to an istream can be polymorphic to a fstream or sstream since they are subtypes (I think).. . But can I directly upcast like below, or will I face object slicing?. . ifstream fin(""file1.in"");. istream is; // Or even faster, istream is(fin);. is = fin;. . If there's object slicing, why do functions with istream as a parameter allow this conversion?"|65|1|active|||1
leyrxhxojxk6n0|Fall 2019 P1b|Can anyone check if my solution would be fine? I'm not sure if I could read in the string first and just take that as the parameter instead of take istream type variable as parameter.. . . . |60|0|active|At a glance, it looks good to me. I recommend running your code in your IDE and test to see whether it works, and using the debugger to understand the bugs if any.||1
leyrnvt6ypj2fa|Spring 2019 0c #4 and #6|"Consider the following RollerCoaster class:class RollerCoaster {private:string name;int height_to_ride;int intensity_level;public:RollerCoaster(const string &name);RollerCoaster(const string &name, int height, int intensity);bool can_ride_coaster(int my_height) const;int get_intensity_level() const;void increase_intensity_level();void print() const;};. . RollerCoaster r4(""Rougarou"");while (r4.intensity_level < 100) {r4.increase_intensity_level();. //error. . RollerCoaster r6(""The Outlaw"");RollerCoaster * const r_ptr = &r6;r_ptr->increase_intensity_level();. //not an error. . I don't understand why 4 is an error and 6 is not an error. Can someone explain this in detail?. "|87|0|active|For 4, you are accessing a private member variable directly in the header of the while loop.. . For 6, you have a constant pointer to a roller coaster object. So, it is not an error to modify that object because not that the pointer is constant, so you can't modify it to point to a different object, but you can modify the object it is pointing to.||0
leyqndfdfuk66w|Plain Old Data|Is plain old data for a struct still considered an ADT? If so, then I'm not sure why not all structs are examples of ADTs. In what case can a struct not be an ADT? |67|0|active|EDIT: Plain old data is a special type of ADT that doesn't include functions to operate on the data.. . ADTs should provide an abstraction so an example of a struct that won’t be an ADT is if I just randomly group variables together. . struct Foo {.   int num;.   int *ptr;.   int arr[4];. };. ||1
leyq5air2o249q|Spring 2019 0a #6|Why is 6 true? Doesn't this go directly against @2760?. Screen_Shot_2023-03-07_at_3.47.23_PM.png|87|0|active|It actually matches @2760. The const keyword here prohibits you from modifying the object it points to, rather than prohibiting the pointer itself to change and point to something else. Because you declared ptr2 to be able to edit the int it points to but ptr1 cannot, you can't just copy of ptr1 into ptr2 and edit the object with ptr2 (as you should not if you declared ptr1 a const int *).||1
leypxpd3byl74l|Spring 2019 Q3B|I used pointer in this question, but I noticed that the solution does not. Is my implementation feasible by using a pointer?. . . // REQUIRES: f_ptr points to a valid Festival. // The number of artists is less than the max festival size. // EFFECTS: Returns true if ALL of the artists performing at the festival. // are sold out (this also includes the case where there are no. // artists at the festival). Returns false otherwise.. bool Festival_is_sold_out(const Festival *f_ptr) {. 	if (f_ptr->num_artists == 0){. 		return true;. 	}. 	else if {. 		for (Artist *ptr = artists; ptr < artists + num_artists; ptr++){. 			if (!Artist_is_sold_out(ptr)){. 				return false;. 			}. 		}. 	}. 	else {. 		return true;. 	}. }. |57|0|active|"I think the pointers are fine. However, there is an error with the return statements as the else if does not have a condition to able to go into that loop. You should fix this by changing removing the ""if"" in ""else if"" and removing the current else section in favor of just ""return true;""."||1
leyp878y9dy4r3|2019 fall, 4d(1)|Hello,. . I am a bit confused why the first output is Phone depleted 2%. Both depletePower() functions in device and phone are virtual. Does this mean that dynamic binding still works? Sorry I thought dynamic binding only works when we have virtual and override keywords.|72|0|active|If a function is declared as virtual in a base class, then it is automatically virtual in all its derived versions. Although depletePower() doesn't have the *virtual* or *override* keyword in the Phone class, it is in fact a virtual function. In this case, the dynamic binding works. . . If the function in the Device class is not declared as virtual, there will be static binding and the Device pointer will be binded to calling Device::depletePower() at compiletime.||0
leyp3vjf3y14uf|Spring 2018 1a|This is my approach for the contains all function in Spring 2018 (question 1a), but it is always returning false and I am not sure why.. . . #include <iostream>. using namespace std;. #include <fstream>. #include <string>. . using namespace std;. . bool contains_all(const char *str, const char *chars){. while(*chars != '\0'){. int count = 0;. while(*str != '\0'){. if(*chars == *str){. count = count + 1;. . }. str++;. }. if(count >= 1){. chars++;. continue;. }. else{. return false;. }. . }. return true;. }. . . |5|0|private|Your count resets in every iteration. The first time, you are able to match the first character of chars somewhere in str, so you increment the count by one. Next time you enter the loop, count = 0 and str is already at the end of the c-string (since the last while loop terminated when *str is null terminating char), so it won't enter the for loop. . . I suggest putting this code into your debugger, and add a main function where you call contains_all() with some examples to better understand this issue.||0
leyojtx7gi06rd|Fall 2019 0b Q2|Can someone explain how they arrived at the answer c for Q2?. . |76|1|active|argv[2] refers to file2.txt which is a character array. Index 4 of this character array is 2||0
leyoemzh4bj4eb|Q15 Spring 2018|. . Not sure why and how this is C. |44|0|active|@2755||0
leyny5fyyiu6f1|const keyword in parameter|". Could someone explain what the compiler error is? I am trying to do a traversal by pointer, but it does not let me initalize int *ptr to the address of the first element in ""begin"" array. I understand that there is a const keyword in the parameter, but I'm not modifying the value of begin in this situation."|67|0|active|I think it's because you have to make it a const int *ptr||1
leyn76g7u544yv|Lectures to review for Exam|I’ve been reviewing and to finish things off I was going to re watch the lecture recordings, it was mentioned that the exam will cover topics up to polymorphism, does that mean all the material on the exam is covered within lecture 1 through lecture 10. Nothing after that?|87|0|active|Correct||0
leyn4m2i6zv1ng|Review Worksheet B.2|For this question the key stated that we could not create a temporary array since the size would not be known at runtime. I am confused on this though, since the function is passed a size parameter that gives the number of elements in the original array. Why could we not declare a temporary array such as tempArray[size] to use if we wanted to copy the original array into it?|59|1|active|The key is that `size` is a non-const variable whose value could change from run to run. We can only declare an array with a certain size if that size remains constant between runs, i.e. if it's hardcoded as a number or if it's a `const int`.||1
leymvgiqfie49x|Spring 2016 2b|. why is D none and not 3? argv[3] is 2 and 2 + 1 is 3?|73|0|active|argv[3] is a pointer to a cstring, so if you just printed argv[3], it would output 2. When you add 1, you are adding 1 to the pointer, you are moving the pointer forward, which will make it point to the null character.. . For example, if you printed argv[0]+1, it would print /program.exe instead of ./program.exe, because it skips the ..||3
leylas4jxd3sg|Fa 2019 Midterm Question 1b|Can somebody walk me through this solution? I really have no idea what's happening. |58|0|active|"Sure, so in this method specifically, we want to output every Nth word from is. Let's look at the example provided, where the input is ""She went to the store"". . So first we make the variable str which will temporarily store words read. We want to loop while there are still words left, which is why we do while(is >> str) {...}. After this line (line 3) is run, str = ""She"".. . We always want to read the first word, so we start by outputting str, so ""She"" is outputted, and afterwards "","" is outputted. Then, we want to skip the next N-1 words, so we loop N-1 times (since the loops runs from 1 to N-1), and each time the next word is read. In this case N is 2, so we loop 1 times and just went is read, and nothing is done with it.. . Continuing, we read the next word to, and output it followed by a comma, then read the and do nothing with it.. . Again, we read the next word store and output it followed by a comma, and then read the next word, which fails but that doesn't matter since we do nothing with it.. . And that's it for that example. If N was 3, for example, we would read 1 word and skip the next 2, then again read 1 word and skip the next 2, etc.. . Hope that helps!"||0
leykczcb4re619|Polymorphism and inheritance|. This was an example in the Polymorphism notes, for the error to go away would class B be written like this:. . class B{. public: . B(){. A{}. }. };. . -------. error example:. class A {. };. . class B : A {     // default is private when using the class keyword. };. . int main() {.   B b;.   A *a_ptr = &b;  // ERROR: inheritance relationship is private. }|67|0|active|You could just rewrite class B to have a public inheritance from class A:class A {. };. . class B : public A {    . };. . int main() {.   B b;.   A *a_ptr = &b;  // No error! Dynamic type is B and static type is A, and since A is the base class, that is fine! Compiler is happy :). }||0
leyjzbnj1px123|Review Session B.3|This is my solution for B.3, I did it with a for loop and didn't use temp, is it ok?. |65|0|active|Since you didn't use temp, you have overwritten the first half of the string by the time you reach the midpoint, so the second half of the string won't actually be changed as you expected. To preserve the original information during a swap, you always need a temp of some sort to hold the information.||0
leyjoo331fa3rs|Cheat Sheet for Exam|Can we use resources from online to make out cheat sheet with screen shots? I wanted to confirm that it wouldn't be an honor code violation. |167|0|active|yes, you can put whatever you want on the cheat sheet.||0
leyjof3fpu690|Where can we find the gradescope practice exam?|I saw on the eecs280 website that there is a practice exam on gradescope, however, I am not able to find it. Has it been posted?|128|4|active|. I saw on the eecs280 website that there is a practice exam on gradescope. . I don't see this can you point to whee you saw it?. . We are not offering a practice exam on gradescope.||1
leyj521bb6m204|string to C-string|Is the const qualifier a must here?|53|1|active|yes, c_str() returns a const char*, so you cannot convert it to a non-const. If you do not include the const, you will get the following error: invalid conversion from ‘const char*’ to ‘char*’||0
leyihimm33j2y8|c-string library|Do c-strings require a library? I remember they don't need a library but this picture says they need <cstring> so I'm confused.. |49|0|active|C-Strings are simply arrays of type ‘char’. Because arrays are a built-in, standard item of C++, you do not need the library ‘cstring’ in order to create C-Style strings.||1
leyid9tp4oc6jy|Spring 19 Q0c #5|Why does this line of code cause an error? Is it because the RollerCoasters in coasters are uninitialized?. . . |57|0|active|I believe it is because there is no default constructor, so the first line will throw an error||1
leyi7jktuup5nw|address of c-string|"We declare char str1[6]=""hello"";. Is &str1 of type char * or char **"|35|1|active|Good question! Let’s think this through:What is ‘str1’, exactly? Remember that referencing an array by its name gives us the memory address to the first element. It is equivalent to doing &(str1[0]).With this in mind, what happens if we did &&(str1[0])? We get &(memory of char). Simplifying this more, we can see that it is the memory address pointing to a pointer which points to a char (try saying that ten times fast). As such, &str1 would be of type char **.||0
leyi35rsj0c3ng|When to use virtual|I saw virtual is used in class B and class C in the review session sheet, but they are the derived class. Do we need to put virtual in both bass and derived class?|72|0|active|"When you declare a function virtual in the base class, all its derived functions are automatically virtual. You need the virtual keyword in the base class, but you can choose to put it in or not for the derived classes. Writing the ""virtual override"" keywords in the derived class can tell the compiler to help you check whether you mistyped anything and whether you are actually overriding the base virtual function."||0
leyhh4xkio62jb|Spring 2019 P1a|The solution I wrote for split_string uses pointer arithmetic, compiles, and outputs the correct output in lobster. However, my implementation looks quite different to the solution posted in the google drive. Would I get full credit for getting my implementation to work correctly or does it have to resemble the solution posted? In other words, how are the frq's graded?|66|0|active|We grade based on correctness. if it works correctly then you have nothing to worry about. Partial credit will be given as well if correctness is off even if it doesn't follow our private solutions.||0
leyh7lokvwrwu|Why do we hide public functions but not constructor?|For public functions, if we find virtual functions of derived class we stop, but we always call the constructor of base class, why don't we just stop when we find the constructor of derived class? (For A.2 in review session)|43|0|active|||1
leygghrg5o3cb|Spring 2018 Q7: why do the type parameters need to be different?|I was thinking, what about the delegating constructors? For example, in lecture, we saw the Triangle constructors. (see below). . . . . . They both take in the same parameter I guess? Or, is it actually not, since the parameter refer to the same whole thing within parenthesees, not just the return type (so, the number and return type)?. . |94|0|active|In this specific case of Triangle and its delegated constructors, one constructor takes in three doubles `(side_in, side_in2, side_in3)` and the other constructor takes in one double `(side_in)` and calls the aforementioned 3 side constructor. This is an example of how there can be multiple constructors that take in different parameters (one has 3 parameters and the other has 1 parameter).||1
leyfxerhmw51ed|string literal|"I saw this expression on the slide, but should we put the const qualifier before str2[6]?(i.e. const char str2[6]=""hello"";). Also, I'm wondering what if we declare ""char str[3] = {'l', '\0'}; would it cause a compiler error"|50|0|active|"Yes, you would put the const qualifier before `char` like `const char str2[6]=""hello"";`. Further, declaring `char str[3] = {'l', '\\0'}` would be ok, but the third char would be another null character."||1
leyeq70mj3c6bt|spring 2018 Q3b|"If ""race->runners... "" is not preceded by ""&"", is it still correct?. "|81|0|active|No because the parameter to the `Runner_init` function requires a pointer to a runner. Without the `&`, you are passing in a Runner object which makes it an invalid call to the function.||0
ley626uh7o46xe|practice exam|can you help me find the practice exam? I only see the spring 18, 19, and fall 19 exams in google drive but not the practice exam. |119|2|active|That is the practice||0
lexygrn0lt1tf|Local variables in functions (Midterm Review A.3)|Rather than creating a new counter variable, I did k--. Since k is local and not being returned, is it alright to edit local variables directly or should we create new variables?. |92|0|active|For this case, it should be ok to edit k - the local variable - directly. As long as your solution would work, you will receive full credit.||0
lexycj85xtk3z7|Midterm Review A.2 virtual ~A() functions|Do we need to know about the virtual ~A() type of functions? And why does calling virtual foo using the pointer result in B, A, and C dtor being printed?. |136|2|active|"The virtual `~A()` works just the same as any virtual function to be overridden. Calling `foo()` doesn't print the dtors. It just results in the print statement ""B's foo"". The dtors are printed as a result of objects `b` and `c` being destructed. Note how when `ptr` is destructed, there is nothing printed because pointers don't have an explicit destructor in this program."||1
lexxhjsinbo3wh|traversal by pointer vs value|When is the best time to use traversal by pointer vs traversal by value?|66|0|active|From the notes:. . Traversal by index is the more common pattern when working with general arrays. However traversal by pointer is applicable to two important cases:. . It is the dominant pattern when working with C-style strings, which we will see next time.. . It is the basis for the more general traversal by iterator, which we will see later in the course.. ||0
lexwhwsqph42w2|spring 2018 multiple choice #21|Can someone explain why the correct answer is C and not D?. . . |68|1|active|. This method is not the same one that is in the class. It is not part of the class and therefore cannot access private variables (and name is a private variable), so it cannot access flower.name.||0
lexuy6gr15j4ip|Fall 2019 4d|Why would this be a compile error? Is it because it is considered downcasting?. |73|0|active|Pretty much - you cant do this bc a derived class pointer can be assigned to a base class pointer but not the other way around. Think of it like all phones are devices, but not all devices are phones.||0
lexulvjw8ryv8|Fall 2019 Q3b (Free Response)|. . Why is the first parameter for runner_init &race-> runners[race->num_runners++]. I'm not sure what this chunk of code is even doing. I know that we have to initialize a runner using runner_init, but not sure why or what &race -> runners[race->num_runners++] is doing.|47|0|active|It is passing in the address of runners[num_runners], and then incrementing num_runners by 1 after the runner is initialized. Because runners[] is an array of valid Runner objects, you can pass the address of the array location directly into Runner_init.||0
lexuekc8io82an|Difference between argv[ ] &#43; 3, vs argv &#43; 3?|I understand that argv[ ] + 3 and argv + 3 give different results. I'm just confused on the difference between argv[ ] and argv? . . What happens if I said argv[ ] instead?. . . |55|0|active|"const char *argv[] is a pointer to cstrings, effectively a double pointer (and equivalent to using const char **argv). Thus, when you use ""argv[0] + 3"", you are dereferencing argv at index 0, which is now pointing to the first character of the first character in the first cstring, and then moving that character pointer by 3 spaces. With ""argv + 3"", you take the cstring pointer from the first cstring and move it 3 whole strings, as opposed to moving it 3 characters. "||0
lextzejc3iv2t|Spring 2019 FRQ 4b|. Why is it sound_effect(), and not Robot::sound_effect()? |53|0|active|Both work ||1
lextz7ri3wo6se|Spring 2019 FRQ 4b|. Why is it sound_effect(), and not Robot::sound_effect()? |46|0|active|@2726||0
lextur0ujq33k1|Spring 2019 FRQ 3a|". . Why is the answer key not using the struct functions to access the member variable venue, name, and sold out? As shown above, I thought directly accessing them is ""not respecting the interface"". I understand that the answer key is technically possible, given that structs are public by default."|53|0|active|@2660||0
lext7twe4z17iw|I don&#39;t know why this is also the proper subtype.|"I am confused here. For the DerivedUnicorn class, we could return the power of the laser which is over 9000kw. However, for the base Unicorn class,  we return the power of the laser beam,  which is at least 100kw. According to the Liskov Substitution Principle : ""in any code that depends on T's interface, an object of type S can be substituted without any undesirable effects"", but here if we have the number of 150kw, the derived class could not return which violate the principle. Why it is still proper subtype?. "|56|0|active|I think it is pretty subtle. You are correct that the derived class function could not return 150 kw. However, we are not saying that the derived class function can return the same values as the base class version. Instead, we are saying that whatever the derived class version returns will NOT break the interface of the base class version. As a result, since the derived class version returns values over 9000, these values are still over 100, which means that it does not break the interface of the base class version. In a simpler example, let's say we had a function that only returns positive numbers and then a derived class function that overrides this function that only returns numbers greater than 10. We are not saying that the derived class function will return all positive numbers(including 1, 2, 3, 4 up to 10), we are only saying that all the numbers that the derived class function returns are positive(which means that it doesn't break the interface for the base class version).||0
lexsb9cx24vf|Spring 2018 FRQ 3c|Hi! I am wondering why you use &race to access the runner array but you don't use &race when you are accessing the num_runners variable? - 3b. I want to know why you use &race in general actually, like in 3c, where you call the array again using the &race. is it because it is an array?. . . . |60|0|active|&race->runners[i] gives the address to one of the runners, and is the same as &(race->runners[i]), as opposed to (&race)->runners[i] which would give a syntax error. The reason we need the & is that we want to get the address, as it is then used in a pointer variable (Runner* runner).. . On the other hand, race->num_runners is not being stored in a pointer, and we just need the value, so we do not get the address to it.||0
lexs9kis9my5zn|How is this a type mismatch?|See the bottom line. I thought they were both pointers, so both are containing addresses?. |60|0|active|Oh wait is it because the address of first element of s1 vs s3 are different? But even then I don't get why S1 doesn't just now point to s3 basically?||2
lexs26w0yqj4zm|Fall 2019 2a|I'm sort of confused on why this would be a compile error. Also, what exactly does the double ** signify in the first line? I'd really appreciate a simple breakdown of the problem if possible. Thank you!. |116|0|active|The compiler error comes from the second line where we have int *y = 3;. This line produces a compile error because we are initializing a pointer variable to an integer, which does not make any sense because pointers should store addresses. The ** in the first line signifies a pointer to a pointer(in this case, a pointer to a pointer to an int), so when we dereference x, we should get a pointer to an int.||1
lexs1v1cklw41e|Conflict answers? Defining virtual function outside of class, and usage of &#34;virtual&#34;|"I was in the midterm review today and our IA Alec answered this question, but I'm not sure if this is conflicting information?. . The notes here seem to say that if we define a function outside the class, then we just use the scope resolution operator, and no sign of the word ""virtual"" in front. . . . . . But, Alec said The key difference is just having [class name]:: before the function name, and you'd keep all other keywords (so including virtual?)He gave an example of virtual Card SimplePlayer::play_card(.... . So are these two things conflicting? I'm just confused now. Thanks!. . "|70|3|active|Thanks for pointing this out, my example was indeed wrong. The `virtual` keyword can only be used within the class, not outside.. . You still need the class name and the scope resolution operator before the function name for it to be implemented outside the class, so the example would instead look like. . ```. Card SimplePlayer::play_card(.... ```||0
lexriyy9xvn4k7|cout character arrays|char str[] = { 'H', 'e', 'l', 'l', 'o' };. cout << str;. would this be undefined behavior or will the compiler automatically add a sentinel after?|52|0|active|you need to include the null terminating character. If it is not included in a literal character array, for an operation such as count<<, it will go pass the end which results in undefined behavior.||1
lexrh7rdkz86g1|fall 2019 3b|Since song is a struct, would it be possible to use the dot operator (p_in->songs[i].title) to get title or is it required to use Song_title?|66|0|active|No you have to respect the Song ADT which means you cannot directly access its member variables and should use its public member functions to access its data.||0
lexrc1k7m0j418|Spring 18 FRQ 1a|Could someone explain the syntax used in these for loops?. . |92|0|active|"The first for loop, does not have an initial clause, So no variable is initialized for the loop (think about how you write int i = 0; to initialize i for travesring). The terminating clause for it is *chars which means traverse till you hit the null terminating character. . . The second for loop, does not have an initial clause as well. For the terminating clause, it has two conditions. Note that ""and"" is not C++ syntax, and you should write &&. The condition is that traverse till tmp is null terminating character and *tmp is not equal *chars (tmp and chars don't point to the same character)."||0
lexq4lodueu7fn|Spring 2019 0c|Why doesn't this question part 2 compiles?. |169|0|active|Since r_ptr points to a const object, it cannot change it.||0
lexpfudik2s26g|Question about syntax|Why we can omit the const int *ptr = begin as ;? . |46|0|active|@2695||0
lexp75x2f203vq|Member initializer list.|In the lecture slide, I see that the order is ignored for the member initializer list. However, when I write the code in euchre.cpp, why the compiler tells me the order matters here? If I disregard the order, it would not compile for my program. I am confused here. |110|0|active|resolved||1
lexoffkaejm66x|Midterm review wksht: why doesn&#39;t char* start refer to the whole string, but just the first char?|"In the solution, we say that. char * start = str;. . But why doesn't this actually refer to the whole string? (or does it?). . For example, I put this into a debugger (I did the solution I bit differently), and it says that front is holding ""hello"", not just ""h"".. . "|71|0|active|Since it's a pointer to a character, so it points to a character which happens to be the first character in this c-string.||1
lexntvkmul245c|Spring 2018: Q2,3|Can any instructor grade these 2 problems for me since my methods are different from the ones given in the answer? I really appreciate :). . For this question, my loop starts from the last element of the array:. . . For Q3b, is my way of adding a runner to the array correct?. For Q3c, it is alright to use i->id instead of calling the Runner_get_id() function ?. . . And lastly, I'd like to make sure that: If I write part of the answer outside the answer box like how I did above (in Q3c), is it acceptable in the exam?|8|0|private|||0
lexned77j4r1kk|c-string and string|"Given that c-string can be converted to string from time to time (e.g. string file_name = argv[1]), but c-string doesn't have properties that string has (e.g. c-string can't use ""<"" to compare directly), I'm wondering how to tell if we can treat a c-string as a string."|44|0|active|I believe you just have to treat those separately. As in, if you're working with C-strings (array of chars), then use the C-string rules. If you convert it to a C++ string (which is what you did with string filename =..) or you declare string x = ... then use the C++ string rules you're familiar with. ||1
lexn8ssmppc48u|Spring 2018 Written 1a|Here's the problem. I have some questions on this problem:. . . Question 1:. The question requires that wen can't use strlen() directly. However, can I implement a strlen function and call it in the traversal by index?. . Question 2:. In the answer given by the instructor, I can't understand why *tmp is written here. Could you explain further what this is?. . . Thanks!. |4|0|private|. In the answer given by the instructor, I can't understand why *tmp is written here. Could you explain further what this is?. . That is the terminating condition for the loop. It terminates when *tmp is the null terminating character.. . . The question requires that wen can't use strlen() directly. However, can I implement a strlen function and call it in the traversal by index?. . For this question, it doesn't seem to be required. I am not sure how it can be helpful.||0
lexn2acvhuo2tg|istream/ifstream/istringstream|What's the hierarchy here? if the type is istream, can it take all 3 types?|76|0|active|istream is like the most general version. ifstream and istringstream are both more specific istreams. And yes, I believe istream can take all 3. Here's a picture from the 280 notes.. ||1
lexmshdna0t1u4|Member name lookup clarification: different base classes|For member name lookup, we start in the first class scope. If not found, we go to the base class scope. What if we have something like 3 classes: . class Aclass B : public Aclass C : public B. If we're trying to look for a function starting in C, but it's not found... do we look into both class B, then if not, also class A? Or, do we only look at class B?. . I'm curious because the base class of C—class B—also has a base class. But I'm not sure if that's important in the context of class C, since technically its base class is just B.. . Thanks!|33|1|active|. do we look into both class B, then if not, also class A?. . yes.. . You would go up the inheritance hierarchal order till you can find the function.||1
lexmrbd4if06cx|Difference btw function overloading, vs member name lookup?|I'm confused on how these processes relate to each other.. 1. For example, is function overloading only occurring in for functions that have the same name, in the same scope?. . 2. Whereas for member name lookup, it seems like we start by looking in the class we're talking about, and if not, we only go up to base class?. |38|0|active|. 1. For example, is function overloading only occurring in for functions that have the same name, in the same scope?. . Yes, they have the same name but different parameters and return types. I am not sure what you mean by the same scope.. . . 2. Whereas for member name lookup, it seems like we start by looking in the class we're talking about, and if not, we only go up to base class?. . Yes, that is correct.||1
lexlj24b7si1f0|array|"Is ""std::array<Card, PACK_SIZE> cards"" the same as ""Card std::array [PACK_SIZE] cards""? (I saw the former in Pack.h) "|51|0|active|No it is not. When we use <>, we use to denote the type of the objects in the container. It is based on templated types. std::array has a templated type for its elements so when you want to create an instance, you have to specify what is the type of the elements it holds.. . std::array is different than writing something such as. . Card cards[PACK_SIZE]. it provides some extra functionalities on top of a normal array. In other words, it's an ADT whereas the normal array is not.||0
lexkxgdgrcr4hb|destructor?|I saw destructor in notes but it was not covered in lecture. Would it be covered in midterm?|60|3|active|||0
lexklq2gife3m2|Exam 2018 Problem 1|For problem 1, I used a while loop to traverse, could someone please check for me if it's okay? Thanks. . |135|0|active|At a first glance, your code looks correct to me. However, I suggest running your code in lobster or in your IDE to check if it is correct. You need to call this function inside of main() with the different cases you want to test.||0
lexiuzn7p646n7|Review Session Packet Problem A.3|Hello! I approached this problem differently than what was reviewed in the function and I was curious if the way I approached it was potentially correct. Int dist = 0;. bool possible = false;. . for(int i = k; i < search.length(); ++i){. .   if(search[i] == elt}{.    dist = i - k;.    possible == true;.   }.  . }. .   if(possible){return dist;}.   return -1;|52|0|active|||1
lexitfi78q14ex|basic question|to be honest I've been confused on some topics for the longest so here is a list and if anyone knows the answer I appreciate it :). . -when in specific do I use a dot operator . . -how does the swap function work. . -when should I know to use [] or () ex. hand() hand[]. . if I have more ill post later thank you :D|74|0|active|use dot operators when you are not using a pointer and referring to a class variable or function . it just swaps 2 numbers I don't think you need to know exactly how it works but if I had to guess it makes a temp variable to store the first number then num1 = num2 and num2 = temp. arrays and vectors use []. With functions use () like foo() {}||0
lexio1l0kh861q|const and passing by reference|Can someone explain to me why const would be necessary when passing by reference? For example, this code:. . . . I am asking for other and more general situations as well.|55|0|active|const is not necessary. If the function wants to give a guarantee that the parameter passed by reference won't be changed, then you will add the const keyword.||0
lexiez5krsj4f5|Spring 2018 FRQ #2b|I wonder if the condition of the first parameter of the for loop need to be filled in. Thanks.. |84|0|active|I don't think it is since there isn't anything you need to initialize. Each part between the ';' of the for statement has its own use. Here's something you can read to help you understand it better. https://www.w3schools.com/cpp/cpp_for_loop.asp||0
lexi9wsrpzy26f|Why does incrementing a char ptr (that declared char ptr[ ]) cause a compile error?|"what's the difference between:. char p1[3] = {'h', 'i'};. char *p2 = ""hi"";. "|36|1|active|I believe the difference is that in the p1 example, the array is still an array. You cannot increment the value of the array variable itself (arrays are not lvalues) as the array has not decayed to a pointer in that case (pointers can be lvalues). After the array decays to a pointer you are able to do increment it all you want. That is why p2 works and p1 does not.||1
lexhpymjpqbed|Traversing Through C String By Pointer|Hi, can someone please inform me if there is something wrong with my str_len function? If not, is there a reason why both str and str2 have different string lengths? Thanks. |50|0|active|I think you strlen looks fine. There's undefined behavior with the way x is declared. There's no null char, and hence your strlen for loop will keep going until it hits a null, which I guess is what is happening. ||0
lexha0bqs2f2t4|spring 2018 Q11|Could someone explain why this is false? Thanks.. |85|1|active|Read from right to left: ptr is a constant(const) pointer(*) to an integer(int). Since it is a constant pointer, it cannot point to any other objects, so its value (address of an integer object) cannot be changed.||0
lexgmrgep8u2f3|Spring 2019 FRQ #1c|Since we wrote const char *inputfile, I wonder why we don't need to dereference inputfile when doing the next line ifstream fin(inputfile); Thanks.. . |75|0|active|Dereferencing inputfile will return the first character of the input file name since it's a pointer to a character. If you pass the c-string to the constructor of ifstream, it can properly read in the name and open the file. ||1
lexgg6lptht3ef|Spring 2019 FRQ #4d|I am confused why does ptr -> sound_effect() calls the member function in fighterBot class, but the ptr ->introduce() calls the member function in the robot class. I though the ptr is a robot variable, but points to a fighterbot variable.. |100|1|active|That's because `introduce()` isn't a virtual function while `sound_effect()` is a virtual function. It is this sole difference that causes a behavior change for a derived pointer object. A ptr object will always try to call the overridden function (in this case `fighterBot::play_sound()`) but if a function isn't virtual, it will call the base function (in this case `robot::introduce()`).||0
lexfzte1hov2my|Difference between Implementation Inheritance and Interface Inheritance?|Hi, so I was going through lecture 9.06 and 9.07, but still can't tell the difference between the two concepts noted in the title. Could someone care to explain through a specific example? thanks|37|0|active|||0
lexfb9bjq4c78e|Problem 0b, Spring 2019 #1|. Why is the answer 2,3 and not undefined? The apple function adds one to pointer b.|154|0|active|You are making a pointer int *b which is then modified. b points to y then is incremented, meaning it points to an undefined address. This does not modify y however, meaning y and the entire cout statement would have defined behavior. ||0
lexesffmjm7mb|Problem 0a, spring 2019 #10: Why is it True?|. Why is this true? Wouldn't the dynamic type be a chicken?|152|1|active|(whoops see my question below)||2
lexe6gfs7x82pn|Problem 0a, spring 2019 #2: Why is it True?|. Why is this true?|142|0|active|Because when the function is finished executing, it’s stack frame/activation record (including all its local variables) is deallocated from the program so you shouldn’t access something that’s not apart of the program. Sometimes it’ll work, sometimes it won’t: undefined error. ||0
lexd1bum1mk2dd|spring2019 0b) Q1|. . why would this print out 2 3? wouldn't the address of y be incremented by 1 so that it is now a junk address?|131|0|active|The value of `x` doesn't changed after calling `apple` since the parameter `a` is a passed by value.. . The `b` parameter, on the other hand, is passed by reference (using a pointer). This means that the pointer `b` inside the function points to the same memory location as `y` outside the function. When the `b` pointer is incremented inside the function, it moves to point to the next integer location in memory after the original value of `y`. However, since the value of `y` itself is not modified, when `x` and  `y` are printed outside the function, they still have their original values of `2` and `3`, respectively.||1
lexcddro6eq1m9|different ways to initialize a class|can we initialize a class with:. Triangle t(1,2,3);. Triangle t = Triangle(1,2,3);. Triangle t{1,2,3};. Triangle t = {1,2,3}|32|0|active|Yes, all are valid ways to call a constructor.||0
lexcadkiikh6lk|Spring 2018 Writing Portion 3b|. For the part of initializing the pointer, could I write:. Runner * runner;. Runner_init(run, name, gender, id);. runners[num_runners] = *run;. num_runners++;. |78|0|active|Looks good to me ||1
lexc8e20hc3at|Spring 2018 practice|how to understand this? Does testing the behavior of the abstraction includes testing the implementation?. . . thanks!|61|0|active|When writing test cases, you should be calling the interface functions and confirm that they work as intended. You are not supposed to directly access elements within an ADT, only use the interface functions provided for you (this is called respecting the interface).||0
lexbnbpb77w4an|fall 2019 2a|why is the output 42 not 43?. |116|0|active|This was also answered in another post, I believe. Please see note @2186 before posting so we don't have duplicate questions.||0
lexbkpr1kd44z4|fall 2019 2a|why does this cause undefined behavior? . Is this because it tried to change the address?. |109|1|active|If you do the pointer arithmetic, you would see that ptr points arr - 1. This is outside the bounds of the array you created, so printing the value would be undefined behavior.||1
lexau2yybo01rj|Spring 2018 Written Portion Q2a|. Hello, I wonder if the answer is false for this question, since it wants the pointer to the last element in the array that is equal to item. And I think this will give the first one. Moreover, instead of building a nullptr, can I just return null? Moreover, what is the correct way to build a null pointer? Is it const int * ptr = null?|85|0|active|Moreover, what is the correct way to build a null pointer? Is it const int * ptr = null?||1
lexasuj3iwv3ey|Why/how is char* a pointer to a string? (spring 2019 1a)|I thought (c-style) strings were arrays of chars. So, since this is a char*, which is a pointer to a char, how is this actually pointing to a string (an array of chars)? Is it not just pointing to one char?. . |63|0|active|Remember that arrays decay to pointers, so having a variable referencing an array and having a pointer referencing the first element of an array are practically the same thing.||0
lexamblv5hq6b7|Pointer Placement|Can someone explain the difference between *int const ptr and int *const ptr.. How does the placement of the pointer affect the meaning?|47|1|active|First of all, *int const ptr is invalid. If you want to use an int pointer, then it has to be of the format int * ptr, and then we can worry about what the const part does.. . When determining what the const keyword, you look to the left, and if there's nothing on the left, then it refers to whatever's on the right.. . . int x = 4;. int y = 5;. int * ptr_1 = &x; // Modifiable pointer to modifiable int. const int * ptr_2 = &x; // Modifiable pointer to non-modifiable int. int const * ptr_3 = &x; // Same as ptr_2. int * const ptr_4 = &x; // Non-modifiable pointer to modifiable int. const int * const ptr_5 = &x; // Non-modifiable pointer to non-modifiable int. . *ptr_1 = 10; // valid. *ptr_2 = 10; // invalid, compiler error. *ptr_3 = 10; // invalid, compiler error. *ptr_4 = 10; // valid. *ptr_5 = 10; // invalid, compiler error. . ptr_1 = &y; // valid. ptr_2 = &y; // valid. ptr_3 = &y; // valid. ptr_4 = &y; // invalid, compiler error. ptr_5 = &y; // invalid, compiler error. . ||0
lexal2y8nrf3f7|Fall 2019 Question 7|I'm confused about this one. Aren't all structs examples of ADTs because the purpose of a struct is to create an abstract data type? Why is the answer false?|59|0|active|ADTs encapsulate BOTH data members and functionality. So if I had a plain old data struct that only has data members but no functionality that works with those members that would be a compound object, but not an ADT||2
lexakwvkkip6e6|Spring 2019 0b #5|"can someone explain why it is ""equal 4 5""?. . . int * apple(int a, int *b) {a += 1;b += 1;return &a;}int * banana(int &c, int *d) {c += 1;*d += 1;return &c;}. . int arr[2] = {2, 3};if ( arr == banana(*arr, arr) ) { cout << ""equal ""; }cout << arr[0] << "" "" << arr[1] << endl;"|168|2|active|I think you meant to say “equal 4 3” not “equal 4 5”banana increments c (arr[0]) making it 3 then d which also points to arr[0] is dereferenced and incremented as well making arr[0] equal to 4. Nothing is done to arr[1]. And the address returned is still equal to arr (aka &arr[0] so that’s why “equal” is printed. Hope that helps. ||0
lexa3tp19xr3on|Spring 2018 1a|Is this implementation correct?|62|0|active|||0
lex9vp6ziod1ax|Spring 19 0a #7: Clarifying &#34;without calling an ADT function&#34;?|What does it mean exactly when saying calling a function? . . Is there an example that anyone could give for this? I'm confused on what it it's referring to when saying calling. (like ___ -> something?). . |154|0|active|"ADT functions are what lets you get/set/modify the data in the class/struct. So it is referring to whether you can use ""getters"" or not."||1
lex9buzko2e2ia|Problem 0a, spring 2019 #5: Why is it false?|I thought the end of the string means that the end is a null ptr? Or am I missing the context of what's going on in the problem?. . |170|0|active|I messed this one up too!  (I didn't write that exam).. . The reason this is false is because the `str` does not *become* a null pointer, it *points to* a null terminating character.. . Now, a bit more depth.  Both `nullptr` and `'\0'` have the value `0` in memory.  Both would be false if used in an if statement.. . If I was going to reword this question, here's how I would do it.  The answer would be the same (false).. . > If `char *str` is used to traverse a C-string, the end of the string is reached when the value of the `str` is `\0`.. . EDIT: It's false because the value of `str` is not a null terminating character.   Rather, `str` *points to* a null terminating character.||1
lex99l1xbtx67z|FRQ 3a, Spring 2019: Breaking Interface, and Could I have used the actual functions, instead of -&gt;?|Rather than doing what they did with a_ptr->name, would it also work to say Artist_name(a_ptr)?. . Also, I still want to clarify why this isn't consider breaking the interface? . Is this the reasoning why:. So for Artist_print for example: we are allowed to access members of the Artist struct here, since it’s kinda basically part of/directly related to the struct (since these functions are technically outside the struct, bc of c-style).But, we just shouldn’t access members outside of functions like these, that directly relate to the struct right? (like, in a Festival struct's function or something, since its function wouldn't relate to Artist, so we shouldn't do -> or something?). . |77|0|active|See @2659. . . Also, I still want to clarify why this isn't consider breaking the interface? . . Because these two functions are on the same interface level. Both access artist struct and do something with the data.. . Yes, to both of your questions.||1
lex8s9ngd6f6ha|Spring 19 Q3a|When implementing the print function, why do we have to use the ->  operator instead of calling the other Artist functions (Artist_name, Artist_venue, Artist_is_sold_out, etc)?. . . |70|0|active|Both are valid solutions!||0
lex7uufg6ci7ow|two star pointers|I am a little confused about how 2 star pointers are initialized. . Would this be the correct way to initialize a two-star pointer ptrr that points to ptr.. . int x = 3;. int * ptr = &x;. int ** ptrr = *ptr;. . or is it . int ** ptrr = ptr;|43|0|active|Similar to what a one star pointer does, which gets the address of what it points to (the pointee), you want to get the address of the pointee for two star pointers. Then, it will be. . int x = 3;. int* ptr = &x;. int** ptrr = &ptr; // get the address of one star pointer, which is what the pointee is||0
lex61pd6o9m1nz|Do we need to know const-cast|Title. Also, can we use it on midterm to justify possibilities?|59|0|active|Since it's a topic not covered, it won't be asked. Using it in your solution would be incorrect because, based on our rubric, we are looking for an understanding of the material taught in the class.||0
lex5b8qh3ll452|If my uniquename is starts with CHE, should I go to CHRYS200?|Just for confirmation of the location to take the exam, is this the CHRYSLER CENTER on the north campus? Thanks in advance!|66|0|active|Yes.||0
lex3rqeeixjcf|Free Response Grading|How will credit be given out in terms of style for our free response code on the midterm (will there be grading on style)? Also will there be partial credit for the writing portions?|98|2|active|No particular grading on style. You will receive partial grading as appropriate.||0
lex1v4jd6z63ig|Fall 2019 0b 8|why does cout << y  cause undefined behavior?. Shouldn't it print out the address of the first character?. . |155|0|active|The question's declaration of variable y is:. . char y[] = {'h','e','l','l','o'};. . As pointed out by the student answer above, notice how this declaration does not contain a null character '/0' and thus when outputting the string, the compiler is outputting every character until it reaches the null character. Since this character is never encountered, there is undefined behavior.||1
lewiolyxfd6676|Spring 2018 Q3c|The solution used Runner * as a parameter for Runner_get_id when the function's parameter requires a const Runner * type. Is it always possible to use non-const types in place of const in function parameters?. . |75|0|active|"You can pass a non-const variable to a function if the function takes a const parameter. The const keyword in the function definition basically tells the compiler that the function SHOULD NOT modify this variable. This doesn't mean you can't modify this variable you passed in elsewhere in your code, just not in this particular function.. . Following this logic, if you pass in a const variable as a function parameter that is not declared const, the compiler will complain, because you are not guaranteeing the ""constness"" of that const variable in your function."||0
lewcz0vajlm7kn|Sp18 Q10|"""When the value of an array is obtained, the resulting pointer doesn't provide info about the length of the array"". . What does ""resulting pointer"" mean here?"|54|0|active|I believe it refers to the pointer the array decays into when passed into a function.||0
lewcvsmn66wiz|Destructors|Do we need to know about destructors (I understand what they do but did not realize that they are called backwards for the order that the objects were initialized as I believe we did not cover this in lecture)|6|0|private|Yes, you should know what destructors are and how to implement one.||0
lewcj3rb6wxnu|Spring 2018 Written Portion Q4c|". . could I write code like this?. . bool GiftCard::transact(double amount) virtual{.   if( (amount > 0) ||  (money + amount < 0  ) ){.       return false;. } else {.       money += amount;.       return true;. .  }. .    return false;. . }"|82|0|active|No because GiftCard does not have access to MoneyContainers private member variable money. You need to use the scope resolution operator to obtain MoneyContainers transact() which does have access the it’s own private member money.Also, the virtual keyword should be at the beginning of the function, and is not necessary. I think you meant to place the override keyword there instead.||0
lewchpejyoo5ac|Spring 2018 Written Portion Q4b|. . Could I define the constructor like this?. . GiftCard :: GiftCard(double value): capacity(value), money(value), MoneyContainer(value, value) {} |47|0|active|If I remember correctly capacity and money are private data members of MoneyContainer so that would cause a compile error since GiftCard doesn’t have access to the bases private members. The MoneyContainer constructor however is public.||0
lewcgbulne526q|Spring 2018 Written Portion Q2c|. . For the answer, I see we use the count function like count(ptr1+1, ptr2, item) and count(ptr2+1, ptr1, item), could we not plus 1 for the ptr1 and ptr2? That is because in the REQUIRES, we know item != elt1 && item != elt2.|65|0|active|+1 is not necessary, see blue comments at the bottom of the solution.||1
lewb1seqk1c18q|Spring 2018, midterm, written portion problem 2c)|For the answer, I see we use the count function like count(ptr1+1, ptr2, item) and count(ptr2+1, ptr1, item), could we not plus 1 for the ptr1 and ptr2? That is because in the REQUIRES, we know item != elt1 && item != elt2.|72|0|active|||1
lewawve23kz5zp|Spring 2018, written portion,  Problem4 (c)|"could I write code like this?. . bool GiftCard::transact(double amount) virtual{.   if( (amount > 0) ||  (money + amount < 0  ) ){.       return false;. } else {.       money += amount;.       return true;. .  }. .    return false;. . }"|56|0|active|||1
lewass4sqgr4ph|Spring 2018 Written Portion Problem 4b|Could I define the constructor like this?. . GiftCard :: GiftCard(double value): capacity(value), money(value), MoneyContainer(value, value) {} . |50|0|active|||1
lew9yfa7whm6rf|Question about inheritance|Hi, I wonder why we could not use the same format as a default constructor for the constructor with one parameter pass-in. And why should we guarantee one argument ctor? Thanks! . |48|0|active|I'm pretty sure that you are able to use that same format(delegating constructors) for the one parameter constructor, where you have Rectangle(double s) : Rectangle(s, s) {}. As for why we should guarantee a one parameter ctor, that was just our choice when designing the interface of the class. It's true that we could just use the ctor with two parameters or the default constructor, but we designed our interface to have a ctor with just 1 argument probably for convenience if the user wants to create a rectangle with the same width and height lengths. ||0
lew8r6m19fq2w6|can someone explain streams to me?|. I'm having a hard time understanding this graphic. Why do we need so many different versions of input and output? What does each mean and what are their relations to one another?|88|0|active|It’s the difference between a file input and a command line input if I remember correctly. Fin and Fout are usually what people use for files (I think those are manually set and can be changed if you want) and Cin and Cout are for the command line. The different streams (I stream and ostream) are how those streams are stored or made manually for testing if I remember correctly. ||0
lew82mieuia6kv|Problem roulette|Is there a problem roulette for 280?|82|0|active|@957||0
lew7nsd4ihb2ev|Practice exam 2019 1b|. Why do we use char ** and not const char *. |147|0|active|Because argv is a pointer to an array of c-strings so it’s a double pointer. char **argv is equivalent to writing char *argv[ ]argv[0] would be of type char * (pointer to a char) (more specifically, a pointer that holds the address of the first letter of a word) argv[0][0] (also could be written as **argv) would be of type char (a character) (more specifically, the first character of the first word pointed to by argv) ||0
lew7cv8zj2h1aq|static_cast|What if bird_ptr points to another object (e.g. of type Duck), would it cause an error?. |52|0|active|It would compile, but would result in undefined runtime error refer to @2611||0
lew5fypk7pn41f|When writing code output do we include: &#34;Program ended with exit code: 0&#34;?|. . That's all. |60|0|active|Nope||0
lew5186gyzj7cr|Why do overriding functions need to match the base return type?|If a return type is not apart of the function signature why does a compile error occur if a function, in the derived class, with the same signature (without the override keyword***) has a different return type from the base class function of the same signature? If a derived class function has a matching signature to a base class function, do the return types need to match?|46|1|active|In C++ the return types in this case need to match exactly (or at least be covariant - you can look that up on your own). This is just a decision made within how C++ is designed, other languages treat this differently (I think Java allows different return types iirc). ||0
lew4tmxz20u46q|Practice Exam 2018 Problem 0 10|Could anyone explain this to me? thanks. |129|0|active|I believe it’s true because arrays usually don’t have sentinel values (although they can) unlike c-strings which do. That’s why we pass when we pass int arrays, for example, we pass the size as well. int arr[3] = {2, 5, 6};neither 2, 5 or 6 provide us with any info about the size of arrSo the pointer to these values obviously doesn’t do any better at providing info about the size||1
lew44wf4syb5uy|access struct member outside of struct|Given that member variables of the struct are public, can we access these member variables outside the struct without producing a compiler error? (Since the textbook says that we're prohibited to do so, I'm wondering if it would cause an error) |45|0|active|"This prohibition is by convention, not enforced by the compiler. You may access members of a struct directly, this is what the ""interface"" functions do by using the dot operator (as seen in P2 with how the various interfaces were designed)."||0
lew3oa5rkji72l|struct|If we create a struct object without explicit initialization while one of the member variables in the struct doesn't has default initialization, would it cause a compiler error? (or an undefined behavior?) |55|0|active|"I think it will, except for a string type variable because string is automatically initialized as """"."||1
lew2oule6uy6ok|Asynchronous Lecture 8 - Abstract Data Types in C&#43;&#43; Question|Hi I just have a question about this problem from 4.1 Exercise: Professor Constructors.. . . Is const Coffee &coffee being passed by reference or is it an address to a coffee? I'm confused on how to distinguish passing by reference and passing an address. If the coffee is being passed by reference, why does favCoffee make a copy of 'coffee' if it is being passed by reference?|57|0|active|Passed by reference. More specifically, reading from right to left, coffee is a reference to a constant Coffee typeyou can distinguish between the two because & in this case is preceded by a type (Coffee) where as if it was on the rhs of the assignment &coffee would be the address. ||0
lew0z3zl9se39|C-strings|Screen_Shot_2023-03-05_at_6.26.13_PM.png. This is an example from Lab 4. I believe we were told not to compare c strings because it would compare addresses, and instead use the strcmp function. For this example, since we are dereferencing it and moving the pointer, is it fine. Also how does the while loop work, as it just has the names, does it just go until it ends? Thank you.|61|0|active|Yes you can dereference the two pointers and compare the characters live in those two memory addresses. At the end of a valid c-string, we have \0. (*str) will give a false value for the while condition, so it can stop there. Note that this is different from dereferencing a null pointer (which is undefined behavior).||0
levzbnccb2g7ai|Spring 2018 Written Portion Problem 1a|Is my solution valid?. . |83|0|active|||1
levykecbw4xdd|Spring 2019 Q0c Part 4|Screen_Shot_2023-03-05_at_5.19.20_PM.png. Screen_Shot_2023-03-05_at_5.19.28_PM.png. . For this question regarding the roller coaster class, the answer key says the while loop that checks the intensity of the ride, which was initialized with only a name and no intensity, would cause an error.  My intuition was that the intensity would default to 0 and the increase_intenstity function was assumed to have a proper implementation, so where is the error occurring here?|166|0|active|The compile error is in the while loop because it is attempting to access the private member variable intensity_level directly.||0
levydqblavt2tt|Could you edit the pointer part, if there was no const?|To clarify, if we make a pointer to a c-style string, can we never change it? Or is it because of the const in the signature of the pointer?. . Also, for the pointer example, how could we tell that it's a c-style string again? Is it just because of the way it's declared, since c-style strings are basically just arrays of chars, so we're pointing to the first element?. . |44|0|active|. To clarify, if we make a pointer to a c-style string, can we never change it? Or is it because of the const in the signature of the pointer?. . It's because of const. If not present, you can change it.. . . Also, for the pointer example, how could we tell that it's a c-style string again? Is it just because of the way it's declared, since c-style strings are basically just arrays of chars, so we're pointing to the first element?. . Yes. with char* or a literal char array. . . Could you edit the pointer part, if there was no const?. . yes||0
levx7rnqzux715|nullptr|Hi all, I'm wondering if dereferencing a nullptr would cause an undefined behavior or a compiler error.|53|0|active|undefined behavior. . see @2602 for what compiler errors would be||0
levx72mh14o5we|Spring 2018 Q17|Hi. Kind of confused about the answer to question 17. Are the arr[size] be {1,4,2,4,3}? Because the ptr+2 should be 6 in the original arr[size].|60|0|active|. Are the arr[size] be {1,4,2,4,3}? Because the ptr+2 should be 6 in the original arr[size].. . Yes, you are replacing 6 with 4. First, the right-hand side will be evaluated, and then the left-hand side.||0
levx6vg86qi4ne|If downcasting gives compile error, then why are we able to explicitly downcast?|I'm just a bit confused on why/how both could occur, if downcasting gives compile error.. . Is it because the explicit downcast is only used when it's like that chicken/bird example, where technically when we set them equal, the bird is referring to Chicken objects?. . I just want to clarify this/why explicit downcasting would work. Thanks!. . . |45|0|active|"Because with explicit down casting, you are basically implying to the compiler ""I know what I am doing."" So the compiler won't throw errors or warn you. But, if your down casting is wrong, it won't be detected at runtime; Instead, it will result in undefined behavior."||1
levweapb10s4su|dynamic storage duration|"Can someone help to explain this sentence in the textbook? Why it's not ""associated with a variable at all""?. . "|38|0|active|An object with dynamic storage is not associated with a variable because it can persist outside of the scope of a variable (any variable really in c++). The programmer creates dynamic objects, and its destruction is programmer's responsibility as well (which can happen in a different frame that the creation frame).||0
levwcf6qehz1ky|Const in array|Can someone explain this:. array_func_1(arrB); // ok. array_func_2(arrA); // error. |27|0|active|arrB (non-const) can be passed as the argument to a const parameter because arrB CAN or CAN NOT be modified (it doesn’t matter) and the const parameter just means that the argument will NOT be modifiedon the other hand, arrA (const) CAN NOT be passed as the argument to a non-const parameter because arrA strictly CAN NOT be modified and the declaration a non-const parameter does NOT guarantee that arrA WON’T be modified something that’s Changeable CAN be used by a function that ensures it will go Unchangedbut something that’s Unchangeable CAN NOT be used by a function that DOES NOT guarantee it will go Unchanged ||0
levvas8l2v03k5|Base and derived class constructor clarification|I have a few clarifying questions about constructors relating to base class and derived class:. . Middle example from screenshot below: is it an error because, in the derived class, we have one call to roadsCrossed. But, we have no call to a base class constructor? . . So if we list one thing in the constructor for derived class, then we must explicitly call the base class constructor now?. . Whereas in last example, there’s no call at all in the derived class constructor. So, it will implicitly call the base class default constructor. So, the derived class constructor is just the base class’s constructor? (also wait, what if there’s multiple base class constructors? What happens in this case?). .  . What if the base class has no constructor (so, it should implicitly have a default constructor)? What do we do in the derived class constructors?. . . |57|1|active|The compiler will provide an implicit default (no parameter) ctor ONLY if there are NO ctors explicitly defined by you. Since Bird has defined at least one explicit constructor that has one parameter Bird(name_in) and it hasn’t explicitly defined a default ctor, the compiler will not provide one for it. This is all to say that the derived class Chicken’s ctor will need to always make a call to Bird(name_in) because that’s Bird’s only ctor (a base (Bird) needs to be created/initialized before a derived (Chicken) is created).||2
levu9cp5tfy52c|strlen function|"a quick question, can strlen take a char* type pointer as a parameter? (e.g. char cha[6] = ""hello""; char* ptr = &cha ; int size = strlen(ptr)); If yes, does it function the same as strlen(cha)?"|40|0|active|yes since both ptr and cha point to the same object in memory (the first character of the c-style string) ||0
levu3f32i3m1qz|Compile error or Runtime error|Can someone explain what's the difference between these two with some examples?|58|0|active|Compiler Error: errors that happen because you did not adhere to the rules of C++. This can be syntactical issues or semantical issues. Syntactical issues mean you violated C++ syntax, whereas for semantical issues, the syntax is technically correct, but that line of code does not make sense. . . int a = 3 //syntactical issue, forgot ;. . string a = 3; // semantical issue, cannot assign an integer to a string. . Runtime error: As the name suggests, these errors happen when running the program. The ones you have encountered before are going out of bounds for an array/vector (seg fault) and dividing by zero.. . int a[3];. for(int i = 0; i < 5; ++i){. 	cout << a[i]; // once i == 4, will throw runtime error. }. . int a = 4 / 0; // divide by zero. . I also saw this chart online which summarizes what I said above.||1
levtemmumkd232|Doubt in the 2018-version midterm materials|Hi there!. . I noticed that there is some weird point in the key materials. runners is an inner attribute of the race-ADT, however, it shall be 0-indexed. num_runners is not 0-indexed. post-fix shall not be used here, in my opinion.. . . |4|0|private|runners is 0 indexed. num_runners indicates a size so it would make more sense for it to be not 0-indexed. . . Also what happens for runner_init is that we are basically making runners container one bigger (since num_runners is not 0-indexed). You do a post-fix so that after the original num_runners is used for making the container bigger, you also increment the num_runners because you have added a new runner.. . Feel free to follow up if something doesn't make sense.||0
levsp4cuvh01w|Can our cheat sheet be printed/consist of screenshots?|"Just wondering if this is an option, or if it must be all handwritten! So for example, if we could put images, and print it out on the 8.5""+11"" sheet. Thanks!"|217|4|active|There is *no* hand-written requirement.||0
levqvhutihe6nk|Question about pointer|I'm confused how could ptr get dereferenced here. It points to 0x1012, which should be out of main's scope. It's the last exercise of lec3.. https://lobster.eecs.umich.edu/async-lecture/3/lec3.html. . |40|1|active|. I'm confused how could ptr get dereferenced here.. . This is an example of using a pointer incorrectly. Pointers can always be dereferenced, but what they point to might/might not be what you expect which can cause undefined behavior.||0
levqjaihdw1v8|Spring 2019 0b #6|Can someone explain why this causes a compile error?. . |172|1|active|it causes a compile error because banana(int &c, int *d) takes in a reference to an integer for the first parameter and a pointer to an integer for its second parameter, but the call to banana doesn’t pass what’s expected since:the first argument passed to the banana call is a pointer to an integer (arr decays into a pointer) when it’s expecting an integer, and the second argument passed is a integer (*arr dereferences the pointer to first element, making it an int) when it’s expecting a pointer to an integer ||1
levprjghikl1tq|Midterm Exam Live Review Session|Hi everyone! As we're getting ready for the EECS 280 Midterm this Wednesday, staff will be hosting a Midterm Exam Live Review Session on Monday (3/6) from 7pm-9pm EST on Zoom. We'll be going over the solutions to this review sheet and answering questions, so we highly recommend you give it a try beforehand!. . Worksheet: https://docs.google.com/document/d/1kN0d6rFucqhV-05yL9wWwRuQK3qSBD7uRTxQ_MVBxyQ/edit. Slides: https://docs.google.com/presentation/d/1gM_t998qZ8UgFoYfWbN8W6SxKzH8SUy4qbEQYbIHZZQ/edit#slide=id.gf65ac369d9_0_337. Zoom: https://umich.zoom.us/j/92672681425. Recording: https://umich.zoom.us/rec/share/pmU-mOErE3o9QZ1pOurdXYXXBWRYlBueJl5IjgbNAYceCG368JBXQJwf01zxexw.EUMnn7mOk2s_4R5a. Solutions: https://drive.google.com/file/d/1xEr0U7flBirJJ49Sjyp_Om1uJiDS2_Qc/view?usp=sharing. . . See you there & good luck with your studying!. . eapple. . |1033|2|active|||1
levp46lmrz425r|When do we need to check for null pointers?|There are some cases when we want to check if we have a pointer that might be null by using if statements. However, I wonder in which case do we need to check if the pointer we have is a null pointer? |41|0|active|I think we need to check if it's null when we need to dereference it and it's uninitialized(which means it might be null). ||0
levorc4irzp1rv|Spring 2019 4c #3|Can someone explain why this causes an error?. |217|0|active|"rBot is a robot.. Presuming that Fighter Bot is a derived class from base robot, this doesn't compile because you're assigning the address of a Robot to a pointer to a Fighter Bot.. . We can do things the other way though!. . . FighterBot fBot = (""Baymax during the action climax of the movie"", ...);. Robot* rPtr = &fBot;. from there, we can use a dynamic cast to call fBot functions from rPtr.. . . dynamic_cast<Fighter Bot*>(rPtr)->StartFight();. . . Visit Manage Class to disable runnable code snippets. (I don't have the question in front of me, so I'm assuming start fight is a Fighting bot function)"||1
levo5s83t0g2rl|Spring 2019 Q4b|". . Why does it print ""Pow! pow!"" (part of the fighter bot introduction). . But it prints ""Hello my name is Megaman"" (part of the robot introduction) . . I would think that it would print ""I will destroy you"" instead?"|172|0|active|I think you mean Spring 19 Q4d***. The reason ptr->sound_effect() prints Pow! Pow! is because the function is declared as virtual in the static type of ptr (Robot), but the dynamic type of ptr is FighterBot so it will bind to the dynamic type’s (FighterBot) version of sound_effect().The reason Hi, my name is Megaman is printed for ptr->introduce() is because introduce() in the static type (Robot) is NOT declared as virtual so the compiler won’t bind to the dynamic type’s function. For an important exception where binding WILL occur even if the static type’s function does NOT have the virtual keyword refer to @2475||1
levl1msb8d2du|Conceptual question?|Hi, Is the following sentence true or false? Can anyone explain why this sentence is correct? I thought the constructor from the base class will not be inherited.. . Thanks!. . |55|0|active|Remember that the constructor of the derived class must call the constructor of the base class. It could only do so if it has access to the base class constructor. Therefore, it must also inherit the base class constructor.||0
levkpxuzfj91yk|Spring 2018 Exam Q18 (MC)|. . What does int *ptr = arr refer to or mean in the case of the for-loop. Is it being set to the size of the array? Why is B the correct answer?|122|0|active|Remember that:. . . int arr[SIZE] = ...;. cout << arr; // Has the same result as. cout << &arr // Has the same result as. cout << &(arr[0]). . So in the for loop, when you're setting ptr = arr, you're really just setting ptr to address of the first element of arr.. . And then you're checking if the item the pointer points to is less than SIZE (5), before incrementing the pointer.. . So:. . First Loop:. ptr is set to the address of integer object with value 1.. *ptr is equal to 1. 1 < SIZE, so we print 1. Increment ptr. . Second Loop:. ptr is set to the address of integer object with value 4.. *ptr is equal to 4. 4 < SIZE, so we print 4. Increment ptr. . . Third Loop:. ptr is set to the address of integer object with value 2.. *ptr is equal to 2. 2 < SIZE, so we print 2. Increment ptr. . . Fourth Loop:. ptr is set to the address of integer object with value 6.. *ptr is equal to 6. 6 < SIZE is false, so we break out of the for loop since the condition is met.. . In all, we printed. 1 on first loop. 4 on second loop. 2 on third loop. ||0
levjoh3w82a618|Array Addresses|Do we have to know specifically how the addresses of different elements in an array work? Like in lecture there's an example of an array that starts at address 0x1004 and then the third element in it has address 0x100C. I'm just kind of confused when/why letters come into the addresses in arrays, but I don't know if this is just a specific example that doesn't happen all the time / if its important to know how array addresses are assigned besides knowing they are contiguous.|37|0|active|The important concept to remember is that elements in an array are contiguous, i.e. the elements are placed next to each other sequentially in memory. The notation for the address (with the 0x and the letters) is a representation called hexadecimal. We won’t expect you to write hexadecimal :) TLDR : Thus, you don’t need to know how array addresses are assigned. Just remember that they’re supposed to be contiguous All the best for the midterm! You got this! ☺️||0
leuz51qde0455a|what Pickle(false, false, false) do?|. . Here, it seems that the member initializer lists only contain three bool variables is_sweet, is_sour, is_spicy. For the default constructor, why we need to add Pickle(false, false, false), could we leave the initializer lists' part empty such as Pickle(){}?|47|0|active|I believe leaving the initializer list/constructor empty would cause a compile error since that would mean the constructor does nothing. The Pickle() constructor is delegating the broader Pickle(bool is_sweet, bool is_sour, bool is_spicy) constructor by calling it to set all the member variables to false. You should not trust that the compiler will default set those bool members to false, so that’s why you need to do it explicitly instead of just leaving the initializer list/constructor empty. Besides delegating the other constructor, you can set each member individually in the initialize list Pickle() : is_sweet(false), is_sour(false), is_spicy(false) { } ||0
leuxr4879xr4u0|arrow and point|Under what condition shall we use arrorw instead of points? Does that only apply for struct?|49|0|active|Arrows are shorthand notation for dereference and then the dot operator and are typically used with pointers. For example we could have Person class and then declare a Person instance, Person p, and then declare a Person pointer, Person *ptr = &p. Under this circumstance, we could say  ptr->getName() (assuming getName() is a public member function of the Person class), which would be equivalent to (*ptr).getName(). Similarly, if we have the instance, we could just call the member function with a dot operator, p.getName().||1
leuw5yqtzum54l|Spring 2018 Q21|. Will c print out the address of flower? Also why isn't D correct?|154|0|active|Yes, I believe that answer c would print out the address of the object flower. Answer D is not correct because name is a private member in the Flower class, so we can't access it outside of the class directly.||1
leuvoqybzoq4ng|Spring 2018 Q16|. I am assuming it has compile error because of ptr[3] instead of the reason given by the answer. (since ptr is a pointer not an array). Can we use an int pointer to point to a constant int? Also can we say something like . int a = 5; const int * ptr = &a?|86|1|active|"Actually, I think that the error is in the line int *ptr = arr;. While you are correct that arr is an array, when we set a pointer to an array, then the array decays into a pointer. There is an error in this line because arr is declared as an array of constant integers, so when it decays into a pointer, we shouldn't be able to modify the array elements through that pointer, so the pointer should be const int *ptr = arr;. If we had const int *ptr = arr; then there would not be a compile error. In fact, I'm pretty sure that ptr[3] would work if ptr was declared and initialized as const int *ptr = arr; because ptr[3] is equivalent to *(ptr + 3), which would print out 6 in this case(I believe). To answer your second question, yes, I think int a = 5; const int *ptr = &a; works because we are promising not to modify ""a"" through ptr which doesn't ""break"" any previous const ""agreements"" if that makes sense. "||0
leuv95jr7koio|why here the second parameter we need to pass by reference?||56|0|active|Also, generally, if there’s no copy constructor for the object being passed as a parameter, the object must be passed by reference. The reason for this is that parameters are passed by value by default. Thus, passing an object by value essentially creates a copy of the object within the function. This requires the copy constructor. Thus, parameters are passed by reference for two main reasons 1) from student’s response : save memory 2) from instructor’s response : if there is no copy constructor for the object being passedAll the best for the midterm!! You got this ☺️||1
leuuny8dc8e41v|Spring 2018 T/F Q9|". I have two questions for this one. First I am a little confused about the meaning of ""breaking the interfaces"". I am assuming breaking the interfaces mean using wrong types of parameters (sending an int while it requires a string). Also, what is the difference of testing the behavior of the abstraction and the behavior of implementation? Aren't we supposed to test whether the implementation of the abstraction is correct?"|85|0|active|Adding onto the students’ answer with an example.I’ll be using pseudocode here for the sake of demonstration : This is a function with a logical error in that it returns the width as opposed to the height int Matrix_height(Matrix* mat){      return mat->width;} Here are two test cases that test whether the height of the matrix is correct TEST1 : assert(mat->height, 5);TEST2: assert(Matrix_height(mat),5);Here, test 1 breaks the interface by accessing the member variable directly. Test 2 respects the interface by using a function.However, both asserts evaluate to false because of the implementation mistake in the function. TLDR : When we ask about abstraction only, focus on analyzing the test cases as in this example. When asked about implementation, focus on analyzing the implementation of the function ||0
leus0mvfc8k5b9|fall2019 7|What does it mean by terminology discrepency?|43|0|active|||1
leupxl2eecl10f|Time Accomodations - Room Assignment|Hi!. . I received an email saying that I need to register to take the exam at the regularly scheduled time, or on March 9th. This would not allow me to receive my accommodations (1.5x, which I have for this class). How can I sign up to take the midterm? Please let me know. I emailed eecs280admin, but nobody has answered me.. . Thank you again!|5|0|private|With spring break, the staffing is limited as we are all on vacation. I bumped this request to admin and they should get back to you soon.||1
leuninvsuap6f|Fall 2019 1a|Can someone explain exactly what the helper function does line by line? Can someone also explain why you need this helper function and why you can't just do +pos instead of +str_len(src). I also thought adding a null terminator to a character index caused a compiler error but it's done in the solution.|81|0|active|||1
leumygust494ke|spring 2019 FRQ 4C question 2.|"Is this line an error because Toy class has a pure virtual function? If so, how come we can still do something like"". FighterBot fbot (""megaman"", 1987); . Toy *tptr = &Bot;. . So you can still create a pointer of an abstract class as long as it points to something else?"|184|0|active|Right. You cannot create a direct object of an abstract class type, but you can have a pointer of that type.||0
leuhsh99w315zs|Spring 2a|Screenshot_2023-03-04_at_4.41.09_PM.png. I wrote my solution in the other way. Is that considered wrong since a and b are both getting swapped?. . Thanks!|95|0|active|That would work as well.||0
leuhj283s974kk|Question about pointer|I'm confused about the solution of the second question. I think  ptr1 = &ptr2 makes ptr1 point to ptr2, which should not be a complier error because ptr1 is an address, and &ptr2 is getting address of ptr2, so it's also an address. Since both sides' type are address, it should not be an compiler error.. . My memory diagram:. . Solution:. |65|0|active|The address of an int variable has type `int*`, but the address of an `int*` variable has type `int**`. So we'd be trying to assign an `int**` type (`&ptr2`) to an `int*` type (`ptr1`).||1
leuh6hkjwv86rw|SP18 FRQ 4B vs. F18 FRQ 4B|"For spring 18, I understand why we need ""::"" for Giftcard::Giftcard, but when we call the MoneyContainer constructor, why don't we need to say MoneyContainer::MoneyContainer?. On the other hand, for fall 19, we used Phone::DaviceID to access the static variable. If anyone could explain the use of ""::"", that would be great. Thanks! "|97|0|active|SP18: The scope resolution operator is used in this case because we're implementing a class function outside the class itself. When calling base constructors within this constructor, we have direct access to them, so we don't need the scope resolution operator.. . F18: The scope resolution operator is needed when referring to *static* member variables, because the static means that there is only one instance of this object used across all instances of the class. So no matter how many `Phone` objects we have declared, as long as we have at least one, there will still be exactly one `Phone::DeviceID` in memory. This is just a C++ syntax thing.. . On another note, the other case where we need the :: operator is when calling a function from a base class and we want to explicitly state that we want to call the base class version, not the current class version. So for instance, with `Shape` and `Square` (which derives from `Shape`), if we wanted to call the `get_area()` function from `Shape` in `Square`, if `Square` has a `get_area()` function overriding the `Shape` one, we need to say `Shape::get_area()` to specify that we're calling the base class version.||0
leuftzt9nxo5p|L10.3_Shape|I don't understand the error here, I've implemented these functions in derived classes, can someone help to explain it? Thanks!. . |22|0|private|From the error, it seems like maybe you did not override these functions in your derived classes and didn't provide an implementation. If you share your code we can take a look.||1
leueyl7jk6t38i|L09.4_Square|I don't understand the error here and how to correct it. I've tried to put the const qualifier before the string parameter in each constructor, but it still doesn't work.. . . |40|0|active|This seems like a Lobster-specific issue. It runs fine for me on my local compiler.||1
leudntzur0k4fz|return|"A quick question, what does ""return ;"" do, is it the same as returning a nonzero constant?"|48|0|active|return; can be used in a void function to exit out of the function. It will not return anything.||0
leudme2ayhd71l|Fall 2019 0b 8|. |85|0|active|resolved||1
leudfm9b2tkwr|Spring 2019 4c|I was wondering why number 2 causes an error.. . |204|1|active|I believe it is because Toy is a virtual class (it has a pure virtual method) so you can't create an object of type Toy.||1
leudd78q5p472m|for loop clarification|For example, there is a for loop:. . for (int i = 0; i < n ; ++i). . Say n can be any int between -1 and 10. Will there be compiler errors if n == 0, or n == -1 ?|35|1|active|Nope, n can be any integer and the compiler should not have any problems. However, the condition would give false immediately and the for loop would never be entered.||0
leud78gkra932h|Fall 2019 0b 5)|. I would like to know why aren't x any y equal?|163|0|active|x and y aren't the string itself, but rather a pointer to the string. The reason they aren't equal is because x and y don't point to the same piece of memory.||1
leucjaxe9ij17x|Fall 2019 Practice Exam MC Q8|Could someone explain why the answer to this question is undefined and not the address of the first element of the array? I know that is not an answer choice but that is what I thought would be the answer. |159|0|active|It would not necessarily be undefined. The key is that it asks if the statement will *always* print an address. If the pointer is a char pointer, it will try to print a C-string. And if it's a proper C-string (i.e. it ends with the sentinel value), it'll print that string rather than an address.||1
leubq9ip7dv2og|Fall 2019 0a|Why is 8 false? I though pointers stored the memory addresses of the objects they point to, so what else might be printed if not an address?. . |161|1|active|see student answer and student followup||1
leub6ldwxx71au|spring 2019 0b - 3|. the correct ans is undefined, but I used lobster and the output is 3. What is the explanation for undefined?. Thanks.|212|0|active|The `apple` function returns the address of `a` which is a local variable, meaning it goes out of scope once the function. So, `z` points to junk memory, and the undefined behavior happens when we try to dereference it on the next line.. . The thing with undefined behavior is that *anything* can happen. It can print what was originally there in memory, or it can print a junk value, or depending on the address sanitizer, it can print an error once it's done running. In this case, lobster just printed the value that happened to be in memory at the time.||0
leuacmsqfpq5vw|Spring 2019 - need explanation on Problem 0. 10|. (The correct answer is True.). . . I'd like more explanation on this. Is this true because b and c are not declared as pointers?. . Let's say there's another case: If they were declared in the form of pointers (Bird *b, Chicken *c), and we write b = c, then what are b's static and dynamic type?|201|0|active|You are correct. The dynamic type of a variable that isn't a pointer will always stay the same as it's static type. If they were pointers, then the dynamic type would change.||2
leu7nzhs6s1sr|Spring 2019 FRQ #4 part c #1|This causes an error because of a function doesn’t exist in the static type, it doesn’t check the dynamic type is just causes an error?|166|0|active|If the function does not exist in the class of the static type, it causes a compile error. In this case, the `Toy` class has no `introduce` function, causing the error.||0
letmpb5l6nk3kp|Spring 2018 Q21|Is it possible to cout a class object? I thought only types like int, char, and strings could be printed directly, and printing a class would need an additional function to avoid compile errors?.  |98|0|active|"For A: Unless the class has an overloaded operator<<, you cannot cout the object.. For B: flower is not a pointer, so you cannot dereference it. It will result in a compiler error.. For C: it will print the address of the object since (&) is the address-of operator. for D: From student response, ""Since the function takes a reference to a flower object, this function is most likely outside the class. In this case, since the name is a private member, you cannot directly access it."""||2
leti00y7eea4fg|F19 #3c: why is there a pointer to pointer in last line?|I thought that Playlist_addSong takes in a song, so why are we doing *s2 in Playlist_addSong at the end?. Is it because we're actually derefencing the pointer s2, so we just get the song?. . . . . . |82|0|active|You are correct when you say that you are just dereferencing. Doing *s2 is not making a pointer to a pointer, but dereferencing it, and passing the value s2 points to into the Playlist_addSong function.||0
letg5cus3sw25|F19 FRQ #1: instead of incrementing dstindex, could we have just incremeted dst?|It seems like they keep track of the dst_index and incrementing it, so that we can set values in the dst memory.. . But instead, at the end of both for loops, could we just say ++dst? Wouldn't that just increment where the pointer is pointing to in dst? And at the end for the null char, we can just say *dst = '\0' since we incremented dst at the end of the for loop already?. |136|0|active|I think that you can increment dst and it would have the same behavior.||0
letf9v3gpex3f5|fall 2019 3c|"For the line after if(s1):. Why don't we use ""s1 ->"" before calling Songplays function (a function of Song)?. Is it because there is a *song_ptr argument in Songplays function? . . "|69|0|active|"Since *Song* is a struct, it doesn't actually have any member functions, so if you do ""s1->"", the compiler will throw an error for not being able to find that function. . . We implemented functions outside the struct definitions, which take in pointers to those structs and simulate the behavior of member functions in C++ classes. Recall p2 where Matrix, Images are structs, and their processing functions are defined outside the structs and take a pointer as a parameter."||1
letf27tj2xs4ll|When downcasting fails, is it compile or runtime error?||5|0|private|Implicit downcast is prohibited by C++, so it is a compile error.. . If it is an explicit downcast using static_cast, it won't be checked at runtime. If your downcasting is invalid, you will have undefined behavior. So it's neither compile nor runtime error.. . Check lecture notes for more info.||0
leteezuaefm10m|Checking Requires Clauses on Midterm|If it's not specified that we have to check a condition, should we still include assert statements to check the requires clauses of the functions?|49|1|active|"No, I don't believe you have to unless it tells you to. On the cover page of the 2019 exam solutions packets, they say: ""You do not need to verify REQUIRES clauses with assert unless instructed to do so""."||0
lete8jzgtci3dn|Fall 2019 2b|I'm a little confused by the first 2 lines -- I know that arrays are treated as pointers to the first object, but I don't really understand why we can index array if it's passed as a pointer to a const int. . . The way that I did this problem was using traversal by pointer: . . // I initialized max and min by dereferencing the pointer to the first element. int max = *array; . int min = *array; . . // then iterated through the array. for (const int *ptr; ptr < array + length; ++ptr) {. 	// basically the same implementation as answer key for finding min/max. }. would that ^ also work? . . . |128|0|active|Doing [0] with a pointer is the same thing at *(pointer + 0) which is why the indexing works. In your for loop, I think you need to do . . const int *ptr = array. . but besides that, it looks like it should work.||1
letdq8f1cyy5uq|Fall 2019 4e|. Is there difference between a pure virtual function and a virtual function? What is the relationship between a class being an abstract class and having a virtual function? |127|0|active|Having a pure virtual function in a class will make the class abstract. In derived classes, you have to override all the pure virtual functions, or they will be abstract classes as well.||0
letdk61443q6e|Practice Exam F19 Q0A|"In the 5th true false question in this section the statement reads: ""A derived class inherits all public member functions of its base class, including the baseclass constructor.""  And the answer key says the answer is true, but in lecture we were told constructors are not inherited.  Which one is correct?"|165|6|active|"~~The base class constructors are inherited in the sense that they are called upon initialization of the derived class object, so the derived class does implicitly have access to them.~~. . EDIT:. Let's review the facts.. * Derived classes may need a constructor for the same reason that ""vanilla"" classes may need a constructor.  For example, to initialize any added member variables.. * If you do not include a constructor in a class, the compiler adds one for you.  It is a default constructor.  It does nothing.  This is also true for derived classes.. * Derived classes are constructed starting from the base class.. . Now if you really want a short answer, it is this: Derived class constructors are not inherited by default.. . If you want a really long answer, check out this [SO post](https://softwareengineering.stackexchange.com/questions/197893/why-are-constructors-not-inherited).. . If you want a really really detailed answer, check out Stroustrup's The C++ Programming Language 4th ed. section 20.3.5.1 Inheriting Constructors.  It describes a special way to inherit construct with `using` in C++.  This is not something we teach in EECS 280."||1
letd2prgmvk1h1|Pointers|Screen_Shot_2023-03-03_at_9.42.31_PM.png. I believe the second one means that its a constant pointer to an integer. Would the first one mean its a pointer to a constant integer. If so isn't it written like int const *ptr or is it the same thing? Thanks.|33|0|active|See @2526||0
letc0drvmq15c2|Version control|version control is contained in the worksheet of lab 4, would this material also be tested in the midterm?|51|0|active|If it's part of a lab covered for the midterm, it's fair game.. . However, I would focus on other concepts/materials that you see on the practice exams.||0
letag1og6ni5pf|Fall 2019 1b)|. In this function, can I replace ifstream is(argv[2]) with the following codes:. string filename = argv[2];. ifstream is.open(filename);|162|0|active|I believe you need to instantiate **is** first and then use the .open() method:. ```. string filename = argv[2];. ifstream is;. is.open(filename);. ```||0
let7s2vfg0768v|Why does argv[2] print whole string, but *(argv &#43; 1) only prints out one character (b)?|"Isn't argv[2] the same as *(argv + 2)? So I'm wondering why argv[2] doesn't just print ""i"", the first element in the c-string in.txt? Like how *(argv + 1) does?. . I'm getting kind of confused by the difference, and also did see a similar question on F19 practice exam, which did seem to make sense.. . "|68|1|active|**(argv + 2) would be just the 'i' character. *(argv +2) would be the same as argv[2]||2
let7bcjmc55zu|How to define a very small struct?|"In the textbook, it mentions that ""Except for very small structs, we generally do not pass structs by value, since creating a copy of a large struct can be expensive."" Does very small structs mean that those structs don't have many member functions, or member variables? "|40|0|active|A c-styled struct does not contain any member functions. An example of a small struct may look like this: . ```. struct Book{.     string name;.     string ISBN;. };. ```. where the size of each instance of the struct is pretty small and can be copied relatively inexpensively (in terms of memory and time). . Something like a Image struct we implemented in p2 is a much larger struct and may be much more expensive to make a copy of it.||0
let6myhpig33z8|Testing on Midterm|I had one question about the content on the midterm. Will we be asked to write test cases for functions, or will we be asked any questions about testing in general on the midterm (basically is anything pertaining to testing fair game?)?|93|0|active|We could ask these types of questions, yes. ||0
let5xy52qw35j4|Fall 2019: 3b free response|why do we need the address of operator here?. . |94|0|active|song_title() and song_artist() receive a pointer to the song as their parameter. A pointer stores an address as value, so to pass that value to the function, you use address-of operator(&) to retrieve the address ||1
let5157o1d63n0|Fall 2019 0a Q1: do we still need to create an instance to access public members though?|This question seems straightforward, but I thought we still had to make an instance of the class itself, and then we call the public member? . For example, we could say. Student Joe;. Joe.get_name(); //where get_name() is a public function in Student class. . But didn't we still need to create an instance, with Joe?. So we can't just say:. get_name(). . I'm just kind of confused about this in context of the question. Also, what does static have to do with anything?. . |187|1|active|You don't need an instance of a class to access its **static** member functions or variables. A **public** member, which is accessible outside the class, is not the same as a **static** member, which is shared across all instances of a class. . . I believe you could use double colon ( :: ) to access static members outside a class without instantiation:. ```. class foo{. public:.     static const int CNT = 0;. };. . int main(){.     cout << foo::CNT << endl;. }. ```||1
let33wr5aho6f7|Pointers and const|Since the type that ptr is pointing to (what is to the left of the *) is not const, we can modify the object that ptr is pointing to. I wonder what's the point of using const for ptr when the type that ptr is pointing to is not const? Can someone explain this please? Thanks! |39|0|active|Each pointer you declare has a static type that is fixed at compile time. Although you can change what object the pointer points to, you should not point it to an object of a different type. For example, an int * should not be pointing towards a floating point object. One exception is polymorphism of classes like we did in p3. . . Having a const keyword when you declare a pointer, depending on the place you put it, can result in a pointer-to-const or a const pointer. The former tells the compiler that user should not be able to modify the object through that pointer, and the latter tells the compiler that the pointer should not be changed to point to anything else (but you may still be able to modify the object it points to).||0
let1wbikizx2j7|Arrays decay to pointers|. . . int arr1[4] = { 1, 2, 3, 4 };. int arr2[4] = { 5, 6, 7, 8 };. arr2 = arr1;  // error: LHS is an array, RHS is a pointer. . . . Can anyone please explain why LHS (arr2) is not a pointer?|42|1|active|"The actual reason for this is outside of the scope of this class, which involves terms such as lvalue and rvalue. I'm going to say it can't because that's the design of C++.. . To expand on the notes: The main reason is that in C++, things are ""by value"". So, then RHS becomes a pointer to the first element because that is what the ""value"" of arr1 is. However, you want to assign it to another variable; this variable is not a value but a name. When assigning value to a variable, it does not convert to its value but to its name. Since arr2 does not convert to its value, it is an array. You cannot set an array to be equal to a pointer to the first element of an array (or equivalent int *)"||0
let0vtuiw1lrb|2019 Fall 0a) Q10 const ptr|. Hello! I want to know what does the first ptr mean. I know the second one means a constant pointer pointing to an integer, and I assume that the key point is that properties following * belong to the pointer itself, not the variable it is pointing to. However, this does not make sense for the first one, since it does not have description of what the pointer is pointing to.|221|3|active|Your interpretation of what the second pointer declaration means is correct. . . The first declaration is an incorrect declaration. If * is used as a unary operator (an operator with only one variable/operand), the pointee type comes to the left of the *. So here, the first declaration does not give a type for the object the pointer is pointing to (the pointee).||1
lesyvyahxcpjf|Fall 2019 Q4 part e|If Laptop doesn't implement the `depletePower` function, would that cause a compiler error or something?|123|0|active|No, the reason there is an error in the code in part e is because Laptop doesn't implement the startUp function. startUp is pure virtual (because of the = 0 in the Device class), so Device is an abstract class. Since Laptop doesn't implement startUp, Laptop is also a pure virtual class. Trying to create an instance of a pure virtual class will give an error. ||0
lesy7j4240j3w9|Midterm Exam Coding Problems|Am I allowed to use `INT_MAX` or `INT_MIN` for the coding questions on the midterm?|67|1|active|Since we haven't explicitly covered that, you shouldn't need to||0
lesxjw0fdii3uh|Spring 2019 FRQ #4 part c #1|This causes an error because of a function doesn’t exist in the static type, it doesn’t check the dynamic type is just causes an error?|148|1|active|@2550||0
lesxht0gigz7k9|C string|Screen_Shot_2023-03-03_at_2.27.14_PM.png. Why do we need the const before the char, or is this just a lobster thing? Thank you.|42|0|active|Certain compilers won't let you have a `char*` type for a string literal and will only allow `const char*`. Other compilers allow you to work around that and just call it a warning. Looks like Lobstser fits into the former category||0
lesw2qnswan6i2|Comparison in C&#43;&#43; strings|"""If one string is a prefix of the other, then the shorter one is less than the longer (which results from comparing the ASCII value of the null terminator to a non-null character)."" . . Can someone take an example of this case please? Also, what does it mean for one string to be a prefix of the other? Thanks. "|52|0|active|Consider app and apple. Apple has the word “app” as a prefix. When comparing strings, I believe what happens is a comparison of each character one by one. So compare the first character, then the second and so on. What happens in the fourth comparison is that app has the null terminator (which is 0) while apple has ‘l’ (which is some ASCII value more than 0). And since 0 < value of l, we have app is less than apple.||1
lesw21m0xv12db|Q0b 8|Screen_Shot_2023-03-03_at_1.45.18_PM.png. Is the reason cout << y would be undefined because when you cout a c string, it goes until the null character, but y does not have it defined. So cout << x would actually print hello. Thanks.|45|1|active|Yes. If you initialize a c-string in the format of y, you will need to manually add the sentinel. ||0
lesr39s7gwl1z8|Example of strategies for keeping track of where an array ends|"Can someone give an example of this strategy from the notes about keeping track of where an array ends please? . ""Store a special sentinel value at the end of the array, which allows an algorithm to detect that it has reached the end."" . Thank you! "|64|0|active|Sure. For example a C-style string is an array of characters where the last element is a \0 nul character. If you wanted to use the likes yourself, you can add a value that you're sure isn't added to the array regularly (enforced with an assert), and use that as a sentinel. For example, if I have an array of integers and I enforce that a negative number can never be added, when I first initialize the array, I can set the last value to that negative number as a sentinel.. . NOTE: Generally, outside of C-Style strings, this is bad idea. If you're using an array, you set the size to a specific value for a reason, just compare the index to that reason (#define, or constexpr, or const static). If you don't know what the size of your array should be, don't use a static array :)||0
lesjjvs7cx4g3|Fall 2019 1b|For checking if there is not enough arguments, is it okay to just check if argc < 2 (the key checked if argc != 2 and argc != 3 but would argc < 2 be fine). . |4|0|private|"The language on the exam is a bit ambiguous since it asks to check if there are ""enough"" arguments which implies that it wants some sort of lower bound for argc. Nonetheless, the answer of argc != 2 && argc != 3 is more precise since the number of arguments must be exactly 2 or 3 for the arguments to be valid. Having 4 arguments, for example, would be invalid and should throw an error."||1
lesjbinx5bfw|Fall 2019 Exam Question|Is the reason nothing is printed out for question 5 because c style strings have a null terminator at the end whereas c++ strings do not, so x and y will not be equal?. . . |4|0|private|"Not exactly. Remember that C-style strings are just an array of characters with a null terminator and are handled as a character pointer to the first element of the array. When we are comparing two C-style strings, we cannot use the built it == operator; that will just compare the addresses of the two C-style strings. Instead, we would want to use strcmp() to compare the contents of the two C-style strings. (See Juett's lecture 6 slide 19). Just as another clarification, string literals like ""hello"" are also null-terminated even though it may not seem like it in the code. The compiler automatically adds the null character at the end."||1
leryzx6pa9f5v0|When a function&#39;s activation record is placed in the same location used by a dead activation record?|"In this example, the note said that "" When the print() function returns, its activation record is also reclaimed. Proceeding to dereference ptr produces undefined behavior. It so happens in this implementation that 42 is printed, but other implementations may have different behavior."" . . I wonder that how could we know if there is the case when a function's activation record is placed in the same location previously used by a dead activation record or the implementation might have different behavior?. . Thanks."|54|0|active|I believe the behavior you are describing is platform and compiler dependent, and it is unlikely that you can predict exactly where an activation record is put when running your program on an arbitrary machine. To avoid undefined behavior, just be responsible when using pointers.||0
lerx8dzkk0e735|Question about post-increment|There are certain cases where I am a bit confused by post-increment. Say we had a previously initialized array named arr[] and some previously initialized integer i. Assuming i is exactly one less than the size of arr[], what would the following code do? Would this result in a segmentation fault?. . . arr[i] = i++;. . I know that it will try to assign the value of i (not i+1) into the array, but does it assign it to arr[i + 1] or arr[i]? I guess more fundamentally, I am wondering if the post-increment operator increments immediately after getting i from the right-hand side (thus attempting to assign i to arr[i + 1]), or waits until it has completed the whole line (thus assigning i to arr[i]). Thanks!|101|1|active|Post increment will wait for the rest of the statement to evaluate||0
lerr2ze13kx2s|Difference between the first and second const in this function?|I'm kind of confused between what the first and second const do. . Is the first const relating to a pointer-to-const? So we can't change the values? . But what would the second one do?. |66|0|active|The first const tells the compiler that the return type is const int * (so yes pointer-to-const). The second one tells the compiler that we are not supposed to modify anything in the function (this would be a read-only operation). If something gets modified in the implementation, the compiler will throw an error for us.||1
lerptyc4kf36ob|Will someone post the solutions to lab 4 and onward?|Hello! I am trying to study for the midterm, and I notice lab 4 and onward do not have solutions posted? Would any of the instructors be able to add this? Thank you so much!!|87|0|active|Solutions have been released. Sorry for the delay.||0
lerpr4vcpn66sw|Spring 19 Problem 1 c)|"argv[1] is of type char *, why can it serve as a parameter to ""ofstream fout()"" . Since I feel like what is inside the bracket should be a string indicating the file name.. . "|90|0|active|". argv[1] is of type char *, why can it serve as a parameter to ""ofstream fout()"" . Since I feel like what is inside the bracket should be a string indicating the file name.. . A c-string will implicitly be converted to a string"||0
lerpe4ecfmvoo|Spring 19 Problem 1 a)|Shouldn't the initial value of length be the length of strings[0]? (second row). . |119|3|active|Well there is no way to set it to that, so I believe the loop should start at 0 so it will automatically make the first string the longest and initialize the length correctly.||1
leroccjrkmh75f|Respecting interface|Screen_Shot_2023-03-02_at_4.22.52_PM.png. For spring 2019 FRQ 3, how is this not considered breaking the interface? We aren't supposed to directly access members of structs like that I thought?|83|0|active|"Since c-sytled ADTs don't have member functions, we will need external functions like this one for similar effects. These functions are within the library and is meant for users to use as interface functions. Respecting the interface in this case means that you should not access members of the struct (such as ""a_ptr->name"") in other parts of the project (i.e. outside the file that Artist is in) but should just use the functions intended as interface. . . For a C++ equivalent, Classes, respecting the interface means only calling public member functions, and you should not directly (and in fact cannot) access private member variables."||1
lerkjoyaaoeei|About the pointer to array and string|Hi guys. I was confused about it. I cout both pointers, one for array type and one for string type. I thought it will both return me an address of the first element of the array and string. But it is not. The string one cout the whole string, does anybody know why? Thanks! (The code there are in lecture5(string) note). |68|0|active|Adding onto the student answer, when you pass a character pointer into cout, the program will keep printing characters until it reaches the null character '/0'. Check out this exam question for practice with this concept: @2465||0
lerk7ubhi486y8|Clarifying why the ptr needs to be a const?|Just to clarify, for the const Sandwich * ptr, does it have to be a const?. This would make it a pointer to a const right? And it makes sense since the Sandwich s is a const, so none of its members can be changed.. But would it lead to an error if the pointer was not const? . I'm guessing it would, since maybe someone could try to dereference the ptr, and try to change the member value when it shouldn't be able to be changed? Just wanted to make sure my reasoning was correct.. |59|0|active|"Your reasoning is perfect! ""ptr"" is a pointer-to-const meaning the thing the pointer is pointing to cannot be changed. Since ""s"" is a const variable, the pointer-to-const is a requirement."||1
lerjm6296396dn|Why would #2 be ok, and #3 be error?|For where there are comments, why is the second one ok, and the third one error? . For the second one, arrB is a regular array, but array_func_1 needs a parameter that's a pointer-to-const. So I don't understand why would this would work?. . And for the third one, array_func_2 just takes in a regular pointer, but arrA is a const. So is this an error because in the function, I want to change/modify it, but arrA is a const?. |59|0|active|If the parameter is const, you can pass in something that is not const and it will be fine, you just won't be able to modify the value in the function. However, if you have a variable that is const, you can't pass it as a non-const paramater, as there needs to be a guarantee that the value won't be modified within the function.||0
lerg3lr6bow6tp|Fall 19 Problem 4 std|"Given that ""using namespace std"" is present (Fall 19 midterm exam), do we still need to use std::cout? In Problem 4, the implementation of Device uses std::cout while those of Phone and Laptop just use cout directly, which confused me. . . "|120|0|active|If **`using namespace std`** is present, then you do not need to specify the `std::` namespace in your code. Keep in mind that you usually **never** want to use `using namespace ...` in a header (`.h`) file, so if you are writing code for a header file, make sure to use the fully qualified name including the `std::` prefix.||0
lerfwdrn2ti6io|Can someone explain this block of code?|#include <iostream>. using namespace std;. . int main() {  int * ptr;  int i = 2;  ptr = &i;    ptr++;  cout << *ptr;  }. It returns 73. Using *ptr++ also returns 73. Removing this ptr++ it returns 2. What's the correct way to increment i with the pointer, if there is one?|56|0|active|Refer to @2392 basically the way to do it would be (*ptr)++ so that the operator precedence of ++ doesn’t happen before the ptr is dereferenced.||0
lerfjreds6s4jr|Practice Exam Problem 4(e)|"I'm confused about ""Laptop being an abstract class"", shouldn't Device be an abstract class since it has a pure virtual function?. "|86|0|active|An abstract class is a class that contains at least one pure virtual function.. You are correct in saying that Device is an abstract class since it contains the pure virtual functions getDeviceID() and startUp().. When you first look at the Laptop class, it does not seem like it has any pure virtual functions. However, if we look at the pure virtual functions from the base Device class that were implemented in Laptop, only getDeviceID() was implemented. Therefore, the pure virtual function startUp() remains a pure virtual function in Laptop. This makes Laptop an abstract class.||0
lerffu2ksao2sh|Fall 2019 Problem3 a)|Why we don't need to init songs array of Playlist in this case. . |95|0|active|The intent of the problem is to create an empty playlist that can hold some songs, and the implementation uses an array of Song to store each song in the playlist. As you construct a Playlist object, the default constructor of Song is implicitly called to create Song songs[MAX_SONGS]; Since the playlist starts with no songs, you don't need to put any songs in the array, nor should you be accessing any songs in the array (since it should be empty). Therefore, you don't need to initialize the songs list. . . The actual values stored in the *songs* array depends on your implementation of the constructor for Song, but with an initial num_songs=0, you should not allow anyone to read any songs from the array.||0
lerf91lhrv37oc|Undefined behavior and compiler error|I'm wondering how can I distinguish undefined behavior from compiler error. I know some explicit examples, like dereferencing an uninitialized pointer would cause undefined behavior, and dereferencing a nullptr would cause a compiler error, but is there any criterion?|55|0|active|A compiler error occurs during the compilation process when the code violates the rules of the language, preventing the code from being compiled. . . For example:. ```c++. x = 5; // compiler error: 'x' was not declared in this scope. ```. . On the other hand, undefined behavior occurs at runtime when the program executes in a way that is not well-defined by the language standard.. . For example:. ```c++. int a[3] = {1, 2, 3}; . a[5] = 4; // undefined behavior: accessing out-of-bounds element. ```||0
lerdtt11psg7n|Should we get familiarized with hexadecimals for the midterm?|For example, we should write 0x1012 should be written as 0x100c? It was something about it being base 16, but I'm not too familiar with it. Thanks!|75|0|active|No you don't need to||0
lercw8ysjy014|C&#43;&#43; string and C string: can they contain spaces?|Can a C++ string and a C string contain spaces?|5|0|private|"I am not exactly sure if this is what you mean, but C++ strings and C strings can contain spaces. A space is just like any other character. So, the following is valid code:. . std::string cpp_str = ""EECS 280"";. const char c_str[13] = ""Hello world!"". Follow up if I didn't answer your question!. . I bet other students are asking the same question! If you feel comfortable, make this post public!"||0
lercao1flcr56z|Fall 2019 Practice Exam Question|Why would the output for this piece of code (practice exam - fall 2019) be 42 and not 43?. . |164|2|active|Because the ++ operator puts a copy of the original value in the current line of code and increments value afterwards, the line. ```. cout << (*b)++ << endl;. ```. is equivalent to. ```. cout << (*b) << endl;. *b += 1;. ```. So the value printed is the value of a in this case, 42. The following code would print 43: . ```. cout << ++(*b) << endl;. ```||0
lerc0d2oedv16e|Fall 2019 Q0A|Can anybody help to explain why this is false? Thanks!. . |259|2|active|Not all structs are examples of ADTS. Some are just used to group together some data, and those are called compound objects. For instance,. . struct Person {.   string name;.   int age;.   bool is_ninja;. };. is a compound data object, but not an abstract data type||1
lerazftagot6yd|Prac Exam|Hi, where can I find the two practice exams? sorry for the dumb question, genuinely cant find them.|89|0|active|Go on eecs280.org and on the left there is a files button under office hours. It will take you to a google drive and the practice exams are under the exams folder. ||0
lera3yjvfo6jw|Difference between polymorphism and inheritance (and derived classes)?|"I think these terms are generally understandable, but sometimes I'm having trouble differentiating between them, or the ""hierarchy"" of the definitions/concepts.. . So derived classes are kinda like an example of inheritance, where we're inheriting code and not duplicating it?. . And what about polymorphism, and subtype polymorphism? Is it relating to the same thing?"|76|0|active|I recommend checking out lecture notes for Inheritance and Polymorphism.. . They are very detailed, and if you have any questions about them, feel free to follow up here.||0
ler91kzcgdl68q|Lab 2: does doing &#43;&#43;ptr change the address of the pointer?|For the second question, about if ++ptr does anything interesting, I just wanted to clarify what it means by being a local variable (because of int *ptr in the func parameter?). . I thought that, in main, saying funct(&x) was pass by reference, but now that I'm thinking about it, the &x is just giving the address of x, not saying it's pass by reference right?. . So that's why it'd be a local variable?. But either way, I still want to clarify what ++ptr would be doing? Is it changing where that new local pointer is pointing to?. |121|0|active|"I believe your thoughts are correct. . . The function . ```. int func(int * ptr) {...}. ```. takes in a **copy** of a pointer to an int, which means if you modify **ptr** inside func(), the **copy** of ptr lives inside the func() memory stack gets modified, but not the original address that gets used in the function call (in this case, &x remains unchanged). . If function definition asks for a pass-by-reference of a pointer to an int:. ```. int func(int * & ptr_ref) {...}. ```.  which means passing in a parameter called ptr_ref that is a reference(&) of a pointer(*) of an int), now if you call func(&x) and try to ++ptr_ref in the function, there will actually be a compiler error: ""You cannot bind a non-const reference to a prvalue"" (I got this from lobster). This is because x lives on the stack, which is not memory managed by you through pointers, and it would be very problematic if you can just change where stack objects pointers point to. If x lives in the heap, I believe it would be okay (but be mindful, ++ptr may cause memory leak if used irresponsibly). . . Also yes, ++ptr is changing where the **local** ptr is pointing to by shifting it one unit up. This could be problematic if you try to dereference it now because we don't know what is at that memory address This is undefined behavior. Once func() execution is completed and returned, **ptr** will be automatically deleted. However, the modification you did to x through ++(*ptr) will remain."||1
ler5o3lx8b6qp|Fall 2019 Question 1|"For the following question (question 1) from the Fall 2019 exam, I am confused about the line ""*(dst+dst_idx++) = *it"". If dst_idx is initialized as 0 and we add 1 in the first iteration, won't we be filling in index 1 of dst first instead of index 0 (*dst would fill in the first index but *(dst + 1) would fill in the second index. . "|7|0|private|Since the ++ is after dst_idx, it increments dst_idx by 1 after ALL the operations in the line are done. That means it does *(dst+0) = *it and then dst_idx++.. . I bet other students are asking this question! If you feel comfortable, make this post public!||0
leqq7z8g7t031o|Delegating Constructors / Initializer List|Are there any other cases besides delegation of constructors where an initializer list is necessary (where the assignment of member variables cannot be done within the curly braces because that would create a local object that would not live on past the constructor)? |47|0|active|I don't think any other functions other than the constructors need an initializer list. Objects in these functions could be from: the parameters passed in, local variables you created, class member variables, or objects you create on the heap. In all these cases, you either call constructors for those types when constructing them, or the objects have already been constructed for you to use.||0
leqplejhnwd6in|Proper Subtype / Liskov Substitution Principle|"Can a proper subtype have ""extra"" properties (added member variables/functions) that aren't present in the base class as long as it follows the Liskov Substitution Principle?. Also, for the proper subtype DerivedUnicorn, how is it that DerivedUnicorn can be substituted for Unicorn if there could be possible cases where fire_laser_beam() should return a value between 100 and 9000 (inclusive) which is not possible in DerivedUnicorn's fire_laser_beam() function. . "|50|0|active|A derive class can have have extra properties (added member variables/functions). In the above case, a Unicorn and DerviedUnicorn can behave the same because they both have the same fire_laser_beam function declaration (meaning they both can fire a laser beam). The strength of the laser beam might be different but this would make sense because if they had the same laser beam strength, they would be the same unicorn and we won't need a DerivedUnicorn.||0
leqn691r4xo79x|Virtual Functions &amp; Subtype Polymorphism|Is the virtual keyword only required for the function in the highest class (highest Base) if all the lower derived classes have the override keyword, but not the virtual keyword. . Example:. . I don't understand why the last cout statement (cPtr->f2()) is 6 and not 4 since the static type's (Citrus') f2() function doesn't have the virtual keyword, only the override keyword. So how would cPtr bind to the dynamic type's (Lemon's) f2() function?|81|1|active|This is a tricky question! When a function is declared as a virtual function in a base class, it automatically becomes virtual in every derived class of the base class (check out this article). Since f2() was declared as virtual in the base Fruit class, it is also virtual in the derived Citrus class. Therefore, cPtr->f2() on the final line would invoke Lemon's f2() returning the value 6.||0
leqn2jf7b6b590|Practice Exam Problem 4(c)|Does the initializing sequence matter?. |120|0|active|Yes initializing sequence should start with the base class, and then the rest of the variables in the order they were declared.||1
leqmmk5ov7t1gy|Practice Exam Problem 4(b)|Solved.|54|0|active|Resolved||0
leqlaajsnccai|Coding rules|"I just want some clarification on this rule. I'm wondering what does ""implement and call helper functions"" mean (I feel like we can't implement a function within a function right?). "|64|0|active|Right, I believe this is referring to a question which didn't have the function declaration already written before the answer box, so you could write helper functions along with the actual function answer. If you're given an answer box in between two curly brackets of a function body, then you can't write a function within it.||0
leqklrmhby8fz|Is the override keyword required in derived class function if the base class function is virtual?|Is the override keyword required in derived class function if the base class function is virtual?|7|0|private|The override keyword is not required. Adding the override keyword just allows the compiler to do a sanity check that the function signature matches something in the base class, which can be useful for catching bugs.. . I bet other students are asking this same question! If you feel comfortable, make this post public!||0
leqi62o0upe7oa|Is upcasting followed by a downcasting safe?|Here is the problem and the sample solution in Lecture 10 of Juett Async Lecture.. The sample answer says this may lead to error (question on the second picture). My concern is that it is an upcasting followed by a downcasting, so it is known that it has the characters of the Chicken type. So Is it safe to do so?. . |6|0|private|Downcasts are never safe! The chicken variables aren't saved in the upcast to a bird because a bird doesn't have those variables.. . I bet other students have this question. If you feel comfortable, make this question public!||0
leqgi84ccw0651|Practice Exam Problem 1 (b)|"I think the while loop condition should be checking if the pointer is null, so why is the condition ""*str "" instead of ""str""? Thanks.. "|197|0|active|It shouldn't check if the pointer is null, but rather it should check to see if the pointer is pointing to the null character. That is what marks the end of the string.||1
leqerwbsno041j|Will operator overloading be in the midterm exam?|I don't think my professor has covered this, but I saw operator overloading in other eecs280 lectures (and projects as well), so I'd like to make sure if it will be covered in the midterm. Thanks.|61|0|active|Yes it is fair game for the midterm||1
leqedhcozs56ly|Will Generic Programming and Template be in the midterm?||53|0|active|I believe only lecture 1-10 will be on the exam, so if it is covered in the Polymorphisms lecture or before, then it is fair game for the exam. ||0
leqa3pvwmiv457|Practice Exam Fall 2019 Problem 2 (a) 3|I put the codes in Lobster, and it has compile error.. . . . |245|1|active|"The code given in the exam is correct, the error is due to a limitation in Lobster. When declaring an array in Lobster, you have to specify the size. So, if you change the first line to the following, it should work just fine:. . const char *arr[3] = {""hello"", ""world"", ""lobster""};. . . If you try compiling the code as given in the exam in your favorite IDE, it will work."||1
leq6mevxise78i|Spring 19 Exam Q7|Q7. True/ False. . Because struct member variables are public by default, directly accessing the membervariables of a C-Style ADT (without calling an ADT function) is not considered breakingthe interface.. . Can anyone tell me why this is false?. . |89|0|active|Directly accessing the member variables is allowed in this scenario. By that, I mean the code will compile. However, respecting the interface means that the users of your struct are using it as intended, and directly accessing member variable would not be the intended use.||0
leq6hz979k6st|Why can we not return a local variable by reference?|Statement: It is unsafe for a function to return a local variable by reference.. . This will return the address of the variable, but why this is unsafe? |56|0|active|Variables created inside a function will be reclaimed by the computer after the function call is finished. If you return a reference to a variable created in the function, the reference would refer to a piece of memory your program should not have access to. This would lead to undefined behavior (and probably a seg fault).||0
leq6fctns36121|Why is this statement False?|Why is this statement False?. . If str is a pointer of type char * used to traverse the characters in a C-style string, the end of the string is reached once str becomes a null pointer.|42|0|active|I think the end of the string is reached once the dereferenced str is the null character, whose address is unlikely to be a null pointer.||0
lepzjs7y6rzej|const &amp; pass-by-value functions|If a function uses pass-by-value for a parameter, why would it ever matter if that parameter or the argument is const since it cannot make changes to the actual argument (only the copy)? I am not sure if this has shown up before in the projects or lectures, but when would it make sense to make a pass-by-value parameter const? . I thought of this question when working on this exercise from the asynchronous lectures (int_func_3(num);). |32|0|active|Great question! You are correct, to the caller of the function, the fact that the pass-by-value parameter is const doesn't matter. However, a const pass-by-value parameter is useful to the writer of the function. . For example, if the writer of the function wants to ensure that the parameter is never modified within the function, they can declare the parameter as const and the compiler will ensure that it is never modified.||0
lepxrhgdg8d48q|Lab worksheet answer key|For the midterm I wanted to review some of the lab worksheets and was wondering if there is an answer key for the old labs? Thanks!|70|4|active|I believe the worksheets on gradescope includes possible corrections/answers.||0
lepo2lpxu1o6p4|Lecture Question|For this slide, is the second local Triangle variable that is created referring to the extra Isosceles triangle with side lengths of 0, or is it referring to something else?. . |4|0|private|"The extra unwanted object this slide is referring to is the one labeled ""Triangle"" in the memory diagram on the right. The pitfall this slide is referring to is calling the base class's constructor outside of the member initializer list, which is what is highlighted in red. . To understand this a bit better, let's take a closer look and what happens when we run the line of code in main():. 1. Objects of derived classes are always constructed from the base class down to the derived class. Since no triangle non-default constructor was specified within the member initializer list of the isosceles constructor, the Triangle default constructor is called setting sides a, b, and c to 0. . 2. After the Triangle constructor is run, now the Isosceles constructor can run (again because objects of derived classes are constructed from the base class down). Looking at the Isosceles constructor, it creates a new Triangle object by calling the Triangle non-default constructor; since this triangle object has no name specified, it is called ""anonymous"". This unintended anonymous non-default constructed triangle object is what we see at the bottom of the memory model on the right. . . To set the Isosceles member variables correctly and prevent the pitfall of accidentally creating an anonymous Triangle object, we want the Isoceles constructor to look like this:. . . class Isosceles : public Triangle {.     // ....     Isosceles (double base, double leg) : Triangle(base, leg, leg) {}. . }. . . This slide has a lot of tricky concepts on it so follow up if you want anything covered in more detail!"||0
lepdjogn2mz601|Access to previous midterm review sessions?|Hi,. . I've recently been looking through the archive to assist in my studying. I noticed that in a few years, there are certain worksheets that coincide with midterm review sessions for that year. I was wondering if anyone knew of away to view these sessions that happened previously, as I know we are able to watch lectures from previous years. If so, please let me know. Thanks so much!. . |73|2|active|Same question!. . Also, if you don't mind, do you know where I could access the archive? Not sure if it's somewhere in the publicEECS280 folder.||0
lep320qizbf2l4|Is it okay for a derviced class to miss one/ have no pure virtual functions ?|In fall 19 exam, the base class Device has three pure virtual functions: depletePower, startUp, and getDeviceID. A derived class, Laptop doesn't have depletePower and startUp. Does Laptop need to have all pure virtual functions un order to compile?. |56|0|active|Laptop does not necessarily need to implement every pure virtual function, but then it must be extended by some class which does. You can still compile just code with the class if you don't implement all the pure virtual functions, but if you try to create an object of type Laptop, and it doesn't implement every pure virtual function, then there will be a compiler error.||0
lep2n4ooce73o7|Fall exam 19 4(c) Laptop constructor|. . 4c) (from Fall exam 19) asks us to write out the constructor for Laptop, a derived class. Why is it Device(brand_in) instead of brand(brand_in)? . . . We have brand as a private variable in the Device, Base Class.. . . |151|1|active|It's calling the constructor of the base class with brand_in :)||0
leozcztcrnc3e8|Materials|Are there any more practice problems besides the 2 practice exams?|72|0|active|I might recommend going through the lecture slides and solving some of the problems on those slides.||0
leox5r9jd2w7k5|Where can I find a recording of the review zoom?|for the midterm|58|3|active|I believe they will release that in the piazza post after they are done with the session. ||0
leosn33rehzm8|dynamic_cast|I'm wondering why it requires at least one virtual function. Since I see no implication from the implementation of dynamic_cast..    |99|0|active|I feel like these explained it far better than I could. . StackOverflow. StackOverflow. . Hope that helps. If it doesn't, feel free to get back to me and I'll try my hand at it.||1
leos8wa08176j7|Lobster exercise L10.3_Shape error|"For the Lobster exercise L10.3_Shape (deleted the ""secret"" function). . Lobster tells me that I have errors in the virtual functions, but I don't know how to fix them. Could anyone take a look at my codes and tell me where's wrong? thanks!!. . Here is my code. . . #include <iostream>. using namespace std;. . const double PI = 3.14159265;. . class Shape {. public:.   virtual double area() const = 0;. .   virtual double perimeter() const = 0;. . };. . // Write definitions of the Circle and Square classes here. class Circle : public Shape{. private:.   double radius = 0;.   double area1 = 0;.   double perimeter1 = 0;. public:.   .   Circle(double rad) : radius(rad){}.   . .   double area() const{.    return radius*radius*PI;.   }.   .   double perimeter() const{.    return radius*2*PI;.   }.   . };. . class Square : public Shape{. private:.   double side = 0;.   double area2 = 0;.   double perimeter2 = 0;. public:.   .   Square(double input) : side(input){}.   double area() const {.    return side*side;.   }.   .   double perimeter() const{.    return side*4;.   }.   . };. . int main() {.   Circle c(1.5);.   Square s(2.4);.   Shape *ptr = &c;. .   // result: 18.8496 28.2743 .   cout << ptr->perimeter() << "" "".        << ptr->area() << endl;. .   ptr = &s;.   // result: 4.8 1.44.   cout << ptr->perimeter() << "" "".        << ptr->area() << endl;. . }"|3|0|private|I see no errors with your code. Feel free to refer to https://onlinegdb.com/vqO_LBuj5. . . Other students may be asking this question! If you feel comfortable, please make this post public so they can see it.||0
leos2rm3q2q1xg|Virtual|Do base classes need to implement virtual functions? I know they need to implement pure virtual functions or they are abstract too.|48|0|active|. . Derived classes do not have to implement all virtual functions themselves. They only need to implement the pure ones.. . . . . Source||0
leoron3vbc0nb|Pass by reference with pointers|Part b of question 4 from the first practice test. int countChargedPhones (const std:: vector<Device *> &devices). . Devices is now passing by reference a vector of device pointers. Why pass it by reference here when we already are using pointers? How would this change the problem.|181|0|active|"Fantastic question. References and pointers in this problem are fulfilling different roles.. . To start out simple, let's imagine that instead of a vector of Device*, we're dealing with a vector of ints:. . int countChargedPhones (const std:: vector<int> &devices). In this case, we have a constant reference to a vector of integers being passed in. References allow us to change the object directly. We saw how this could be helpful in the swap function from lecture.. (Quick Refresher for those who need it). . void my_swap_val(int x, int y){.   int temp = x;.   x = y;.   y = temp;. }. . void my_swap_ref(int& x, int& y){.   int temp = x;.   x = y;.   y = temp;. }. . int main(){.   int x = 0;.   int y = 100;.   my_swap_val(x, y);.   cout << x << "", "" << y << endl; // Will print 0, 100.   my_swap_ref(x, y);.   cout << x << "", "" << y << endl; // Will print 100, 0  . }. Why references?. In this case, reference are useful for letting us change values outside the swap function.. . However, in our vector<int> example, we can see that it's const. Meaning we can't change the value. So what's the point of a reference if we can't change the value?. . The point is that when we pass by value, we make copies of the parameters passed in. When we pass by reference, we never make a copy. Depending on how big our vector is, that could be a really big deal. With a reference, we'll never have to hope the vector is small. Plus, with references, the swap function can be called even if the parameters don't have a way to be copied (but that's for later in the class).. . That's why we're passing in a reference to a vector rather than a copy of the vector.. . Let's go back to the original problem:. . int countChargedPhones (const std:: vector<Device *> &devices). Like with a vector of ints, we're passing the vector of device pointers by reference so we don't have to copy the whole vector. This would be regardless of the type of the elements in the vector. They could be doubles, floats, integers, pointers to integers, birds, triangles, it doesn't matter, the vector would still be passed by reference.. . So the question becomes:. Why a vector of pointers?. . And that really was really an implementation decision. You COULD have made it vector<Device> instead, but we chose to do pointers. There are advantages and disadvantages to that decision. In my mind here is the biggest pro and the biggest con for using pointers.. . Pro. Normally, when an element is added to a vector with something like push_back(object). Under the hood, vector is actually making a copy of that object. If the object is large, maybe that's not something you want. By pushing a pointer, instead of copying the whole object, you're only copying the pointer (8-bytes on most computers).. . If that's not enough to worry you, it's worth remembering that vectors grow by creating a new array, copying over all the values from the old array to the new array, and getting rid of the old array. That can be a lot of copying. If your Device class doesn't have a good way to be copied, it won't even compile. So we use pointers.. . Con. . The biggest con of working with pointers is memory management. If you have a vector of pointers in main, and somewhere 15 minutes later in your program, that pointer gets deleted, you might have just corrupted your vector with a dead pointer.. . . I would choose to go with pointers. What would you choose?. If anyone needs further clarification on this, let me know."||0
leor8gm8d0u1lz|const qualifier|Is the const circled effects the same as (const int x, const int y)?. |29|0|active|There is an important distinction to make. The const you circled specifically means that none of Matrix's member variables will be changed in the body of that function.. . The const you circled says nothing about the parameters being passed in being const, or even the return value being const.. . In other words, no the const you circled is not equivalent to (const int x, const int y). . If you'd like me to go further into specifics of constness, I'd be happy to. Just let me know||0
leooq4bab6n5m5|private variables in base class|"I learned something the same as the note in the attached picture, but when I used lobster to define a base class bird with private member variable age and a derived class duck, I implemented a public function in the derived class called ""addage"" to increase the age by 1 (age++) it did work. So I'm wondering what it means by saying that the private member of the base class is inaccessible to the derived class.. "|47|0|active|It means that the duck class cannot access the bird's private member variable age.. . . It can, however, use a public setter function.. . . If you want a member variable of a base to be accessible by derived classes and private to everything else, it shouldn't be marked as public or private, but as the third option: protected. . ||1
leooke38f9b51s|Midterm Tested Lecture Material|Hi, I just wanted to make sure that I know what the midterm is going to test us on. It has been stated that it is everything up to and including Polymorphism. So any content from lectures 1 to lecture 10 (Polymorphism) is fair game, and nothing after (lecture 11+ - container adts etc) will be tested, correct?. Thank you!|67|0|active|Correct||0
leoj5lov167315|Constructor|For the third constructor, I'm wondering what's the mechanism behind. Is it just syntax or there is indeed a copy from Triangle(3,4,5) to t3?. |87|0|active|"This question is really great because it touches on an oddity of C++ syntax.. . If you had:. . int a = 0;. it would act the same way as:. . int a;. a = 0;. . But they're both fundamentally different concepts. The first is called initialization.. Initialization is when you create an object and give it a value in the same statement. This can be done through a constructor, such as in:. . Triangle t1; // Default constructor. Triangle t2(3,4,5); // Non-default constructor. Or it can be done with '=' which will also call the same constructor if on the same line as its declaration, such as in:. . Triangle t3 = Triangle(3,4,5); // Also non-default construcor. The copy constructor will not be called. If you want to toy with this, here's a link to a simplified example I whipped up https://onlinegdb.com/YN0iFArz0U.. . The copy constructor WOULD be called for something like this:. . Triangle t4(t3); // Copy constructor. Triangle t5 = t3; // Copy constructor. In other words, for the copy constructor to be called, the right hand argument must be a named object. When initializing t3, notice that the right hand argument does not have a name, so the copy constructor is not called.. . . Assignment happens after you've already initialized the object, and then change its value. For example:. . int a;. a = 0;. Or in the triangle example:. . Triangle t1;. t1 = Triangle(3,4,5);. Again, this is fundamentally different than a constructor.. . . A strategy that works well for me to determine if something is assignment or initialization is to see if my code would compile if my objects were const. For example:. . int main(){.   const Triangle t1; // Compiles.   const Triangle t2(3,4,5); // Compiles.   const Triangle t3 = Triangle(3,4,5); // Compiles.   const Triangle t4(t3); // Compiles.   const Triangle t5 = t3; // Compiles. .   const Triangle t6; // Compiles.   t6 = Triangle(3,4,5); // Error: can not assign to a const object.. }. I hope that helps clear things up. Let me know if there's any confusion.. . In case you didn't want to click the link, here it is:. . #include <iostream>. . using namespace std;. . // I was too lazy to find the full class, so for the sake of a simple example, we'll pretend a triangle has one side.. class Triangle{.     public:.     Triangle() {cout << ""default"" << endl; x = 0;}.     Triangle(const Triangle& copy) {cout << ""copy"" << endl; x = copy.x;}.     Triangle(int a) {cout << ""non-default"" << endl; x = a;}.     .     private:.     int x;. };. . int main() . {.     Triangle t1; // Prints default.     Triangle t2(1); // Prints non-default.     Triangle t3 = Triangle(2); // Prints non-default.     Triangle t4(t3); // Prints copy.     Triangle t5 = t3; // Prints copy.     return 0;. }"||0
leofbx1bjsg5pr|Not able to pass an array of array to a function|I am trying to test my code on 2b) from Fall Exam 19. I. initialized the array of array in this way: int arr[3][2] = {{4,4}, {7,2}, {4,3}};. And the function call is int search(int **arr, int length_outer, int length_inner). . The compiler is throwing an error saying no matching function. Why am I getting this error?. . |182|0|active|It seems that the compiler is only capable of letting the outer array decay to a pointer. When I declare `arr` like:. ```. int a[] = {4, 4};. int b[] = {7, 2};. int c[] = {4, 3};. int* arr[] = {a, b, c};. ```. it seems to work.||0
lenpo55fc5y2dl|stream input|"I'm wondering for the fourth example, why it ""parse the next characters from the stream as a floating point value"" rather than a double value( actually, I'm not clear about the situations where we use ""floating point value"" and where we use ""double value""). "|79|2|active|"That second part isn't quite right Ayan :) but you're really close!. . You definitely got the first part: a floating point number is a binary number that approximates a decimal value.. With integers, not amount of 1's and 0's can represent a fraction.. . Floats, like integers, are 4 bytes (32 bits). I'm happy to go into details as to how floats are implemented if you're interested, but the short of the problem with floats is that it turns out 4 bytes is approximately enough for 6 or 7decimal digits of precision. In some cases, that's not enough.. . That's when you'd use a double. A double is actually short for ""double precision float"" which, rather than 4 bytes, is 8 bytes long (64 bits). This gives us a lot more precision (16 or 17 decimal digits).. . So float and double and both valid C++. They're just a tradeoff between memory consumption and precision. If precision isn't NECESSARY (most situation) use a float. If precision is important (for example in physics simulations), use a double."||0
lenmrq6uaj05w5|fstream|"Can anybody help to explain these four conditions for the while loop? For example, for the first condition, since the file can be opened, I feel like the while loop won't end.. Also, I don't get the explanation for the extra line ""goodbye"" clearly.. "|51|0|active|fin.fail() isn't only for when you can't open the file. fin.fail() will also return true if you can't read anymore from the file. In this example, this will happen when your reach the end of the file. All of these check for a similar condition. When you can't read from the file anymore. However, by checking this, you will run the loop one extra time (when you read the eof character), which will print the last word in the file again.||1
lenkq6743du7ld|meaning of x---x|"I saw ""x---x"" in the slide of lecture 6, I'm wondering what does it mean(i.e. (x--)-x or ...?)"|47|0|active|"Your understanding is correct. ""x--x"" equates to ""(x--) - x"". My recommendation would be to run the following code in Lobster to get a complete understanding of what's going on:. . . int main() {.     int x = 2;.     cout << x---x << endl;. }. . . A brief summary of what's going on:. First, the post-fix operator executes leaving a copy of the value of x and decrementing the actual value of x in memory. Then, the copy of the value of x is subtracted from the newly decremented value of x resulting in an output of 1.. $$x---x \rightarrow (x--) - x \rightarrow (2) - 1 \rightarrow 1$$"||0
lend93aokdp496|Exam fall 2019|". If x is char x[] = ""hello"";, wouldn't c be the correct answer? Or does cout never print the sentinel character?"|169|0|active|The strlen() function counts the number of characters up to, but not including, the null terminator. Let's take a closer look at the c-style string x. If we write its contents as an array:. . char x[] = {'h', 'e', 'l', 'l', 'o', '/0'};. Counting the number of characters before the null terminator, we get that strlen(x) will return 5. Therefore the for-loop in the question will only iterate 5 times printing up to, but not including, the null terminator.||1
len95zzmiel465|Things covered on exmm|I just wanted to clarify if ADTS and lectures 11 and 12 will be on the midterm. |74|1|active|No, only lectures up to and including polymorphism (lecture 10) will be on the midterm.||0
lemt8jxw4oo5xe|Structs and the Motivation for const|"I am slightly confused about the following statement: ""a function could mistakenly change the contents of the caller’s copy of Triangle t"". I would appreciate if I could get some clarification on this topic. Thanks!. . "|150|2|active|"Absolutely. This is a great question, would you be okay with me making it public so other students can see it?. . Let's start with a simplified example:. . int add_integers(int* ptr_x, int* ptr_y){.   return *ptr_x + *ptr_y;. }. . int main(){.   int x = 10;.   int y = 10;.   .   cout << add_integers(&x, &y) << endl;.   cout << x << "", "" << y << endl;.   cout << add_integers(&x, &y) << endl;.   .   return 0;. }. In the above example, we have a function that returns the sum of two integers. It takes two pointers as parameters. We can read the integer being pointed to by dereferencing the pointers.. Then, main prints out the sum, the values, and the sum again.. . The result?. . 20. 10, 10. 20. As we would expect, sum up 10 and 10, and we get twenty.. . However, that's not the only way we could have written our add function. Let's try another way:. . int add_integers(int* ptr_x, int* ptr_y){.   *ptr_x += *ptr_y; // Instead of returning their sum, we set the value of x to the sum and then return x.   return *ptr_x;. }. . int main(){.   int x = 10;.   int y = 10;. .   cout << add_integers(&x, &y) << endl;.   cout << x << "", "" << y << endl;.   cout << add_integers(&x, &y) << endl;. .   return 0;. }. The result?. . 20       // Works as expected. 20, 10   // x is now 20. 30       // The sum of x and y is now 30. Obviously, when you add two numbers, you don't expect it to change either of those numbers. But maybe someone only saw the header file declaration of add_integers and decided to use it. They don't know how it's implemented, and so get a result they did not expect.. . We can fix this problem through the use of const. The const keyword int this context makes a promise that you will not change the value an object. So let's rewrite our add_integers function using const.. . int add_integers(const int* ptr_x, const int* ptr_y){ // Notice the consts!.   *ptr_x += *ptr_y; // This line will not compile because we've made a promise not to change either integers.   return *ptr_x;. }. . int main(){.   int x = 10;.   int y = 10;. .   cout << add_integers(&x, &y) << endl;.   cout << x << "", "" << y << endl;.   cout << add_integers(&x, &y) << endl;. .   return 0;. }. The result?. . Error, will not compile.. . Which is great. It means that anyone calling your add_integers function can rest assured that it won't have unintended side effects, because if it did, you'd have gotten an error.. . . I'll make a post with a discussion about how to read pointers later in the week, and I'll link it here when I'm done. The short of it is that when we wrote const, we made the integers the pointer points to constant, not the pointer itself. This is good.. . . Back to triangles:. Let's get back to the original question.. . . double Triangle_area(Triangle* t){.   t->a += 1;.   ....   return area;. }. . int main(){.   Triangle t = {3,4,5};.   cout << Triangle_area(&t);.   return 0;. }. When we calculate the area of a triangle, we don't expect the size of the triangle to change in the process.. . If we were to call Triangle_area in the above example, the first step is changing one of the sides. . . So what do we do about that?. We make Triangle_area promise not to change the Triangle being passed into it. We can do that in the same way we did with integers earlier:. .. . double Triangle_area(const Triangle* t){ // Now the Triangle pointed to by t is constant.   t->a += 1; // This line will not compile.   ....   return area;. }. . int main(){.   Triangle t = {3,4,5};.   cout << Triangle_area(&t);.   return 0;. }. Since line 2 would cause an error, we'd have to fix it by making sure the Triangle isn't being changed.. And that's the beauty of const, it helps you find errors rather than bugs that are very difficult to find.. . . I realize this bug might seem obvious now that you see how it works, but in your own work these will be much more difficult to find.. In my view, unless your functions NEED to change a value, I'd set it as const by default. It's much easier to remove const than to add it in at the end. Not everyone agrees with me on that.. . . "||1
lemt0uas45b4yg|Lecture 5 Question|"For the following exercise in Lecture 5 slides 38-39, is it necessary to have const Triangle *t = triangles for the first part of the for loop, or is it okay to just have Triangle *t = triangles since the function double Triangle_area(const Triangle *t) already expects a cont argument (and as mentioned previously in the lecture, ""You can use a pointer-to-T anywhere you expect a pointer-to-const-T, but NOT vice versa"". . "|7|0|private|You're right. Technically you can. It is ill advised for the same reason as @2395. If something CAN be const, it SHOULD be const.||1
lemcrx0o2b64c|Operator Precendence of *ptr&#43;&#43;|"I tried ""*ptr++"" which turns out to be an error. I don't know why even if ptr=0X2714(the address of y), we can't use * to dereference it then.. "|114|1|active|"This is an excellent question and comes down to operator precedence. Does the de-reference happen first, or the post-increment?. We can look at an operator precedence chart to tell us which goes first. Anything in precedence 1 will happen before anything in 2, will happen before anything in 3 etc. . Within precedence categories, which one goes first will depend on associativity of the category. Either left first, or right first.. . . . In this case, we can see that post-increment comes first, followed by the dereference.. Remember that post-increment says ""first we'll use the current value for the rest of this line of code, and then we'll increment it."". . So, as your stack states, we'll assume ptr starts at 0x2710.. We then apply a post-increment to ptr, which means after this line of code, we'll need to increment ptr.. . Next, the dereference. Now the dereference doesn't actually do anything because we don't do anything with the resulting value.. . After that, ptr is incremented. Because it's a pointer to an integer, and integers are 4 bytes, it will now hold the value 0x2714. . . Solution: Operator precedence is really hard to get right. If you're not sure what comes first, just add parentheses. There's no cost to parentheses within reason. It'll also make your code more understandable to other people who don't know operator precedence by heart (including me).. . (*ptr)++ . . Unambiguous.. . "||1
lem8j456jft68h|stack frame|"I'm wondering, at this given time, how much amount of memory on the (call) stack is needed by the program? Assume an int takes up 4 bytes, and that the memory to store local int objects is the only memory used by the program. In fact, I'm wondering if we should take a,b in minOf3 into consideration here.. . Also, is the answer ""compile-time property"" for the question below?. "|60|0|active|"I don't know if I'm addressing your question, but we can see in the above screenshot that main has 3 integers stored in it (12 bytes), and minOf3 has 5 integers stored in its stack frame (20 bytes).. . a,b is definitely counted in minOf3. You can assume that anywhere you see ""int"", you're allocating a new 4 bytes on the stack."||0
lelz6ao6luh2o2|Midterm coverage|Just to make sure, the midterm doesn't cover previous projects we've done right?|98|0|active|Everything up to and including polymorphism (Lecture 10 I believe).||0
lelrkiym6yy5uw|Alternate midterm exam email|Has anyone who is registered for the alternate exam received an email about it? Do any instructors know when we might expect to receive it? Thanks!|82|0|active|Those should have gone out. If you haven't received one, I recommend emailing eecs280 admin. :)||1
lelf11835hq1u4|Lecture 2 Question|The first section of Lecture 2 goes into great depth about binary and hex (converting binary to decimal, hexadecimal concepts, etc). How much of this do we need to know for the midterm (or do we just need to generally know that addresses are stored using binary / hex).|4|0|private|Unfortunately, I can't answer this for you.. Material from lectures 1-10 (up to and including Polymorphism) are covered.. . My advice is to look for bolded words in the slides and make sure you understand them.||0
lejh14tqip76py|Didn&#39;t Understand the Exam Classroom Docx|It's a stupid question but I really didn't get it.... Could someone help me explain how to find the classroom based on the uniqname and shared docx?. My uniqname starts with j, so how should I check the table? Thanks a lot!|181|0|active|. Sure, so if your uniqname comes before JAXXXX (inclusive) (i.e. before JAXXXY (exclusive)) alphabetically, then you are in DOW2150, between JAXXXY (inclusive) and JJBBBB (inclusive), DOW2166, and after JJBBBC (inclusive), IOE1610.. . To figure out if your uniq name comes alphabetically before/after, compare letter by letter. So if it was JJAMES, for example, you would go in DOW2166||0
leivto7gpaf3js|Exam practice aside from practice exams|Are there any other resources outside of the practice exam that we can use to practice, or are the practice exams the only resource that are given to us? I asked if there was a problem roulette and it seems like there isn't, is there anything aside from the given practice exams such as access to the online exams or multiple choice problem sets, or no?|10|0|private|We don't have any additional resources besides what's been publicly announced. However, practice exams and lab worksheets do a pretty good job of giving an idea of what to expect on the actual exam.||0
lehx7ees94a27g|Midterm review resources other than practice exam?|I wonder if we have something like problem rolet in eecs 183. Is there any other resourses other than practice exams?|120|0|active|This is my personal favorite resource (https://eecs280staff.github.io/notes/). I took notes on these when I took the class to make sure I understood everything. If I had questions on what code would do, I would put it into repl.it  and test it. You can also use lobster to test it as well.||0
lehwq4vy91s6fj|Midterm room clarification|My uniqname start with y, should I go to Angel Hall auditorium C? So it's on central campus, not north?. . |136|0|active|Yes. It's on central.||0
lehfth1w4b6374|Midterm Exam|"This message contains the details for the EECS 280 midterm exam.. . ## 1\. Time and Location. When: Wednesday, March 08 at 7pm ET. . Those students with an alternate or accommodation will receive a confirmation email with time and location.. . Rooms are assigned by uniqname.  For example, if your uniqname is catmouse, it is in the range of ARUAON - CHLFFF, thus your exam room would be CHRYS220.. . | Room | Uniqnames |. | - | - |. | AH AUD A | AAAAAA - ARTYON |. | CHRYS220 | ARUAON - CHLFFF |. | DOW1005 | CHLGGG - DAJLLL |. | DOW1010 | DAJMMM - DSJBBB |. | DOW1013 | DTTTTT - FEDTTT |. | DOW1014 | FEEEEE - GRADDD |. | DOW1017 | GRAEEE - HKFFFF |. | DOW1018 | HKFFFG - IAOOOO |. | DOW1206 | IAOOOP - ISIIII |. | DOW2150 | ISRRRR - JAXXXX |. | DOW2166 | JAXXXY - JJBBBB |. | IOE1610 | JJBBBC - KBARTOM |. | EECS1003 | KCCCCC - KRISHB |. | EECS1005 | KRISHC - LCLLLL |. | EECS1012 | LCNNN - LERRRR |. | EECS1200 | LERRRS - LUCHHH |. | EECS1311 | LUCHHI - MCRRRR |. | FXB1008 | MCRRRS - MISSSS |. | FXB1024 | MISSST - MTTTTT |. | FXB1032 | MTTTTU - NAFFFF |. | AH AUD B | NAFFFG - ROHTTT |. | GGBL1025 | ROHTTU - RUUUUU |. | GGBL1045 | RUUUUV - SAATSS |. | GGBL1571 | SAATST - SMAJJJ |. | GGBL2153 | SMAJJK - SUSTTT |. | LBME1130 | SUTTTU - THWEIJ |. | CSRB2246 | THWEIK - VBAJOS |. | AH AUD C | VBAJOT - ZADDDD |. | COOLG906 | ZADEEE - ZZZZZZ |. . ## 2\. Policies. The exam will be in-person, on paper, with a 120 minute duration. Staff will be outside the exam room to answer questions.. . The exam is closed-book. You may use one note sheet, 8.5""x11"", double-sided, with your name on it.   . . No calculator will be necessary, and no electronics of any kind are permitted. The exam will be given under the Engineering Honor Code.. . ## 3\. Preparation. The content will include everything up to and including Polymorphism. The format will be a mix of short answer, true/false, multiple choice, and free response code.. . Practice exams are posted on Google Drive.  We'll host a remote exam review session Monday, March 6, 7pm - 9pm ([Zoom](https://umich.zoom.us/j/92672681425)).  We plan to record the session.. . ## 4\. Schedule. There will be no lecture and no lab during the week of the exam (Week 9, Mar 6-12).  We plan to release grades via Gradescope on Tuesday night (Mar 14) with a 48-hour deadline for regrade requests.. "|1194|2|active|||6
lehfhbz36cy5zq|midterm lectures covered|just to make sure, anything past container ADTS inclusive will not be on the midterm? (i.e only up to lecture 10)|108|2|active|Only content up to lecture 10 will be on the midterm.||0
leg7bezn9eo13b|Where can I find my room assignment|Where can I find my room assignment for the midterm|111|1|active|Be on the lookout for an email that will be sent out soon with the midterm information.||0
lefyo1c8ir749s|Arrays|Just to clarify, arrays always are decayed to pointers. So if I had this code int arr[3] = {3,4,5};int *ptrArray = arr;. arr[2] is implicitly saying the address of arr + 2 and derference that.. ptrArray[2] is saying the exact same thing.. Thanks!|73|0|active|Yup! That sounds about right.||0
leet4cpdryu6c8|slides with answers and/or annotations|Is there a way to get Juett's slides with his annotations and answers of the examples, because I am trying to study, but I cannot know whether my answers are right|63|0|active|He usually goes over them with a video, or the lobster has its own auto-grader to check your implementations. These are usually gone over in the James Juett Async lecture links||0
leesla2b6n6d9|Can anyone explain this to me|. As with any pointer into an array, we can use the subscript operator to index into the array:. arr[i] = i;. This is equivalent to:. *(arr + i) = i;. How are these equivalent?|94|0|active|arr[i] is just shorthand for writing out *(arr + i). They do the exact same thing, they just have different notation and we typically use [] rather than *() just because it is quicker, but both ways are the same and both are completely valid. If you want some more details about what exactly *(arr + i) does, under the hood arr is converted to a pointer to the first element of arr, so when we do (arr + i), we move i spaces down the array, to the ith element of arr. * is the dereference operator used to get that value. arr[i] is just shorthand for incrementing arr by i and dereferencing that value.||1
lec4356gquh2qy|cheat sheet|do we get a page front and back cheat sheet for exam 1?|173|0|active|Yup! One 8.5x11, double sided.||0
lebn2e7v7o2zs|Midterm practice exam?|Hi, I saw this on Canvas, but don't see any pinned post on Piazza regarding the midterm practice exam.. Will doing the midterm practice exam and submitting it on Canvas be an extra credit opportunity?. |122|0|active|The practice midterm exam will be released soon and won't be for credit or extra credit.||0
leb0w96mab16b|Static Keyword|"I am confused by the meaning of this sentence:. . ""Member variables that are static need not be compile-time constants. However, a member variable that isn’t a compile-time constant cannot be initialized at the point of declaration"". . Can anyone give me an example of static not being a compile-time constant? Also why can't a non compile-time constant be initialized at declaration?. "|80|1|active|A static variable doesn't need to be a compile-time constant because a static variable is just a variable shared by all instances of that class, which can be changed. If for whatever reason you want to track how many instances of some class was ever initialized, you can set a member variable static int cnt and increment it every time you call constructor of that class. . . A non-compile time constant doesn't get its value hard coded in at compile time. Instead, it is given a value at its initialization at runtime, and since it is constant, once initialized, it will not change during its lifetime. I believe there is an *inline* feature in C++17 that allows you to set the value for a const member of a class at declaration, but I don't know how that works under the hood or if that is good practice. Plus, autograder only uses C++11.||0
leaj8xnjcvp58o|Lectures Covered|What lectures will be covered on the midterm? |83|0|active|Lectures 1 through 10 will be on the midterm. Lectures 11 and beyond will not be covered in the midterm.||0
le7p0l8gos4qg|arrays in memory|does the array name exist as an actual pointer to the array's first element in memory like this? If so, is that how c-strings are also represented (and are they contiguous as well)? |80|0|active|Your question is a little confusing, but I'll try to answer what I think it could be asking. Let me know if I interpreted it wrong and I'll fix my answer.. . Variable names are not stored in memory if that is what you are asking. However, the array variable 'a' really does just point to the first element of the array.. . Cstrings are represented the same way, and have a null character at the end which represents the end of the string. Here's an image I found that helps explain it:. . ||0
le5x8l4u5135vd|Midterm Preparation|Hello,. With midterms coming up soon I was just wondering what the best way to study for this exam is. What materials should I use to optimize my study time?|204|1|active|We will be released (or have released) a bunch of practice exams from previous semester. I always find that these are the most helpful for studying as the format of the actual exam will most likely be very similar to what we have put out in the past!||0
ldgsf5kqrdw12a|Questions about Midterm problems practice|Do we have Problem Roulette or something else just likes on EECS 183 that we can use to practice multiple choice problems of past years?|209|0|active|While we don't have a problem roulette, you can access practice exams in our public drive here.||0
lddl3vslr2r1nq|midterm date|Hi, when is the midterm. because on the class site it says its on the site but i cannot find it|145|0|active|Marking as resolved||0

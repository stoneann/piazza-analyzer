post_id|subject|content|unique_views|good_question|visibility|i_answer|s_answer|num_followups
l9x9z4papyv4ft|P4 FAQ|"This is the thread for P4 FAQ's.  Reminder P4 is due on November 13th at 8pm!  Please add your uniqnames on Piazza (the post @6 gives you instructions on how to do so).  This really saves us so much time when helping you whether it be looking up your code on the AG or doing anything exam related.. . The p4 intro session to be determined..  . Q: What is a linked list/iterator?. A: A linked list is another kind of container and an iterator is an object used to traverse and access elements in a container. You can refer to the lecture slides or the class notes (https://eecs280staff.github.io/notes/) if you have any questions..  . Q: Why am I getting an error related to accessing a private member of Iterator in a List function?. A: By default private members of the nested Iterator class are not accessible to the List class. The solution is friendship! We'll be covering friend declarations in the Iterator lecture. .  . Q: Should I test the destructor/How do I test the destructor?. A: You should write tests for every function that you can. You're not responsible for testing the destructor in your test cases, but you should use a tool like the address sanitizers to ensure that your code isn't leaking memory. You shouldn't call the destructor explicitly! The compiler does so automatically when the object dies..  . Q: Why am I getting a segfault/undefined behavior?. A: In general, a common cause for segfaults and undefined behavior in this project is uninitialized pointers. Make sure whenever you create a pointer variable (like first, last, or the members of a Node) and even after you delete the pointer that it is given a clear value. Use your visual debugger as well as address sanitizers to help ensure every pointer is set to the correct value..  . Q: Why does my test case compile on CAEN, but not on the Autograder?. A: Double check that you haven't added any public functions or made one that was originally declared private, public. Also, double check that you've not put using namespace std in a header file. Also, you can't compare an Iterator with a pointer.. . Q: How do I start api.cpp? What should the program look like?. A: Be sure to check out the project intro slides here.  They include information that you may find useful when implementing api.cpp.  Think about where you need to take input from, and what different things your program needs to be able to do with it. Then, break your code up into different functions or a class or whatever structure you'd like - just try and keep things organized, and don't just use one giant function.. . Q: On the style check I'm getting a ""memory is allocated but not initialized"" error whenever I create a Node.  But I'm initializing my Node data member variables in the lines directly following.  How do I fix this?. A:  This occurs because the style checker sees that you create your Node on one line, but is not smart enough to check the following lines to see that you initialize the members of the newly created Node. This can be solved in a few different ways.. . Default constructing your members then initializing them.. . Node* n = new Node{};. n->datum = datum;. .... . Using brace intialization to create the new node.. . Node* n = new Node{next_in, prev_in, datum};. . Creating a default constructor for Node.. . We recommend options 1 or 2, since they are easiest to implement and integrate into your existing code. Option 3 is a little more complex, but good practice.. . Happy coding!. . pinkedlists"|798|0|active|||1
lb728gz22342ha|P4 Canvas Grade|The full grade for P4 shown on canvas is 75. Should I worry about this?|123|3|active|I noticed this as well, I hope it doesn't change tbh.||2
lb70kucenjk1jk|Project 4 Canvas Grade vs Autograder|Hi there! On autograder I received a 65 / 95 for project 4, but on canvas I have a 65 / 75. Just so that I have a better idea when computing averages for my final grade, which one of these is correct? Thanks!|10|0|private|||0
lauh80u914j4sl|Trouble with P4 API working with index.html|My implementation of api.cpp made use of whitespace to find data like location and uniqname from json's, however what the server sends isn't indented and has no new lines.  I've tried changing line 760 of index.hmtl to the code below and there still is no changes despite examples on the internet showing that should be the solution.  Am I better off changing my implementation to work for the server and not for the test cases?. . . body: JSON.stringify({uniqname, location}, null, '\t'). |47|0|active|||0
lan33rx0mbd3cq|Question about &#34;insert&#34; implementation|"On autograder, it says I failed the test case ""List test insert 3"". I have my implementation below and I would like to know what the mistake in it is. Thank you.. "|8|0|private|Marking as resolved. Please follow up if not.||0
lajx2scqdpv4bd|No problems in CAEN but failed most of the tests for proj 4|My project 4 was working completely in CAEN, but failed most of the private tests because of memory leaks or undefined behavior. I want to understand the pointers and these topics, but I can't if I don't know what went wrong. Would office hours be able to tell me what went wrong? Thanks. |118|0|active|You should set up [ASan](https://eecs280staff.github.io/p1-stats/setup_asan.html) (note: you may have a better experience using it on your own computer rather than CAEN). You'll get specific line numbers where errors were detected. You can absolutely go to OH, but it's likely they'll have you do this—but you may still find it helpful to have someone explain how to use what it reports.||0
lairoppwbk6693|Not grade on the highest score|Why my final grade is not on my highest grade submitted? Thanks!. . |144|0|active|I'm guessing that your 49/49 submission ended up failing more private tests than your 48/49 submission and that made the full grade lower overall.||0
laip3mswj8w7me|What should be the correct implementation for Iterator big three?|Thanks|144|3|active|The Big Three was not necessary for Iterator, only for List.||1
lahntzmxnq5608|can we insert datum to an empty list using insert()?||136|0|active|"The REQUIRES of the insert function is ""//REQUIRES: i is a valid iterator associated with this list"". For am empty list, it has ""valid"" iterators. Note that valid iterators are not the same as dereferenceable iterators."||0
lahmu7dajl82s|List_compile_check compiles but never runs|is it supposed to run? Every time I run it I get segmentation fault but my code runs fine on autograder. |89|0|active|It is supposed to run - if you have a segmentation fault you have a memory error somewhere.||0
lahl3dxyw751wk|List copy ctor|Do I need to set this.sizes to other.sizes in the copy ctor? sizes is a private member variable I created to track the size of the list. . . |12|0|private|Yes, but be careful bc copy_all might also be incrementing the list size||1
lahkpz0em2208|Error in unit test frame work|Could someone explain why I'm getting this error? Thanks.. . |95|0|active|You may have a bad test name? Check to make sure you don't have two tests with the same name and that you don't have tests with the same name as C++ keywords (e.g. `main` or `int` or `map`). But usually you shouldn't be getting errors in this part of the code.||0
lahiq7ctig16t1|test suite doesn&#39;t run in terminal and fails on AG but works in IDE|resolved|7|0|private|resolved||0
lahhy94o7xz3n1|Style Checks on Test Cases|After catching all the bugs on my last try, my final submission for P4 was taken points off for code duplication style checks on the test case file. Are we supposed to check for style points in our test cases as well? This was the first time I've had style issues in the test case file. . . If it by any chance is the case that we are not held accountable for style check issues on test files, would it be possible to earn the points back?. . Thank you|6|0|private|We also do check for style in your test cases. Unfortunately in a class of over 1000 students, we have to maintain our policy of no extra submits or exceptions in order to be fair to everyone.||0
lahfyxiasgm3hk|Why does this test fail?||7|0|private|The address sanitizer output is complaining about heap-use-after-free, which essentially means that you are trying to use a pointer to an object on the heap after it has been deleted. In this case, be careful about using an Iterator after you have used erase on it (hint: the erase function frees up memory on the heap).||0
lahdmm8o1ij28u|what does this mean in autograder for project 4|No Compilation Warnings . why am i failing this?|78|0|active|In the autograder, it looks like the issue has been fixed. Please follow up if not!||0
lah0gj78mzg5z0|how do i use the iterator constructor with a node in test?|how do i get a node in test? or a node to the last element?|86|0|active|You can't do this directly because the constructor is private. You will have to use the `begin()` function from `List` and then increment/decrement this iterator to where you want.||0
lagwdqxqkkm5ec|Iterator == and != operators|I'm not sure how to get the iterator operators to work with both const Iterators and normal iterators. I think that my operator declarations are fine because I used the same ones as shown in lecture.. Screen_Shot_2022-11-14_at_9.42.37_AM.png|80|0|active|The signature should be. ```cpp. bool operator==(const Iterator & rhs) const {. 	// code here. }. ```||0
lagcyyfumzg4s8|how do i erase last element|"im currently trying an iterator that points to ""past the end"" with end() and then doing  --on  that iterator it doesn't work because my assert(node_ptr) in my operator-- function fails."|7|0|private|Think about using the other Iterator constructor to create an Iterator that points to the last element!||0
lagctu43u0d3dc|Compiler error on unit test framework|resolved |68|0|active|resolved||0
lagbt2wyc3ohi|compiler errors about size in List|I keep getting compiler errors on size. I declared int size; as a private member variable in List class. . . |96|0|active|@3507||0
lag8ziajuj75ec|how do i call operator-- in my tests?||88|0|active|You must first create an iterator using list.begin() then you can call -- on the iterator object,||1
lag7spbbj4w2f9|how do i declare iterator in my tests||57|0|active|You can declare an iterator by calling list.begin(). The type is List<type>::iterator.||0
lag5txzop9b6ik|why am i getting this error in my insert function and erase function?||123|0|active|node_ptr is a private member variable in the Iterator class, so the List class cannot access it. How can you use a friend declaration to allow List to access Iterator's private variables? ||0
lag4fs2bpuf42w|Penalized for Code that isn&#39;t being Used|"I created a member function to help an assert statement, but didn't end up using it because I realized I didn't need to use it and thought it could cause a potential error. I deleted all references of it, but forgot the function declaration itself. Turns out, it had an error in the form of a reference to a non-static member function that wasn't called. As a result, I don't even qualify for style checks(""please be aware that these errors will prevent OCLint from analyzing this source code""), and instantly lose 12 points, even though my code compiles and passes everything else, and would most likely pass those style checks.. . I take full responsibility for not deleting it in the first place and waiting till the last hour to do so; completely my fault for not planning accordingly. But it makes no sense to completely disqualify someone from earning style points on the basis of ""Compiler Errors"" (even though it literally passed the compile check in both style and list sections), just because they forgot to delete a function that isn't used. I understand I'm one of almost 1000 students taking this course, and this probably will just be ignored and not go anywhere, but is there anyway to get points back, or at least change that from happening in the future?"|171|2|active|Unfortunately in a class of over 1000 students, we have to maintain our policy to of no more extra submits or changes after the project deadline. This ensures that we are being fair to everyone. In terms of this happening again in the future, the best way is starting a bit earlier so you can catch these small mistakes on earlier submits.. . . . . . We do take the highest submit to the autograder so if you have a previous submit that is higher than this one, that will be your final score.. . . . . ||0
lag3rek78li3td|Deadline auto extend|Does the 8PM deadline automatically extend to midnight for projects similar to previous classes? I had a wifi outage occur and did not notice until after I had finished a final submission and was not able to submit.|139|0|active|Marking as resolved||0
lag3i6hfqfu2ff|I&#39;m assumin I ain&#39;t gonna be able to get this changed|"Alright so I did a last minute change and forgot I removed a const somewhere, so that one messed up word destroyed the entirety of my compiling of List.h. I'm just making sure because I couldn't see it anywhere, but my highest graded autograder submission is what gets graded, right? If not, is there a way I can either get that one ""const"" added in in line 161 before the word ""Iterator"", or just ask that the second to last submit be the graded one?"|6|0|private|Unfortunately you may not submit past the project deadline, but your highest graded autograder submission (after private tests are run) is what will be used for your final project grade.||0
lag351keju826a|Submit to autograder after deadline|Can I still submit code for P4 to the Autograder after 8PM today? Will the Autograder give me feeback? I know there is a bug in my code but I didn't have enough time within the deadline to figure out what went wrong or how to fix it, but I still want to know if I'm able to fix it.|138|0|active|The Autograder stops allowing submissions after 8, unfortunately.. . However, if you want some feedback, you can go to the proffice hour or send your code to a professor of EECS 280. They will be able to take a look and help you with that.||0
lag2qtx3wna3dp|Autograder said I didn&#39;t submit any test cases.|I not only submitted my test case file, I also resolved my memory leak issues. Furthermore, Autograder also ran my test cases in a different section to see if I had any memory leaks, and I did not. . . My uniquename is: elissali|6|0|private|The test cases you submitted did not compile because you used the copy_all function which is a private member of the list class. Because your test cases could not compile, they could not be run and scored. Unfortunately in a class of over 1000 people, we have to maintain a fair policy to everyone so no exceptions can be made for rerunning your test cases for that submit. However, the autograder will take your highest score, so if one of your previous submits ran correctly with the tests then that will be your final score.||0
lag2gslvjeizq|code duplication|on my last submit to autograder, i got points off for code duplication, but the two test cases are slightly different. I used a similar method for a lot of my tests and it never said anything before. |6|0|private|The computer has special, specific guidelines as to what to deduct code duplication points for. Even slightly different code can be too similar, thus it is declared as duplicates. To ensure a set policy across this class of over 1000 students, there is no exceptions or changes to this grading.||0
lag1zf3z8133dm|autograder issue|i accidentally inserted in extra bracket that made my code not compile right before i submitted. I was nervous and did it by accident-that was my last submit and i failed everything. Is there a way i can have another submit? It was an accident and I know there is probably nothing you can do, but i worked really hard to finish it, and I feel that i deserve to be graded without the extra bracket that caused my code to not compile. Sorry about this. Thanks. . EDIT: It was a delete key at the end not a bracket. I was testing something and forgot to delete it. This will bring my score down a ton- If i remembered to delete it I would have gotten a 45/49 rather than a 17. It's a silly mistake and I'm really sorry in advance for doing this. If there's anything you can do, I appreciate it. If not, I understand.|6|0|private|Unfortunately in a class of over 1000 students, we have to maintain our policy to of no more extra submits or changes after the project deadline. This ensures that we are being fair to everyone. However, we do take the highest submit to the autograder so if you have a previous submit that is higher than this one, that will be your final score.||0
lag1sidt1df770|Implementing operator == and !=|So autograde gave me this. When using the operator function from lecture notes, do we exclude rhs in this implementation?. . ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkt04r5j3l2i2t6%2F5f4476d24ab810351c3e27e627f72767e75a537071deec80be41e2f12f0c634a%2Fimage.png)|108|0|active|You are trying to return a bool& in the operator overloads, which is a reference to a bool, and it looks like autograder doesn't like that. This error should disappear if you change the return type to a regular old bool.. . Edit: Conceptually, returning a `bool&` is like returning a pointer to a local variable. The reference refers to a memory location that is invalidated (by the function returning and thus its stack frame being deallocated) right before the caller gets to use it, so the reference would always point to a location that's been deallocated and inaccessible to your program.||1
lag1fwdao1u5ca|How to call Assert to compare nullptr and output for test cases?||84|0|active|```cpp. ASSERT_EQUAL(nullptr, output). ```. . Not sure what exactly you are asking here but there it is in the most literal form. `ASSERT_EQUAL()` is what we use in the unit tests to debug since it gives you more information about failed assertions.||0
lag1ckt85o0so|Segmentation Fault|After testing. I found that this->first = p caused the error. If I annotated that line out, the rest won't produce any errors. So . this->first = p causes the error. but this->last = p doesn't. I don't know why.. |15|0|private|Marking as resolved||0
lag13f63s5wm1|Autograder Question|My partner and I were finishing up the project today, and we came across a style error that seems weird and we just wanted to ask you about it. The autograder is saying that our code is being duplicated in tests when we are pushing back to a list and asserting that it did that correctly, but doing that multiple times within the same test. Is there any chance we could get the 3 points for that back? We were both very confused about it and tried to fix it multiple times before our final submission. Those were the only 3 points that we are missing. . . Thanks so much for everything that you do!|5|0|private|Unfortunately in a class of over 1000 students, we have to maintain our policy to of no more extra submits or changes after the project deadline. This ensures that we are being fair to everyone.||0
lag0xskzazx6ze|Failing List Private templating test, not sure what to do.||71|0|active|Marking as resolved.||0
lag0jtws7n33jn|test cases passing locally but not on autograder|My tests are passing locally but arent passing on autograder and i am not sure why. Please help me, I don't know how to fix it. I am stressed.|5|0|private|You might have memory errors/undefined behavior in your implementation. Try re-running your tests locally with the address sanitizer enabled to see if you catch any errors.||1
lag0i11xm6f4dr|Memory Leak|I know this is a common problem so it is probably exhausting seeing it again. However I have spent a rather unreasonable amount of time trying to figure out the problem whether it be with the visual debugger or submitting to autograder. Any help would be much appreciated I know its close to the deadline so no worries if I can't get any.. . |5|0|private|I changed my pop_back and pop_front to resemble this (obviously alternating the necessary variables). Does this look reasonable?||0
lag0hwgb7op6sp|Compile check error|Hi, I'm not sure what this error in compile check means, and my code is no longer compiling. This is the provided code from the compile check|98|0|active|Have you written and implemented the equality operators yet? I.e. `operator==` and `operator!=` in the `Iterator` class?||0
lag0e8toal562v|iterator delete|if i initialize a new iterator in a function, do i have to delete it if it goes out of scope?|67|0|active|If you don't make an object on the heap, the runtime will automatically delete what you make when it goes out of scope, so no, you won't have to manually delete anything.||0
lag0dwrp4br1yq|No test cases were submitted.|We have 20 test cases, and tried all the solutions from @3627. We don't know what to do from here. It started with our insert one, but we don't know how else to fix it.|5|0|private|Double-check your test_begin() and test_end(): Do you have unused variables?||1
lag08mvj2d3738|no tests cases were submitted|. CXXFLAGS ?= --std=c++11 -Wall -Werror -pedantic -g -Wno-sign-compare -Wno-comment -fsanitize=address -fsanitize=undefined. ^my cxx flags. . I have been scrounging around Piazza looking for answers as to why it states: no tests cases were submitted. As on my laptop, all of our test cases are passing and we are getting points for everything else. . From my understanding of the piazza posts and the answers responded from Aman Khalid, it seems that somewhere in our List_tests we are breaking the autogravder's interface for list.h. Is there some way for me and my partner to find out where this issue is coming from? |4|0|private|It looks like you added an operator==() implementation for List, but this wasn't included in the initial public interface we gave you List.h.starter. Since the autograder's List.h doesn't contain an operator==() for Lists, your tests are failing to compile when using == to compare Lists. Perhaps there's another way you can compare Lists without implementing operator==?||1
lag00azniey6lf|*node_ptr not declaring|"For some reason, the line in my code declaring *node_ptr isn't working, and doesn't even get color-coded as code normally should. Because of this, I'm getting the following ""use of undeclared identifier"" error when trying to compile my code. Any idea why this could be? I included the ""friend class List"" line where told.. . . . . . "|60|0|active|im getting that too with just the assert statements and i have the parenthesis. Are your assert statements colored?||1
lafzzebhp669o|Memory Leak on tests|My code here says that I have a memory leak even though i have no errors and Address sanitizer detects no memory leaks. |73|1|active|It looks like you are allocating memory in push_front and push_back that you never end up deleting. Look at your code and see if you're creating any dangling pointers.. . Also, can you please update your Piazza display name to include your uniqname (@6)? This will help us look at your autograder submission quickly.||0
lafzykf7orx2i2|Erase Function|For the erase function, is all we're supposed to do just change the pointers to point to the correct nodes and then delete the node that's being pointed to?. Do we have to somehow delete the datum|61|0|active|"The datum is only ""deletable"" if it's a pointer, and the datum is not necessarily a pointer, and there's no way of knowing if it is. So no, you don't have to delete any datum within List.h itself."||0
lafzvk2prqa47n|error on size function|What does this error for the size function mean?. . List.h:52:24: runtime error: load of misaligned address 0x62696c2f7273752f for type 'List<int>::Node *', which requires 8 byte alignment0x62696c2f7273752f: note: pointer points here<memory cannot be printed>|65|0|active|It means you are trying to dereference a pointer that is in the middle of an object or in the wrong place - you are likely using a pointer to an object that has long since been deleted, never intialized, or your pointer got separated from the actual object (via iterator invalidation)||0
lafzukktfdw7dm|Is a friend declaration public or private?|P4 has the friend declaration in the private section so im confused |41|0|active|"The location of the friend specifier is ultimately not too important - it can appear in public or private, and it'll work just the same. (friend is treated specially by the compiler as it's not really a ""part"" of the class - moreso is a way of saying ""hey, I'm okay with this accessing my private data."")"||0
lafzuiyb7yxwt|pop_back trouble|I'm still having trouble understanding why my pop_back function is seg faulting when pop_front gave no issues and both are implemented the same way, even manually setting last->next to nullptr didn't do anything.|6|0|private|Marking as resolved||0
lafzqckjt701eq|assert(node_ptr) fails in the != operator overload function|Why could this be? This assert statement passes in all of the other overloaded operator functions, what's the difference here? Do I need to include it or do something special?|46|0|active|It seems like you're going into the != operator overload function with a nullptr if that assert statement is failing.. . Does it really violate anything if the function is passed a nullptr? Do you really need to assert that it isn't a nullptr?||0
lafzomf9c5j77h|Erase and size change|How am I supposed to update the size of the list (consider I made a separate private field for the list to keep track of the size) after deleting an element by using iterator?|57|0|active|After you erase an element, how should the size change? If you have a private member variable, and Iterator has access to List's private members, you should be able to just update the size variable in List<T>::Iterator::erase().||0
lafzjxgupab2q6|copy_all tests|We're testing the copy constructor and we're asserting that the first front values from the two lists we made are equal. But the copied value keeps changing to a garbage value. Has anyone else run into this problem?. . . |126|0|active|You are most likely not updating your front pointer properly, and you're referencing junk data through an invalid pointer pointing to memory that you did not allocate (or did allocate and have since deleted).||0
lafz5wpcpi92gq|erase error|When I test erase for a list (1,2,3,4), I correctly delete 2 and change the pointers for 1 and 3. So the new list should be (1,3,4).. However for some reason, the datum for 1->next is 2 and not 3 so it's failing my test. Any ideas??|47|0|active|Run your test with a debugger and set a breakpoint where you erase 2. Step into your erase function to see how you are actually modifying 1's pointers, and see how it's different from what you *should* be doing.||0
lafywj57jjg2z0|can we add private member variables to List?|I was thinking about adding a size private variable to keep track of the size of the list |59|0|active|You may add new member variables/functions to List, so long as they aren't part of the List's public interface. For example, if you add a new public member and then use it in your tests, your tests will fail to compile on the autograder, as we compile your tests against our solution for List.h.. . So long as you only use your additional member variables/functions internally in List.h, you'll be fine!||0
lafymd42tjj6da|Failing List Private Tests Compile Check|I realized I messed up the dereference and was putting out a node * instead of the type T, as well I forgot to implement the copy all functions. before I fixed those problems everything compiled and worked on my end. I am wondering if those two problems would be what is causing me to fail the List Private Tests Compile Check or is there something else causing it. I only have one more submit on autograder and don't want to waste it if those problems weren't causing it. . unique name Jkhawks|82|0|active|Marking as resolved||0
lafyl15n1253f2|fixed||37|0|active|Marking resolved.||0
lafykzt5rjm4lw|Test Cases not catching errors|I've run into an issue where my test cases won't throw errors or deliver any text output via cout. For example, I create a vector, fill it with 3 elements, and then assert that it's empty, or that the size is 200, and so long as it compiles neither case would throw an error. Is this an issue with the test suite or am I missing something?. . |140|0|active|Since you're sharing code, I've made your post private. Can you step through this test with your debugger to manually check the condition (empty_list.size() == 0)? If that condition is false, can you try stepping into the ASSERT_TRUE() call to see if you can get it to stop the program? ||1
lafyc5a4fb52m2|no test cases submitted|"Hi,. We have successfully compiled on our computer, but when we submitted to autograder, it said ""no test cases submitted"". What should we do?"|4|0|private|"The autograder compiles your tests against its own List.h solution, so if you add any functions to your public interface and use them in your tests, the tests won't compile on the autograder. It looks like you added an operator== implementation for Lists, but this wasn't included in the initial List specification we gave you, so using ""=="" to compare Lists in your tests will cause compilation errors."||1
lafy0dbl6eah9|*fixed* solved|. . Sometimes they work, other times they do not. Any advice? Particularly when the iterator is pointing to anything that's NOT the first or last node, it doesn't seem to work, due to prevv somehow becoming uninitialized. For example, if the iterator was pointing to the 3, in (1;3;5;), somehow prevv points to a null ptr.. . username: brshin (it is on my autograder as well)|4|0|private|Marking resolved.||0
lafxym64n1t6sq|&#34;No test cases submitted error&#34; but no issue caught by address sanitizer, compile check, etc|"The autograder is giving me the ""no test cases submitted"" error and I tried looking for a solution to fix this (e.g. making sure I'm using the address sanitizer, making sure that the compile check works, and manually using g++ -Wall -Werror -pedantic -g --std=c++11 List_tests.cpp -o List_tests.exe to compile) but nothing is catching the issue and I continue to get the ""no test cases submitted"" error.. . I notice there is some kind of a memory leak, but I'm not sure where to look for this because the address sanitizer is not showing me anything. . . Thank you for your help!"|4|0|private|It looks like you're trying to compare an Iterator with nullptr in one of your assert statements. Are iterators the exact same type as pointers? Is there another way you can check if an iterator is not dereferenceable (perhaps there's a function you've written that returns such an iterator)?||1
lafxwuv81xa6g|No Test Cases were Submitted after adding More Tests|. We were able to submit and get some test cases in, but after adding more it stopped recognizing them completely. I have followed the previous piazza posts but nothing has come up.Uniqname: kaihsieh. |3|0|private|I ran clean but it still gave the same result. p is a pointer to a list, which is dereferenced to pass into copy_all. I do not see the error here.||1
lafxmg9jfym31q|I am getting the No Test Cases error in the autograder while my code compiles on CAEN|I went through this post and still did not get any errors on my local machine or on CAEN, I don't believe I am calling any functions that are not called in List_compile_check so I am not sure why the autograder is rejecting my test cases. Thank you! uniquename: hagenc |3|0|private|"Could you try running ""make clean"" and then rerunning that compilation command, please? -Werror really should catch this issue.. . It full_compile_check(), you initialize iter_check to my_list.end(), but then you never use the variable. If you don't intend on using it, could you just call end() without saving its result?"||1
lafxgqwlrbd2i8|Autograder saying no test cases submit|Hi I submit my files to the autograder where it showed my test cases caught 9 out of 21 bugs but after I went back and added more test cases autograder is now saying no test cases were submitted. both my List.H and List_tests.cpp files compile and all I did was add more test cases, why would it now say that I submitted no test cases when there are multiple in the file. Could it have anything to do with that I forgot to delete iterators and the test file failed the memory check test. unique name is Jkhawks. |7|1|private|It looks like your iterator_Test() dereferences an iterator, and tries to compare that result with nullptr. This is a type mismatch, because operator* should return a value with the type the List holds (in this case, an integer). Is there another way to check if an Iterator is pointing to a nullptr?||0
lafxfvva4x51r0|Error running tests|Receiving this error when running our tests, not sure as to why I am receiving it and how I can fix it. . . . |4|0|private|On line 143 of List_tests.cpp, you compare a call to List::end() with an integer, but end() returns an Iterator. Perhaps you meant to call another function?||0
lafx9p5i1lw62c|Student list tests on student list not passing|I'm not sure what the error is. When I run my tests on my own computer they are passing but they aren't on autograder. I'm losing 3 points because of this but I'm not sure what/where the error is. There's a mention of address sanitizer on the error but I'm not sure what it means. Please help me out|4|0|private|I would re-run your tests locally with the address sanitizer enabled (here's how to set it up). This will reveal any memory errors/undefined behavior your code has.. . On line 33 of List.h, it looks like you're dereferencing a null pointer. This was caused when running test_assign_opt().||1
lafwdq6bw7c3n|Test case for list.erase() giving false positive?|I have a test case for the iterator class's erase function. This test case is for the empty() function acting on an empty list, and the assert statement is asserting that the list is empty using list.empty(). . Autograder is reporting this as a false positive, which I do not understand. With any implementation of the erase function, an empty list should still assert true when calling ASSERT_TRUE(list.empty()), right?|3|0|private|"I would double-check the REQUIRES clause of the erase() function: The iterator passed in must be a ""valid,. . dereferenceable"" iterator associated with the list. If you call begin() on an empty list, what Node should the iterator be pointing to? And is this iterator dereferenceable?. "||1
lafw4p9mjrq3a2|No Test Cases were submitted : One Solution|"I found out that running the lines:. . g++ -Wall -Werror -pedantic -g --std=c++11 List_tests.cpp -o List_tests.exe. . g++ -Wall -Werror -pedantic -g --std=c++11 -Wno-sign-compare -Wno-comment -fsanitize=address -fsanitize=undefined List_tests.cpp -o List_tests.exe. . Will help show more errors in your code than just running the make file.. I found out my error was from using the compile_check as a test case and there were unused variables that weren't shown just using the make file and that was causing the ""No test cases were submitted"". Goodluck everyone. "|125|3|active|||2
lafw31r7nqk289|Insert segv error|Me and my partner have been trying to figure out insert for a while now and dont know why were getting a segv error. This is our code for insert. |4|0|private|"If you run your code with the address sanitizer enabled, on which line does the seg fault occur? I'm guessing it's on ""i.node_ptr->prev = new_node;"". . I think you need to tweak your else if condition: insert() should try to put the new node before the node the iterator is pointing to, so your else-if condition is calling push_back() if the iterator points to the last node, when we are meant to put the new node before last in such a case. However, you are correct in thinking there is a situation when we should call push_back(); what should the iterator be pointing to in such a case? If you fix this issue, I think your seg fault in the else condition will go away."||0
lafvy298p7i77i|operator* when passed a null Iterator|For the UB checks for the student tests, I am getting an error with my copy test, where since I use dereferenced pointers, if it is passed a nullpointer, it asserts false and kills the file. Should I make it so that the *iterator returns an unusual number instead? How should the * operator respond to a null iterator? My uniquename is breia, if that's needed.|140|0|active|The REQUIRES clause of the `operator*` function _would state_* that the Iterator points to a valid Node, so calling it on a nullptr Iterator would result in undefined behavior, meaning you don't need to handle that case. It is always the callers' responsibility to ensure that the REQUIRES clause of the callee (operator*) is met.. . Your problem appears more subtle than calling operator* on a nullptr Iterator. Inspecting `listB` in your copy test with a visual debugger right before the test ends can help you discover why `pop_front` is dereferencing a null pointer with `first->prev`.||1
lafv28uuflm3ew|clear function and erase test not passing in autograder|. void List<T>::clear() {. for(Node *node_ptr = first; node_ptr != nullptr; node_ptr = node_ptr -> next) {. pop_front();. }. first = nullptr;. last = nullptr;. }. . . . . TEST(test_clear) {. List<int> list;. list.push_back(1);. list.push_back(2);. list.push_back(3);. list.clear();. ASSERT_TRUE(list.empty());. ASSERT_EQUAL(list.size(), 0);. }. . . . . . TEST(test_iterator_erase_back) {. List<int> list;. list.push_back(1);. list.push_back(2);. list.push_back(3);. List<int>::Iterator i = list.begin();. ++++i;. list.erase(i);. ASSERT_EQUAL(list.front(), 1);. ASSERT_EQUAL(list.back(), 2);. ASSERT_EQUAL(list.size(), 2);. }. . . All of my tests in my compiler are passing when I try to run it on my own computer, but both of them are failing in autograder. I am not sure why and was wondering how i would be able to fix this.|4|0|private|The autograder found some undefined behavior while running your test_clear() -- this undefined behavior may be responsible for why your test_iterator_erase_back() passes locally, but fails on an assert(!empty()) on the autograder. I recommend you re-compile and re-run all of your tests locally with the address sanitizer enabled, and fix any memory errors it finds before re-submitting.||0
laful7k49g43sw|When compiling my code on CAEN I get this error|Not sure where I am going wrong and looking for some pointers thank you!|52|2|active|Remove the sanitizers from your MAKE file. They do not work on CAEN.||0
lafuds7h2fk3sf|nonconst lvalue to rvalue|"I keep getting the following error:. List.h:299:14: error: cannot bind non-const lvalue reference of type ‘List<int>::Iterator&’ to an rvalue of type ‘List<int>::Iterator’  299 |     Iterator i=l.begin();. and I was wondering if anyone had any ideas on how to debug it?"|59|1|active|Marking as resolved||0
lafucz8g4n365d|Destructor Memory Leak after insert(end(),..)|fixed this, please answer @3560 instead|3|0|private|Marking as resolved.||0
lafubnmznt15ky|New to using ASAN. How do I interpret this error message?|. List 198 is referring to my back() member function, which is only one line long|68|0|active|"The ""SEGV on unknown address 0x0"" means you tried to dereference a null pointer. This occurred in your test_pop_back() on line 67 of List_tests.cpp. I would re-run your tests under the debugger with a breakpoint set at the beginning of test_pop_back(), so you can see what exactly is null at that point.. . The errors above it referencing memory addresses like ""0xbebe..."" are caused by you using an uninitialized pointer (this is different from a null pointer!). The below error is equivalent:. . int x; cout << x << endl; // what should print here? We don't know!. . Every time you create a new Node, make sure you initialize both its next and prev pointers to some value; if you don't you'll get the above error when you try to use an uninitialized pointer."||0
lafu4vgpwk13ax|Autograder says &#34;no test cases submitted&#34;|we submitted all of our test cases, and even despite passing the student tests on student lists it doesn't register our tests. How do we fix this with certainty? we only have 1 more submit.|4|0|private|"Your Lists_tests.cpp failed to compile due to an error on line 4: You call the function ""getNode(),"" but the Iterator class doesn't have such a member function. Once you've addressed this, I would make sure to re-compile and re-run your Lists tests locally before submitting to make sure there aren't any other compiler/runtime errors."||1
laftykl5gm92tg|Decrement operator|Our decrement operator seems to not be working correctly.. This is the test we have written, but when I step through it, it seems as though calling the decrement operator on iter1 causes it to be looking at nothing. This is what it shows right before I return from the operator function:. . So then I can't call the dereference operator on it. I'm confused why this is happening since we are not supposed to modify the decrement operator function. Any help would be appreciated. Thanks!|3|0|private|Is it possible you aren't setting the prev pointer of Node correctly somewhere in your implementation? I would double-check all of your functions that modify the List (push, pop, insert, erase) handle the prev pointer correctly. It seems like the prev pointer of the last Node in your List was nullptr, when it should've been pointing to the Node containing 8.||1
laftv5p05zx1gb|List tests not submitted??|"Our autograder says ""no test cases submitted"", even though it passes the student list tests on student tests. We have no idea how to fix this. It also passes the compile check and our own tests in the compiler perfectly."|87|6|active|Check @3627 (and its followups) for possible solutions to this.||1
laftn97qmpg3sa|Autograder telling us that there is no test cases submitted|We do not seem to have any extra functions, we are not using namespace std, and the test compiles on our systems. The compile check works, and we use ++iter as opposed to iter++. Any ideas??|56|6|private|What is your uniqname?||0
laft98w6dfa3ox|bad_access error for insert|Hi, I'm trying to figure out insert and I get this error. I want to set a temp node pointer to point to the prev of i.node_ptr so that I can set the new_node prev to this temp node. Any help would be greatly appreciated!. . |3|0|private|Could you re-run this test with the address sanitizer enabled, and see what error it gives you? It's possible you aren't initializing the prev pointer to a legitimate address when creating a new Node.||0
laft3nriw9l61u|test error|when i push_front and push_back in the same test i get a segmentation fault 11 error. Any ideas what may be wrong. they work separately but not together.  |86|0|active|nvm i fixed it. ||0
lafsuvuczt26wv|Calling copy constructor|"Hi, my copy constructor isn't getting called properly; the current syntax I have is ""List<int> copied(ref);"". Thank you!"|38|0|private|That syntax should be the correct way to create a copied list with a constructor. Try looking at your copy constructor and see if it is missing anything. ||1
lafrdg8ylb51ab|Inperson office hour|What time the the in-person office hour held today?! |88|0|active|Its on the website:||0
lafr24vs43n4z7|Insert() and Erase() on an the end iterator|Hello! I was curious about what to do with insert() and erase() with params of end iterator. I created this and made it work, but when submitting test cases to the autograded, I got a 'false positive' in these tests : ie, its raising errors when it shouldnt be raising errors, which means that the correct implementation doesn't implement these. Just to confirm, erase() on iterator end is the same as pop_back(), and insert() on end iterator is the same as push_back(). DO we even need to implement this? will i get points off if i do?|196|0|active|`insert()` on the end iterator is the same as `push_back()`. You shouldn't be able to call `erase()` on the end iterator, per the RME.||2
lafqwxmwmzh6jr|destroy iterators|"in lecture, the professors stated that we don't have to write custom implementations for the big three for the iterator class. I understand how to create iterators without using ""new"" but how do we destroy iterators then?"|164|0|active|You shouldn't have to make any destructor for the `Itareator` class (like the profs said). If you aren't making anything using `new` (not putting anything on the heap), then you won't have to do anything special to delete the object. The computer will handle everything for you here.||0
lafqpi04m8d9q|Default Constructor Tests|How do we test the default constructor? Do we just create an iterator to point to each element to see if the list was initialized correctly? How do we test the iterator default constructor?|120|0|active|Yep, the simplest way to check if a List was made correctly would be to traverse the list and check each value manually. For the `Itearator` default constructor, you can compare it to other iterators that should be at the same spot (`end()`, for example).||0
lafpzsdesgk2yu|dtor test|How did you guys test the dtor?  I made a new list, push backed 2 values, called ~List on it then checked if the size was 0 but the autograder said I got a false positive. |187|0|active|See @3372 and @3372_f1 - you shouldn't call the destructor explicitly and your runtime should let you know if something went wrong in deleting it.||0
lafpyu8itvm3u7|Office Hours|Does anyone know where the in-person office hours are today?|53|0|active|1230 USB||0
lafpsdg3eiv30x|testcases|For testcases, is it necessary to test different data types as the generic type in the list? Or one type is good enough, like int?|167|0|active|It's generally a good idea primarily to make sure that your own lists can hold elements of any type.||0
lafpqx452jm3fu|Seg fault|Me and my partner keep getting a seg fault error in our pop_front function. Could someone explain how to fix it? Thanks. |3|0|private|If you re-run this with the address sanitizer, what errors do you get? It looks like first->next is pointing to some invalid memory, and then trying to dereference that invalid memory (with hold_node->prev) is causing issues.. . In your logic for push_front(), if the List's size is only 1 before adding the new node, what is the value of hold_node? Can you access its prev Node in this case?||0
lafpmxfmy5b2mg|Iterator big 3|I noticed in the autograder there's a private test for the iterator big 3. If I wrote code that doesn't require the big 3 for the iterator, does that mean I'd fail that since it's expecting to see the big 3, or would that check accept my choice? Or... did I do something wrong and I'm supposed to have to big three (uh oh)|180|0|active|The presence of that test should not imply that you need to customize the big three for Iterator.||0
lafpmob884f7ht|List Private Templating Test won&#39;t compile|I have read all posts about the List Private Templating Test (ex. @3444 and @3555), but still can't figure out why the List Private Templating Test won't compile. I have compared my dereference operator to the dereference operator on the slides and don't see anything wrong. I also have doubled my tests, one set for List<int> and one set for List<string>.  Could anything else be causing this error? uniqname: lbues|126|1|active|The only attributes you can assume about `T` are that it has a no-argument constructor (`T::T()`) and is not abstract. You cannot assume that `T` has overloaded `operator==`. One way to verify this is to make your own class and create lists of instances of that class.||0
lafplo88sr931u|Memory leaks and grading|If I can't resolve memory leaks, but otherwise my code functions perfectly, do I just get the two points off from UB/Leak checks, or do I also fail private test cases?  Public test cases work fine if you ignore the memory leaks.  . . EDIT: Public leak checks fail on CAEN but *work* on autograder, my tests result in leaks?. . =================================================================3==84==ERROR: LeakSanitizer: detected memory leaks45Direct leak of 24 byte(s) in 1 object(s) allocated from:6#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)7#1 0x417f5e in List<int>::push_back(int const&) /home/autograder/working_dir/List.h:678#2 0x40919c in empty_list /home/autograder/working_dir/List_tests.cpp:149#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:42010#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:50911#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:21812#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)1314Direct leak of 24 byte(s) in 1 object(s) allocated from:15#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)16#1 0x418716 in List<int>::push_front(int const&) /home/autograder/working_dir/List.h:4717#2 0x40a514 in push_pop_front /home/autograder/working_dir/List_tests.cpp:7418#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:42019#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:50920#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:21821#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)2223Direct leak of 24 byte(s) in 1 object(s) allocated from:24#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)25#1 0x418716 in List<int>::push_front(int const&) /home/autograder/working_dir/List.h:4726#2 0x40aff6 in clear /home/autograder/working_dir/List_tests.cpp:11127#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:42028#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:50929#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:21830#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)3132Direct leak of 24 byte(s) in 1 object(s) allocated from:33#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)34#1 0x418716 in List<int>::push_front(int const&) /home/autograder/working_dir/List.h:4735#2 0x409684 in empty_list_reverse /home/autograder/working_dir/List_tests.cpp:3236#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:42037#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:50938#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:21839#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)4041Direct leak of 24 byte(s) in 1 object(s) allocated from:42#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)43#1 0x417f5e in List<int>::push_back(int const&) /home/autograder/working_dir/List.h:6744#2 0x40a98d in push_pop_back /home/autograder/working_dir/List_tests.cpp:9145#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:42046#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:50947#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:21848#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)4950Direct leak of 24 byte(s) in 1 object(s) allocated from:51#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)52#1 0x418716 in List<int>::push_front(int const&) /home/autograder/working_dir/List.h:4753#2 0x419c69 in List<int>::insert(List<int>::Iterator, int const&) /home/autograder/working_dir/List.h:32754#3 0x40bd71 in insert_erase /home/autograder/working_dir/List_tests.cpp:15155#4 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:42056#5 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:50957#6 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:21858#7 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)5960Direct leak of 24 byte(s) in 1 object(s) allocated from:61#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)62#1 0x419c78 in List<int>::insert(List<int>::Iterator, int const&) /home/autograder/working_dir/List.h:33063#2 0x40bc72 in insert_erase /home/autograder/working_dir/List_tests.cpp:14864#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:42065#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:50966#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:21867#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)6869Indirect leak of 24 byte(s) in 1 object(s) allocated from:70#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)71#1 0x417f5e in List<int>::push_back(int const&) /home/autograder/working_dir/List.h:6772#2 0x40a8bb in push_pop_back /home/autograder/working_dir/List_tests.cpp:8873#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:42074#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:50975#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:21876#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)7778Indirect leak of 24 byte(s) in 1 object(s) allocated from:79#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)80#1 0x418716 in List<int>::push_front(int const&) /home/autograder/working_dir/List.h:4781#2 0x40a442 in push_pop_front /home/autograder/working_dir/List_tests.cpp:7182#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:42083#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:50984#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:21885#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)8687Indirect leak of 24 byte(s) in 1 object(s) allocated from:88#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)89#1 0x417f5e in List<int>::push_back(int const&) /home/autograder/working_dir/List.h:6790#2 0x4097a2 in empty_list_reverse /home/autograder/working_dir/List_tests.cpp:3591#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:42092#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:50993#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:21894#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)9596Indirect leak of 24 byte(s) in 1 object(s) allocated from:97#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)98#1 0x417f5e in List<int>::push_back(int const&) /home/autograder/working_dir/List.h:6799#2 0x419b9c in List<int>::insert(List<int>::Iterator, int const&) /home/autograder/working_dir/List.h:323100#3 0x40ba48 in insert_erase /home/autograder/working_dir/List_tests.cpp:140101#4 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:420102#5 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:509103#6 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:218104#7 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)105106Indirect leak of 24 byte(s) in 1 object(s) allocated from:107#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)108#1 0x418716 in List<int>::push_front(int const&) /home/autograder/working_dir/List.h:47109#2 0x4092ba in empty_list /home/autograder/working_dir/List_tests.cpp:17110#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:420111#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:509112#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:218113#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)114115Indirect leak of 24 byte(s) in 1 object(s) allocated from:116#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)117#1 0x417f5e in List<int>::push_back(int const&) /home/autograder/working_dir/List.h:67118#2 0x40af34 in clear /home/autograder/working_dir/List_tests.cpp:109119#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:420120#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:509121#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:218122#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)123124Indirect leak of 24 byte(s) in 1 object(s) allocated from:125#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)126#1 0x417f5e in List<int>::push_back(int const&) /home/autograder/working_dir/List.h:67127#2 0x419b9c in List<int>::insert(List<int>::Iterator, int const&) /home/autograder/working_dir/List.h:323128#3 0x40bb9d in insert_erase /home/autograder/working_dir/List_tests.cpp:144129#4 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:420130#5 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:509131#6 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:218132#7 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)133134Indirect leak of 24 byte(s) in 1 object(s) allocated from:135#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)136#1 0x418716 in List<int>::push_front(int const&) /home/autograder/working_dir/List.h:47137#2 0x40ab7d in push_pop_back /home/autograder/working_dir/List_tests.cpp:94138#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:420139#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:509140#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:218141#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)142143Indirect leak of 24 byte(s) in 1 object(s) allocated from:144#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)145#1 0x417f5e in List<int>::push_back(int const&) /home/autograder/working_dir/List.h:67146#2 0x40ae62 in clear /home/autograder/working_dir/List_tests.cpp:106147#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:420148#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:509149#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:218150#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)151152Indirect leak of 24 byte(s) in 1 object(s) allocated from:153#0 0x7f1790542532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)154#1 0x417f5e in List<int>::push_back(int const&) /home/autograder/working_dir/List.h:67155#2 0x40a5d6 in push_pop_front /home/autograder/working_dir/List_tests.cpp:76156#3 0x404872 in TestCase::run(bool) /home/autograder/working_dir/unit_test_framework.h:420157#4 0x406149 in TestSuite::run_tests(int, char**) /home/autograder/working_dir/unit_test_framework.h:509158#5 0x40d05b in main /home/autograder/working_dir/List_tests.cpp:218159#6 0x7f178ee5a82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)160161SUMMARY: AddressSanitizer: 408 byte(s) leaked in 17 allocation(s).|189|2|active|this happened to me last project and is curretly happening to me now. I dont think i got points marked off-kast project UB checks didnt take off points i dont think. I think youre fine. ||0
lafpf3paqs3k5|Testing assignment operator|When I’m testing the assignment operator,I created two empty lists, pushed elements on the first list, and copied all the elements by setting the second list equal to the first list. After that, I checked whether it properly worked by traversing each of the lists and comparing the two output. The output looks the same but after that, it gives me this error message and I’m lost where to look for. It will be greatly appreciated if anyone has an idea. |206|0|active|The error message means that you are deleting something that was already deleted. It's likely that you may have copied the Nodes shallowly, meaning that once your destructor destroys the first list's nodes, it also deleted the second list's nodes (since they were the same object)> Then, when it tries to delete the second list's nodes, it's encountering a double delete.. . If that's not the case, I would check the behavior of the destructor and if the connections you made between nodes are exactly the same (traverse back and forth).||0
lafp9ymz3fa1k1|insert|where does the iterator I point to after the insert, the new node that was just create, or the node just after the new node|124|0|active|The iterator will point to the node that was there before you did the insert. Iterators are associated with Nodes in a list, not positions in a list.||1
lafogt89q6a2h9|How to do pointer comparisons in the test suite?|I am trying to check if my begin returns a nullptr when it's used on an empty list but i'm not sure how to do that in the unit testing framework, since neither assert equals or assert true works.|162|0|active|"you can use ""end"" or a blank iterator, as both of those should have nullptrs for their node_ptr.  You can't check if an iterator is equal to a nullptr though as they are different types.  "||0
lafo725dexw5po|List tests UB/Leaks checks|Sorry for the generic title, but is there any information I can gain from this at all (besides there probably being dynamic memory I failed to clear at some point)? I don't understand a single part of the error description. (The test passes when I run it on my own code if that matters).. . . . . |96|0|active|`heap-use-after-free` refers to you trying to access an element on the heap (something made using `new`) after you deleted it. The file names under the error message tell you which lines and files this issue occurs from. If you want to test this on your own and not waste autograder attempts, you should use the [address sanitizers](https://eecs280staff.github.io/p1-stats/setup_asan.html).||0
lafo4sn4aqd5l5|erase function memory leak|my erase 1 test is giving a false positive due to a memory leak error-i debuged and made sure to delete the iterator but it didnt work. Can someome check my submission? my uniquename is mtinda.|3|0|private|my newest sumbit||1
lafo3e8rvbv4eh|Memory leaks / heap-use-after-free|"I keep ending up with memory leaks.  If I use ""=nullptr"" then I get the generic memory leak error, alway occurring in places where I specified ""new"", which makes sense, but when I delete, then I get ""heap-use-after-free"", even if I only use it in the dtor.  . . It seems to save over different Lists too, so when I delete one list, it frees the memory, and if I go and try to free another list, it claims it was already freed by the previous instance.  . . Should It not start over with a new instance each time?  I'm rather confused. "|87|2|active|I fixed it but I don't know how... ||0
lafnyklnluw2pg|do we need a copy constructor or deconstructor for iterator?||112|0|active|Nah||0
lafn959r8483gk|Creating Iterators in tests|Is using begin/end the only way to make an iterator when testing? I understand you cannot use the constructor because it is private. I made a list of size 3 and incremented list.begin() twice and it does not equal list.end().  |97|0|active|I think you can use first and last as well. Also, if it is size 3, then you need to increment list_begin() 3 times since list.end() should point one past the end of the list.||0
lafmds4vnxr241|discards qualifiers on begin() and end()|list.h wont compile, because of this error.. . List_compile_check.cpp:45:30: error: passing 'const List<int>::Iterator' as 'this' argument discards qualifiers [-fpermissive]. . b = iter3 == my_list.end();.                                         ^. . . what could I possibly doing wrong in my implementation of list.end() or list.begin() in order to break the qualifiers?|69|0|active|Did you change the signatures of some functions? This error usually occurs when you try to run a function that is specified as non-`const` inside of a `const` function.||1
lafmd8pbfxw5vi|i.node_ptr|if I remove the ith element, what should the i.node_ptr point to? Does it just become a null pointer? |109|0|active|i would become an invalid iterator, so I wouldn't worry about i after the ith element is removed. i.node_ptr would be a dangling pointer because the object node_ptr was initially pointing to become deleted through erase, pop, etc. It wouldn't automatically become a nullptr unless you set it to be one. So as long as you don't use i again, I think you should be fine.. . I hope this helps!||0
lafm5s232lo6c|Segv error|I need help with these segv errors, I think every one that is number is a segv error, but im not positive, if anyone could help it would be greatly appreciated.. . |4|0|private|It looks like you're trying to access member variables of an object referenced by a nullptr, which is invalid.. . Edit: Just checked your submission, and it looks like you figured it out.||0
lafkuroe8no6z9|assignment operator compiler error|"In liststests.cpp, I am trying to test my assignment operator. I created a List called list3 using the default constructor and I am trying to set it to another list called list2 that is previously defined using the assignment operator. . list3 = list2;. However, the compiler gives me an error ""error: assignment of function ‘List<int> list3()"". I am not sure what this error means "|91|0|active|When you are making the `l3`, don't use the parentheses to specify the default constructor - this make the compiler think that `l3` is a function that returns a `List` rather than making a `List` object and putting it in `l3`:. . ```cpp. // yes:. List l3;. // not:. List l3();. ```||0
lafktdqwvvq4dt|Comp error using-declaration of std::cout|"When I try to make List_compile_check.cpp, I am getting these two errors:. List_compile_check.cpp:8:12: error: using-declaration for non-member at class scope    8 | using std::cout;      |            ^~~~List_compile_check.cpp:9:12: error: using-declaration for non-member at class scope    9 | using std::endl;. . Does anyone know how to fix this?"|45|0|active|Marking as resolved||0
lafks4gwz532cd|Why does my insert seg fault?|I don't know why when I test the middle one, the edge case where I have to add to the end of the list, it gives me a seg fault when testing.  The other edge case at the start of the list works fine and so does when in the middle of 2 elements, just the edge case at the end of the list gives me a seg fault, any hints to why? . . I even changed it to this and it still is seg fault.|3|0|private|"Your first code snippet shows that if i.node_ptr is a nullptr then it will execute the middle code. However, within the middle code chunk you have ""i.node_ptr->prev"", which is dereferencing i.node_ptr which you already established is a nullptr. Dereferencing a nullptr will cause a seg fault. If your second code snipped it causing an issue, it could be that you're making the same mistake in your push_back function."||0
lafkisi4si82vj|Iterator Default Constructor|I was wondering whether we are supposed to implement a default constructor for the Iterator in project 4?|131|1|active|Yes, and it should make an iterator that points to the `nullptr`. From the comment at the top of the `Iterator` class:. . ```cpp. // OVERVIEW: Iterator interface to List. . // You should add in a default constructor, destructor, copy constructor,. // and overloaded assignment operator, if appropriate. If these operations. // will work correctly without defining these, you can omit them. A user. // of the class must be able to create, copy, assign, and destroy Iterators.. ```||0
lafkb2rshez73g|reference to type &#39;const List&#39; could not bind to an rvalue of type &#39;const List *&#39;|Push_front and push_back functions:. Screen_Shot_2022-11-13_at_11.10.09_AM.png. . Ctor and size tests:. Screen_Shot_2022-11-13_at_11.11.14_AM.png. . Currently running into 2 errors :. . 1. I'm not sure how to set a list to another list in order to invoke the copy constructor in my tests. I'll attach a screenshot with my current code, how I am trying to implement this, and the error that I am getting.. . 2. My size() test runs forever. I am assuming this is due to something being wrong in my push_front or push_back functions but I can't seem to figure out where I might have gone wrong. . . Any sort of advice and hints in the right direction are much appreciated! Thanks!|5|0|private|In push_front, is there a case where you have to update last, similarly to how you update first in push_back?||0
lafk96uf8w56qn|Expected behavior when erase(list.begin()) is called on an empty list?|One of my tests is causing a false positive in the Autograder, but after tracing through the test multiple times, I still cannot find the issue. I do have a question related to one of the cases that the test with the false positives looks for. When the iterator is set to list.begin() and the list is empty, what is the expected behavior when the erase function is called?|127|0|active|Per the starter file, erase requires that i is a valid, dereferenceable iterator associated with the list. This means that i can't be pointing to an empty list since it would no longer be dereferenceable. Erase isn't required to handle this ||2
lafjuamidhw7fh|Mem leak not showing up on Asan|We are failing UB/leak checks on student list test on AG. However, the memory leaks shown in the ag error are not showing up on our address sanitizers. My Xcode address sanitizer has worked for me in the past and it correctly showed a memory leak for this project as well. However, the memory leak we are getting on ag for our insert function is not being detected by the address sanitizer. Is there anything I can do to fix this?|122|4|active|Marking as resolved||0
lafje0bi4a33sj|Creating test functions with limited functions.|The way I understand it is that we want our test cases to have a minimal amount of functions being tested. There are so many ways to compare the values of our lists using functions that we are supposed to be testing as well. Would it be okay to focus and compare results of certain functions, but use other functions from our project to retrieve said data.|64|0|active|yes, most test cases will be using multiple functions within one test. It's a good idea to have each test case focus on testing one, or only a few, functionalities at a time. ||0
lafja9rncml6tw|Compilation Warnings in Autograder|. Hi we are getting this error and we don't know what it means. . . Additionally, after a list is cleared, should first and last equal nullptr? Because this never seems to happen. So I tried to make first and last equal nullptr when my size equals 0; however, my assert(i.node_ptr) in insert() results in an error when I try to insert on an empty set.|112|0|active|I got the error on the euchre project when I initialized member variables in a different order than they were declared. Make sure your initializer list goes in the order that your declarations do. . . @3852_f1 answers your second part||1
lafj03ulf0r6my|include path errors|Anyone have a clue how to solve these problems here? Thx!. |31|0|active|I redownloaded Visual Studio code and followed the mega setup again but the problem still did not get solved||0
lafhw5kpoyy132|Push Front|"Just a little confused:. I was going through my back() function and I was getting a seg fault after doing push_front for (1,2) which means that back (last) should be 1. However, I realized that my push front never actually initializes ""last"", so would I have to account for that in my push front implementation assuming the list isn't empty?"|100|0|active|Yes, you have found an edge case - `push_front` has to adjust its behavior when it pushes the only element in the list.||1
lafh82j3oap1sx|Update first from nullptr|I can't figure out how to reassign first without causing a segmentation fault in push_front. Are you supposed to be able to write Node* ptr = new Node and first = ptr when first is initially set to nullptr?Edit: Ok the segmentation fault went away when I got rid of my destructor so maybe pop_front is the problem|72|0|active|Marking as resolved.||1
lafgink77eddy|Compile Check Error|"I am able to compile and run my tests without issues but I am getting this error when I make List_compile_check.exe:. . In file included from List_compile_check.cpp:3:List.h: In instantiation of ‘void List<T>::erase(List<T>::Iterator) [with T = int]’:List_compile_check.cpp:38:23:   required from hereList.h:286:27: error: no match for call to ‘(List<int>::Iterator) ()’  286 |     Iterator begin = begin();      |                      ~~~~~^~List.h:287:23: error: no match for call to ‘(List<int>::Iterator) ()’  287 |     Iterator end = end();      |                    ~~~^~List.h:289:9: error: statement has no effect [-Werror=unused-value]  289 |     for(begin; begin != end(); ++begin){      |         ^~~~~List.h:289:28: error: no match for call to ‘(List<int>::Iterator) ()’  289 |     for(begin; begin != end(); ++begin){      |                         ~~~^~List.h:292:9: error: type ‘class List<int>::Iterator’ argument given to ‘delete’, expected pointer  292 |         delete begin;      |         ^~~~~~cc1plus: all warnings being treated as errorsmake: *** [Makefile:42: List_compile_check.exe] Error 1. I have no idea what this means, could someone guide me in the right direction?"|188|0|active|For the first 4 errors, it seems like the runtime cannot find your `Iterator` functions or class. Did you define them? Also, check if you have declared `List` as a friend class of the Iterator class. For the last error, it seems like you are trying to delete an iterator, which you can't do. You can only delete pointers.||0
lafg7p6elue694|What version of cpp is the autograder compiler using?|What version of cpp is the autograder compiler using?|42|0|active|11||0
laffke09e9248m|SEGV: Misaligned Address|We got this error in the Autograder and we believe it is caused by trying to access memory that we do not have access to. However, we have no idea what that would be and have poured a lot of time going through the debugger and can't find any issues. Does anyone have any ideas for what our problem could be and if you are an instructor could you look through our most recent autograder submission?. . |34|1|active|We figured it out||0
laffa5t3kdv52s|testing iterator erase function|. TEST(test_iterator_erase) {. List<int> list;. list.push_back(1);. list.push_back(2);. list.push_back(3);. List<int>::Iterator i = list.begin();. list.erase(i);. ASSERT_EQUAL(list.front(), 2);. ASSERT_EQUAL(list.back(), 3);. ASSERT_EQUAL(list.size(), 2);. }. . . . . void erase(Iterator i) {. //implementation currently doesn't traverse loop. if(begin() == i) {. i.node_ptr -> next -> prev = nullptr;. } else if(end() == i) {. i.node_ptr -> prev -> next = nullptr;. } else {. i.node_ptr->prev->next = i.node_ptr->next;. i.node_ptr->next->prev = i.node_ptr->prev;. }. delete i.node_ptr;. --list_size;. }. . . . This is my test for the erase iterator and the erase implementation. Whenever I run this test, it shows me a malloc error. I am not sure if it is just a faulty test case or a problem with my function itself.|4|0|private|The test case seems reasonable to me. Take a look back at the List private member variables, are you modifying all of them correctly in your erase function? I believe you're missing some in certain scenarios. ||0
lafedovtjbwgk|Insert|I thought my implementation was correct, but it’s showing me this error. I think this error occurred when implementing the element to the middle, but kind of lost what this error means. Any clue? |121|0|active|You are deleting something you already deleted (or something that was never initialized in the first place).||0
lafck5y7sz93yn|Insert|For inserting the element in the middle of the list, I’m a little confused. For instance, if i.node_ptr is pointing to the second node, we’re inserting the new node in front of that so the second node becomes the third node and we have to update the information accordingly. In that process, the prev of the new node should be pointing to the first node. So then, would that be  i.node_ptr-> prev because before inserting the element, it was the previous node of the second pointer(which i.node_ptr is pointing to)? And to update the next of the first node to the new node, we would access through that? Is this the correct way of understanding?|113|0|active|Yes, you are right in your thought process. You will have to change three nodes (the first, the one you are inserting and the second) so that their links are all coherent and logically make sense.||0
laf4fti4ngm62i|Style checks - call to non-static member function without an object argument|. I am getting this same error for every style check. The lines specifically are just calls to the clear() and copy_all() functions respectively. I checked their brackets, their headers, ect, and cannot find any reason why they are acting this way. If anyone can offer solutions to this, I would appreciate it.|65|0|active|It seems like there is a list function that you're calling without the syntax <list_object_name>.<function name>() and are just using <function name>() instead. None of the members or functions of List are static, so you need a List instance to reference any of them.. . Also, please update your Piazza display name to include your uniqname (@6). This will allow us to see your Autograder submissions quickly.||0
laf3xczfg5j2x4|Function trying to access memory that can&#39;t be printed|In the compile file, I am running and my code is trying to print out a memory address that can't be printed. I also attached the error message, the picture of my pop functions, and my fileList.h, . . . |5|0|private|List_compile_tests is only meant to tell you if your code compiles. It isn't really meant to be run.||0
laf2hxmht6s1c1|Public Tests Fail|Hi,. . I implemented empty() based on how it was given in lecture. I made it a constant function and returned the value based on whether first is a null pointer. This was my header: bool List<T>::empty() const. However, the basic public test is failing. Why is this happening? . . |55|0|active|Does your constructor actually set `first` to `nullptr`? If it doesn't then the pointer will be random memory (same with any other variable you don't explicitly give a value).||0
laf1vq6w8z16rc|Segmentation fault in push_front and push_back|I am still getting a segmentation fault when I try to reassign first and last (which are set to nullptr when List is constructed) in push_front and push_back. How can I fix this?my uniqname is brycehu|77|0|active|This seems to have been resolved in your most recent autograder submission. In general, enabling the address sanitizer helps you pinpoint the erroneous memory access and fix it.||0
laf1v0gg4hb2iv|Inconsistent memory leaks in functions with new|We ran Valgrind and found that in the functions where we create a new Node, the memory leaks aren't consistent. Sometimes, the function will not cause a memory leak. Does this mean that our destructor is broken or that we should be hard coding deletes elsewhere?|141|0|active|Are you using delete in pop_front/back, list deconstructor, and erase? That could be a source of error.||1
laeyt2hqlkr5aa|Error Message - Operator function|. I do not understand either errors, could I get a pointer on what I should be looking at? |3|0|private|`operator==` and `operator!=` should not mutate `this`, so they should be marked `const` so that you can call them on const Iterators. Here, you did not mark them `const` (hence implying that they might mutate `this`) and called them on const Iterators.||0
laexo2w1k4k1ae|memory leak in student list tests|After adding our insert function, we're getting an ag error for the memory leak/ub check for student list tests. The autograder error is below. It references push_back and one of the insert tests that I wrote. But since we were not getting this issue before adding insert, doesn't that mean that the memory leak should be in insert and not push_back? Also, weirdly, my xcode address sanitizer which is configured correctly, is not identifying any issues at all. Any help would be much appreciated!. . . . |156|1|active|answer in followup||1
laexaq811vs2r8|Tests not compiling|My tests aren't compiling (0/21) and the autograder isn't recognizing them. I checked the common Q&A section and I don't believe I'm breaking any of the rules. I'm really just lost as to why the autograder isn't recognizing my test cases. Could a staff member point me in the right direction?|3|0|private|You seem to have resolved this earlier today. The original cause was the presence of unused variables.||0
laex3xc6lwt5ak|iterator big three, copy ctor|My unique name is Chenaust, and the last version is the most updated version of our work.. I wrote a big three for the iterator, but it seems like it does not work when I ran the provided compile check. I do not know why this will be a problem... The error message goes: . List_compile_check.cpp:37:10: error: no viable overloaded '='.     iter = my_list.begin();.     ~~~~ ^ ~~~~~~~~~~~~~~~. ./List.h:170:18: note: candidate function not viable: expects an lvalue for 1st argument.       Iterator & operator=(Iterator & rhs) {.                  ^. List_compile_check.cpp:39:10: error: no viable overloaded '='.     iter = my_list.begin();.     ~~~~ ^ ~~~~~~~~~~~~~~~. ./List.h:170:18: note: candidate function not viable: expects an lvalue for 1st argument.       Iterator & operator=(Iterator & rhs) {.                  ^. List_compile_check.cpp:49:10: error: no viable overloaded '='.     iter = my_list.begin();.     ~~~~ ^ ~~~~~~~~~~~~~~~. ./List.h:170:18: note: candidate function not viable: expects an lvalue for 1st argument.       Iterator & operator=(Iterator & rhs) {.                  ^. 3 errors generated.. . And here is the screenshot: . Screen_Shot_2022-11-13_at_00.26.59.png|3|0|private|"All copy assignment operators should receive a **const** reference as their argument (with ""move assignment operators"" receiving ""T&&"" and the [""copy-and-swap idiom""](https://en.cppreference.com/w/cpp/language/operators#Assignment_operator) being exceptions outside the scope of this course). This means `rhs` must be const."||0
laex1mp2mqr4jy|Assignent operator|I am trying to test my assignment operator for the list and I am having some trouble. When I try to push it I make two distinct lists (lists1 and lists2) and assigning one to the other using list2 = list1. However, my assignment operator is not being called ever. I am cout ing something as the first line of my assignment operator just to see if it is being called. But nothing is being printed during this test and there is just a seg fault. . . I am defining it as. List &operator=(const &rhs) {. implementation . }. . but this function is never being called. Am I setting it up wrong?|104|1|active|Resolved in followup, function signature should be. ```cpp. List &operator=(const List &rhs). ```||1
laew64xdedc2jm|Custom class test|"Hello,. . I have written test cases involving int, bool, strings etc. and was trying to create a class Card and create a list of cards. However, I am running into issues when I try to do so. My test case is:. . class Card. {.     private:string rank;.     string suit;.     public:.     Card(string rank_in, string suit_in): rank(rank_in), suit(suit_in) {};. };. . TEST (my_class). {.     Card Queen_of_Hearts(""Queen"", ""Hearts"");.     Card Ten_of_Spades(""Ten"", ""Spades"");.     Card Ace_of_Diamonds(""Ace"", ""Diamonds"");.     Card Jack_of_Clubs(""Jack"", ""Clubs"");.     List <Card> pack;.     pack.push_back(Queen_of_Hearts);.     pack.push_front(Ten_of_Spades);.     pack.push_back(Ace_of_Diamonds);.     ASSERT_EQUAL(pack.front(), Queen_of_Hearts);.     ASSERT_EQUAL(pack.back(), Ace_of_Diamonds);. }. . And here is the error message. . . . Also static assertion failed for the following test case.. . . . TEST (list_of_list). {.     List <List<int>> lol;.     List <int> l1;.     l1.push_back(10);.     l1.push_back(20);.     l1.push_back(30);.     List <int> l2;.     l2.push_back(40);.     l2.push_back(50);.     l2.push_back(60);.     List <int> l3;.     l3.push_back(70);.     l3.push_back(80);.     l3.push_back(90);.     lol.push_back(l1);.     lol.push_back(l2);.     lol.push_back(l3);.     ASSERT_EQUAL(lol.front(), l1);.     ASSERT_EQUAL(lol.back(), l3);.     lol.pop_back();.     ASSERT_EQUAL(lol.front(), l1);.     ASSERT_EQUAL(lol.back(), l2);.     lol.pop_front();.     ASSERT_EQUAL(lol.front(), l1);.     ASSERT_EQUAL(lol.back(), l1);. }. . "|3|0|private|"I see two problems here:. . 1. When you use `new Node`, you call the no-argument constructor of `Node`, which default-initializes all its member variables, including the `Card` datum. For primitive, ""atomic"" types like `int`, `char`, and `double`, default-initialization does nothing, so they would hold junk values. For class types like `Card`, however, default-initialization means calling the no-argument constructor `Card::Card()`, but that doesn't exist for `Card`. The language environment requires the Card inside the `new Node` to have been constructed using a constructor, but it doesn't know how to construct the Card without a given rank and suit. You would need to declare a no-argument constructor for `Card` or remove the `List` test completely.. . 2. You seem to be calling `ASSERT_EQUAL` on two Cards. The underlying function checks if the two Cards are equal, but you never defined how Cards get compared. You would need to add an `operator==` to the class or remove the `List` test completely.. . I believe that testing `List` is generally unnecessary if you have already tested `List` and `List`. You can safely assume that any class of objects we hold in a List has a no-argument constructor."||0
laew1ftds566dd|Issues running Student tests on autograder|resolved, please look at question @3625|59|0|active|Marking as resolved.||0
laevn5ndhrg54v|Templating is still failing in autograder|Resolved.|4|0|private|Marking resolved||0
laevfydsthu1f8|Push back Memory access of null ptr|Hi I have been having trouble with my push_back function. I am getting a segmentation error and I'm pretty sure it's because when I am trying to access last->next, last is a nullptr. But I don't understand why last is a nullptr as I thought I had taken care of the case where the list is empty in the if statement above. My uniqname is jiahw. Your help would be greatly appreciated.|81|0|active|It could be that whatever you're using to check if the list is empty is incorrect, and so an empty list is failing that assertion and executing the next portion of code. Or it could be that on a non-empty list you're not setting last correctly and it's still a nullptr. You can use your debugger to determine which case it is, and then set other breakpoints to determine why it's happening. ||0
laevf80guzv17r|IMPORTANT testing error| Naming test cases in uppercase results in a seg fault. it took us a while to figure out so just wanted to throw it out there.|76|4|active|||0
laevbu5r6bn79v|List Clear Misaligned Address, Invalid Pointer|We ran our tests before submitting and everything seemed to work perfectly. Then, once we submitted it to the autograder, our clear test had problems there and we do not at all understand what the error is saying. Could anyone help interpret it?. . Screen_Shot_2022-11-12_at_11.36.37_PM.png. Screen_Shot_2022-11-12_at_11.36.21_PM.png. . We have now fixed the pointer issue, but we still have a misaligned address issue in our most recent submission.|53|3|active|Marking as resolved. Please follow up if not.||1
laev5gwt2db2tc|Help on List Private Templating Test|I have read @3444 and other past posts about how to address this issue, but nothing has worked so far (working with List> lists or List lists). This is my only issue I'm getting from the autograder. I would be interested in hearing how other people who encountered this issue resolved it, or if Instructors have any insight?|102|0|active|Take a look at the Iterator class member variables. When dereferencing an iterator you need to make sure you're specifying the member variable you want to use by using the . operator, or using -> ||2
laev394yslt58p|leak check errors|Hello, I know this a lot of stuff, but could anyone point out and address some of the potential issues in this error message? Thank you!. . |74|0|active|The first line indicates that you’re trying to access a member variable of a nullptr, which is invalid. This is happening when you call pop_front in clear, and which is called in your List destructor.||1
laev2qarnmi496|List Private Templating Test not compiling|I read @3444 and added tests that use lists of types double and string, and both passed. What else could have caused this error?. . uniqname: cindyzhg|60|0|active|Marking as resolved. Please follow up if not.||0
laeux54d84du0|Assigning last-&gt;prev for push_front() function?|Hello, I am trying to find the last bug, and I was trying to test the erase and insert function by eliminating and inserting the element somewhere the list that was created with push_front() (test names: iteratorEraseSeveralTimesPushFront and. . AiteratorInsertPushFront). . . . . Since I experienced a memory leak error when I stepped into the erase and insert function, I deduced that the last bug must come from the push_front() function since the prev Node of the last element was never updated. I Googled to find if modifying the last node is needed for the doubly linked list, but the functions don't require that. . . This made me wonder if push_front() really needs the last->prev to be modified. If it doesn't, is there a fault with my test case? If yes, do you have any advice as to how I can keep the last element unchanged every time I add a new element with push_front()?. . Here are my files for your reference: List.h and List_tests.cpp.. . Thank you very much for your time and kind help.|4|0|private|Resolved||0
laeu9ogl4rl3x|RESOLVED|Uniquename: poojaka. Hi, we just added our insert function and the student list tests UB/leak check on autograder is failing now. I'm confused if it is a problem with the test I wrote or with the actual insert function. The autograder error, insert function, and test is included below. I'm not sure if there could be an issue with push_back which the error references, but this leak only happened after adding the insert function and insert function tests. Also, on my Xcode, I have address sanitizer enabled and it doesn't show any errors. I also added the flags to my makefile and no leaks are detected at all. I would really appreciate any guidance on this. . . . . |5|0|private|Resolved||0
laeu1hi1rie5xt|Test with False Positives|. In my test cases, the autograder states that I have a false positive in my iterator tests. However, even after looking through the specification sheet and also going through my code, I have no idea what could be causing this as I am getting the results that I think are supposed to happen in my code. What could be causing my false positives here? If you could get me a lead on anything that would be much appreciated. Thank you.|5|0|private|Marking as resolved. Please follow up if not.||0
laetooz6mwn2i5|missing template arguments copy constructor|Hi, this error showed up in our test cases. What does this mean? Was the copy constructor called incorrectly? Thank you!. . |90|0|active|I think it should go along the lines of . List<int> copy(list);. where list is previously defined.||0
laetlrg21l048w|Receiving a memory leak on an insert test|. . I know i have to delete dangling pointers but im not sure how thats done in the insert function.|138|1|active|you don't need to delete dangling pointers if the pointers are allocated in the stack because they'll be automatically destructed. the leak is probably a node you didn't delete. personally i only have the new keyword in the insert function and delete in the erase function to make sure that everything i allocate in the heap gets deleted. have you written your destructor yet? the biggest thing is to make sure your destructor handles the nodes you made with the new keyword.||0
laesx0bahqj7mz|Insert iter invalidation|I know that erase invalidates the iter passed in, but it seems like insert does too? The iter passed in is passed in by value, which means we can't really change the actual iter we used to call the insert function. However, if you try to insert in an empty list using an iter initialized with list.begin, the iter is null and passed in as such. However, because the insert function can't alter the original iter, that means the original iter will still be null even though the list.begin now returns a different pointer. Is this a feature? Does this mean that iters we use to insert with automatically become meaningless after an insert? Even if the list was empty, the iter would still point to the node we wanted to insert an element before, rather than the node that is now in its position.|138|0|active|Insert should not invalidate iterators. The case you are describing with the empty list doesn't invalidate the iterator. The iterator is initially pointing at nothing (the nullptr), and after you add something it is still pointing at nothing. What you likely thought is that the iterator is pointing at the beginning of the list, which isn't true.. . Iterators are assigned to specific nodes in a list rather than positions in a list - even if you declare an iterator with `list.begin()`, the iterator is only associated with the node that *was* the beginning of the list. If you were to push something else to the front, the iterator still points to the same node, but the node is now in a different position (the second position rather than the beginning).. . An iterator being invalidated doesn't mean that it is no longer pointing to the same position in a list as it was before. It means that the node the iterator was pointing to is now deleted, or that the iterator is pointing to junk memory.||1
laesq0tfu8y20d|segmentation fault|this is from the slides-I'm not sure why its giving me a segmentation fault. I've drawn diagrams and it should work out for all cases. Any tips?|3|0|private|Have you tried running this using the debugger? What are the values of the length and last when this happens? It could be that last is set to a nullptr when it shouldn't be, which would mean you have a bug somewhere else in your code. It could also be that length should be 0 but for some reason isn't, which means you're forgetting to modify it somewhere. ||0
laesm5fyctn2h|Why does operator* return a char*?|Wouldn't it be much easier to return an int?  I'm confused on how we go from an integer to a char*.  |68|0|active|your operator* returns the datum of the node your iterator is associated with. so if your type in your list is a char it will return a char, etc.||1
laeslew5dwzfw|how to use the *operator()|So if I want to create a new node and make it the same location as where the i iterator is, how would I use the * operator?  I did something like Node * test = *i; but that doesn't work.  Would doing Node *test = i.operator*(); work?  How would I use the * correctly?|81|0|active|the operator* deferences the iterator to the datum of its relevant node.  allocate new nodes on the heap with the new keyword. all you need to do with the iterator is find the node it points to in order to rearrange the relevant pointers when you assign.||0
laesgfm8ea96d|no tests cases in auto grader?|I just submitted my project, it shows no tests cases were submitted, but it works in my terminal. and there is also code existing in the list_tests when I looked at my submitted file on autograder.|5|0|private|Marking as resolved. Please follow up if not.||1
laerm7xtuxa5p2|iterator default constructor testing|hi, how do you test the iterator default constructor?|85|0|active|You could push back elements into a list that you created and check if the list is being initialized correctly by using an iterator to check each element. ||0
laerbmzsgg6ss|erase function|. This is our code for erase when the iterator is not pointing to the first or last pointer..  . Node * victim = i.node_ptr;. i.node_ptr -> prev -> next = i.node_ptr -> next;   \\\\(line 260) \\\. i.node_ptr -> next -> prev = i.node_ptr -> prev;. delete victim;. . . But for some reason, we get these errors . List.h:260:50: runtime error: member access within null pointer of type 'List<int>::Node'SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior List.h:260:50 in List.h:260:50: runtime error: load of null pointer of type 'List<int>::Node *'SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior List.h:260:50 in . . and we have no idea why|6|0|private|Marking as resolved. Please follow up if not.||0
laer2xniif74ff|iterator -- testing|do we need to test iterator --?|81|0|active|Yes! You should test it the same way you test ++||0
laeqrrlemut1fb|Is the autograder testing exhaustive?|If we have a 49/49 on the autograder does that mean we are likely to get a 100 on the project? We currently have a test case that our code is failing but we can't tell if that is an issue with our code or the test. Without that test we're getting 49/49 on the autograder so we're not sure if we need to pursue that test or not.|201|0|active|If you submit with the test included to the autograder, it will tell you if it is a false positive (if so, there is an issue with the test). It could be that this additional test case is exposing buggy behavior in your own code, in which case you would want to fix this.. . In general, it is not guaranteed that if you have full points on the public autograder you will pass all private tests. Your own testing and looking over the spec are the best ways to gain confidence that your code will pass private tests.||0
laeqetjzwue439|How do we use &#43;&#43; in erase/insert?|I have my erase function so that it calls pop_front/pop_back if the node is first/last, but all I do is set node_ptr->prev to node_ptr-> next and then delete the node_ptr. I saw in another post that we should call ++/-- in erase/insert, so how do we utilize those?|131|5|active|I never had to use ++/-- in my erase and delete. However, I did use ++/-- on iterator in test cases||0
laeqdzz3weg27v|null_ptr and end()|"I'm unclear as to how I should be using the end() function. From my  understanding, end() will return an iterator pointing to ""one past the end"", which is just a nullptr. . . Say I've generated an iterator through this function, since it has nullptr as its node_ptr, wouldn't I not be able to do ANYTHING with it? Like, how would I do the --operator if there is no prev to go off of? For insert(), I just implemented it so that if the iterator is pointing to the a nullptr, I assume it is from end() and I call push_back. Should I always assume that an iterator pointing to nullptr is the one pointing to one past the end?. "|178|0|active|"I believe the point of it is to use as a sort of ""sentinel"" character, just like we do with c style strings.  I think you had the right thought with assuming a nullptr is one pointing to one past the end.  By doing this you can, for instance, iterate through your list until you reach the end, without relying on counting until you reach the size of your list (although that would work too).  "||1
laeq88ur61s2lg|Assertion failed: (node_ptr), function operator&#43;&#43;, file List.h, line 206.|"Assertion failed: (node_ptr), function operator++, file List.h, line 206.. . I don't understand where this could come from.  I ctrl+f'd the entire file for ++ cases and I've only used it on integers.  Anything else should be prewritten.  In fact, the operator overload itself was written for us so I'm not sure how I'm getting this error.  This is purely from running compile checks, not any test cases.  . . EDIT: I looked through the code for the compiler check, and I think it should actually fail?. it starts with a size of 0, pushes 2 (one to the front, one to the back), and sets ""iter"" to ""begin()"".  it then does ""++iter"", then ""*++--iter"", which is weird, because by C++ order of operations it should run ++-- first, but ++ takes it to a null pointer?  "|185|1|active|Turns out I accidentally flipped a couple lines in push_back that caused some edge case issues in the compile check. ||1
laepz2u4jao5yh|Test error|For some reason, when I try to test, on the line that I've set the breakpoint, it says that it is equal to nullptr which then fails the assertion assert (node_ptr) back in list.h. I've stepped through it and in the previous line, *it is equal to 1, but for some reason the following line doesn't work.|5|0|private|Marking as resolved. Please follow up if not.||0
laepx3m5snr32v|List Private Tests Not Compiling|Hello,. . Although my code passes the Autograder compile checks for the Public Tests and the Private Templating Check, it does not compile for general Private Tests. I'm a little unsure how to debug it from this point; any suggestions would be appreciated!. |107|0|active|It seems to be an error with your dereference operator, I would look back in lecture / lab to see what dereference should do.||0
laepm88gid82xd|launch json mac m1|what should this look like? mine isnt working|51|1|active|"It should look like this. Make sure that you change the ""program"" line to the executable you want to test though."||0
laepb01iayc2mf|Infinite loop Copy Constructor|Seems like I have an infinite loop in my copy constructor. Specifically in copy_all implementation. I am using a for loop to deep copy from one to another. |102|0|active|what kind of for loop is it? if you did something like length = other.length but then do for i<length and your insert adds to the length each time, then your loop would be infinite since each loop adds 1 to length||1
laeoy6q7hac4dh|another bad access error|Hello, I am getting another bad access error for pop_front. Why is this happening?|5|0|private|You are deleting the victim pointing at first and then attempting to access first at the line with the error with first->prev. I would make sure that you are deleting the node after any accesses to it are necessary.||1
laenqxm98ps49k|Pop_front and Pop_back|"I think I'm having issues with my pop_front and pop_back functions because I was having problems with my erase function that sometimes uses pop_front or pop_back. When I delete the first node, for example, when I reassign first to first->next, the node that first is now pointing should have a previous value of nullptr, since its previous node is about to be deleted. So i set first->prev to nullptr, and then deleted the ""victim"" node like from the lecture notes, and I got a segmentation fault. Why is this happening?"|133|2|active|Consider the assignments when the list becomes empty (etc popping the only element). Did you initialize last to nullptr?||1
laenozgzjtd7hx|Copy Constructor|I wanted to ask what is wrong with this copy constructor. The issue is that when I create a new list by copying, it crashes.. . I experimented around it, but I think there's something to do with the size variable being 0. If I have size to initially be 1, or more, then the program runs, but obviously incorrectly due to the difference in size from the original by the initialization. . . Here is my push_all function, for reference also. . . I am trying to set the size variable to be zero, because otherwise it somehow initializes to a random number by default.. |7|0|private|Marking as resolved. Please follow up if not.||0
laenjaqiw5r29x|Autograder says submitted no test cases|I have no idea why that would happen. tests compiled fine for me.. . UN: cadeci|101|2|active|Did you add a separate function such as for printing to your List.h file? If you did that's probably what was causing it. I had the same issue as you and it was solved by deleting my print function. ||3
laeng9sf2wh5j2|Clarification about functions|Is the insert function supposed to work if our iterator was created using the end function? Meaning the iterator is pointing at a null ptr. In this case do we just push_back? . . What is the point of the end() function if the iterator is pointing at just a nullptr? Would the -- and ++ operator functions work on an iterator from the end function?|93|1|active|Yes, `insert(list.end(), datum)` is the same as `push_back(datum)`.. . The reason `end()` exists is likely for semantics and consistency with the rest of the iterators that may exist in C++ classes. It's there because it logically makes sense to have a beginning and an end where you know where to stop - in our class it's trivial but in others it might not be, so having a common way of referring to it allows for easier development.. . No, the increment and decrement operators should not work on an Iterator with a null `node_ptr`.||0
laen89isu2n166|List copy constructor test|So for our test functions, whenever we try to iterate through a list, our overloaded operator != doesn't seem to like when we do list1iter != list1.end(), where list1 is the list and list1iter is the iterator of it. We tried using * with no improvement. Should we just see if the front, back, and size of the lists are the same, and if we do will that pass the private tests?|120|1|active|What exactly is . list1iter. If list1 is empty, both first and last should point to nullptr so list1iter== list.end()       . Since list1iter = nullptr (depending on how you initialized list1iter ( list1iter = list1.begin() or list1.end() ) ). and the end() function should point to nullptr,    . Thus both are equal. . If list1 is filled with anything and list1iter is initialized to any of the elements . ie. . List<int> list1;. list.push_back(1);. List<int>::Iterator list1iter = list.begin();. list1iter should not equal (!=) list.end(). since list1iter is a iterator with a node with datum 1. and list.end() is a iterator with node nullptr. . ||0
laen5l2kcgn644|Autograder States That No Test Cases were Submitted|The problem is basically what I've described in the title. I uploaded the List.h file and List_tests.cpp file and everything runs properly except for the fact that it states that I have no test cases, which is not true as I've run many test cases on my computer and they even show up in the files that I've submitted. What do I have to change for these test cases to show up and run? . . -Joseph Yi (6445 9970). Uniqname: yijo|3|0|private|.||1
laemw04t32r3xe|Error with copy constructor size initialization?|When I implement the copy constructor and initialize the size variable, the program goes wack and crashes if I initialize size = 0. Any other number works fine, besides 0, but obviously 0 is what I need to initialize it as. What is the issue??|80|0|active|Not sure. Instead, you could set the List private variable size=0 from the start, this would make any created list to already have size 0 and your copy constructor would increase the size based on push_front or push_back (or insert or erase) incrementing the size variable. It may also be beneficial to still find out what the problem is as well.||0
laemunkwhgs6s7|Memory leaks only on CAEN|"When running List_compile_check on my mac I have no issues, even with address sanitizers on.  It used to have the same issues as CAEN, but after some edits they've been fixed.  Despite this, CAEN continues to have memory leaks.  . . I think it has something to do with my destructors, but setting a custom Node destructor causes stack overflow on that destructor.  . . Logs from CAEN:. ./List_compile_check.exe10II*. 1. ===================================================================3238692==ERROR: LeakSanitizer: detected memory leaks. Direct leak of 24 byte(s) in 1 object(s) allocated from:    #0 0x7f5177feb000 in operator new(unsigned long) ../../../../gcc-7.1.0/libsanitizer/asan/asan_new_delete.cc:80    #1 0x403538 in List<int>::push_front(int const&) /home/dreiffer/eecs280/p4-web/List.h:46    #2 0x401931 in main /home/dreiffer/eecs280/p4-web/List_compile_check.cpp:23    #3 0x7f517654dcf2 in __libc_start_main (/lib64/libc.so.6+0x3acf2). Direct leak of 24 byte(s) in 1 object(s) allocated from:    #0 0x7f5177feb000 in operator new(unsigned long) ../../../../gcc-7.1.0/libsanitizer/asan/asan_new_delete.cc:80    #1 0x403ab2 in List<int>::push_back(int const&) /home/dreiffer/eecs280/p4-web/List.h:65    #2 0x4057fc in List<int>::copy_all(List<int> const&) /home/dreiffer/eecs280/p4-web/List.h:165    #3 0x40457e in List<int>::List(List<int> const&) /home/dreiffer/eecs280/p4-web/List.h:130    #4 0x401b11 in main /home/dreiffer/eecs280/p4-web/List_compile_check.cpp:32    #5 0x7f517654dcf2 in __libc_start_main (/lib64/libc.so.6+0x3acf2). Direct leak of 24 byte(s) in 1 object(s) allocated from:    #0 0x7f5177feb000 in operator new(unsigned long) ../../../../gcc-7.1.0/libsanitizer/asan/asan_new_delete.cc:80    #1 0x403538 in List<int>::push_front(int const&) /home/dreiffer/eecs280/p4-web/List.h:46    #2 0x404892 in List<int>::insert(List<int>::Iterator, int const&) /home/dreiffer/eecs280/p4-web/List.h:274    #3 0x401c0b in main /home/dreiffer/eecs280/p4-web/List_compile_check.cpp:36    #4 0x7f517654dcf2 in __libc_start_main (/lib64/libc.so.6+0x3acf2). Direct leak of 24 byte(s) in 1 object(s) allocated from:    #0 0x7f5177feb000 in operator new(unsigned long) ../../../../gcc-7.1.0/libsanitizer/asan/asan_new_delete.cc:80    #1 0x403538 in List<int>::push_front(int const&) /home/dreiffer/eecs280/p4-web/List.h:46    #2 0x402084 in main /home/dreiffer/eecs280/p4-web/List_compile_check.cpp:47    #3 0x7f517654dcf2 in __libc_start_main (/lib64/libc.so.6+0x3acf2). Indirect leak of 24 byte(s) in 1 object(s) allocated from:    #0 0x7f5177feb000 in operator new(unsigned long) ../../../../gcc-7.1.0/libsanitizer/asan/asan_new_delete.cc:80    #1 0x404943 in List<int>::insert(List<int>::Iterator, int const&) /home/dreiffer/eecs280/p4-web/List.h:278    #2 0x402aa0 in main /home/dreiffer/eecs280/p4-web/List_compile_check.cpp:64    #3 0x7f517654dcf2 in __libc_start_main (/lib64/libc.so.6+0x3acf2). Indirect leak of 24 byte(s) in 1 object(s) allocated from:    #0 0x7f5177feb000 in operator new(unsigned long) ../../../../gcc-7.1.0/libsanitizer/asan/asan_new_delete.cc:80    #1 0x403ab2 in List<int>::push_back(int const&) /home/dreiffer/eecs280/p4-web/List.h:65    #2 0x4019ce in main /home/dreiffer/eecs280/p4-web/List_compile_check.cpp:24    #3 0x7f517654dcf2 in __libc_start_main (/lib64/libc.so.6+0x3acf2). SUMMARY: AddressSanitizer: 144 byte(s) leaked in 6 allocation(s).make: *** [Makefile:54: List_compile_check.exe] Error 1[dreiffer@caen-vnc-mi14 p4-web]$. . My code--pardon the many many comments:. . #ifndef LIST_H. #define LIST_H. /* List.h.  *.  * doubly-linked, double-ended list with Iterator interface.  * Project UID c1f28c309e55405daf00c565d57ff9ad.  * EECS 280 Project 4.  */. . #include <iostream>. #include <cassert> //assert. #include <cstddef> //NULL. . . template <typename T>. class List {.   //OVERVIEW: a doubly-linked, double-ended list with Iterator interface. public:. .   //EFFECTS:  returns true if the list is empty.   bool empty() const{.       return first == nullptr;.   };. .   //EFFECTS: returns the number of elements in this List.   //HINT:    Traversing a list is really slow.  Instead, keep track of the size.   //         with a private member variable.  That's how std::list does it..   int size() const{.       return elements;.   };. .   //REQUIRES: list is not empty.   //EFFECTS: Returns the first element in the list by reference.   T & front(){.       return first->datum;.   };. .   //REQUIRES: list is not empty.   //EFFECTS: Returns the last element in the list by reference.   T & back(){.       return last->datum;.   };. .   //EFFECTS:  inserts datum into the front of the list.   void push_front(const T &datum){.      Node* newNode = new Node();//TODO MEMORY LEAK.       newNode->datum = datum;.       if(empty()) {.           first = newNode;.           last = newNode;.           elements++;.           //delete newNode;.           return;.       }.      newNode->next = first;.      newNode->prev = nullptr;.      first->prev = newNode;.      first = newNode;.      elements++;.      //delete newNode;.   };. .   //EFFECTS:  inserts datum into the back of the list.   void push_back(const T &datum){.       Node* newNode = new Node();//TODO MEMORY LEAK.       newNode->datum = datum;.       if(empty()) {.           first = newNode;.           last = newNode;.           elements++;.           //delete newNode;.           return;.       }.       newNode->next = nullptr;.       newNode->prev = last;.       last->next = newNode;.       last = newNode;.       elements++;.       //delete newNode;.   };. .   //REQUIRES: list is not empty.   //MODIFIES: may invalidate list iterators.   //EFFECTS:  removes the item at the front of the list.   void pop_front(){.       //Node* victim = first;.       first = first->next;.       //delete victim;.       //ptr->prev = nullptr;.       //first = ptr;.       elements--;.   };. .   //REQUIRES: list is not empty.   //MODIFIES: may invalidate list iterators.   //EFFECTS:  removes the item at the back of the list.   void pop_back(){.       //Node* victim = last;.       last = last->prev;.       //delete victim;. .       // ptr->next = nullptr;.       // last = ptr;.       elements--;.   };. .   //MODIFIES: may invalidate list iterators.   //EFFECTS:  removes all items from the list.   void clear(){.       while (!empty()) {.           pop_front();.       }.   };. .   // You should add in a default constructor, destructor, copy constructor,.   // and overloaded assignment operator, if appropriate. If these operations.   // will work correctly without defining these, you can omit them. A user.   // of the class must be able to create, copy, assign, and destroy Lists. .   List():first(nullptr){.       //Node* newNode = newNode();.       //newNode->prev = nullptr;.       //newNode->next = nullptr;.       //first = newNode;.       //last = newNode;.       //elements = 0;.   }. .   List(const List& other):first(nullptr),last(nullptr) {.       copy_all(other);.   }. .   List& operator= (const List &rhs) {.       if (this == &rhs) return *this;.       clear();.       copy_all(rhs);.       return *this;.   }. .   ~List(){.       clear();.       delete first;.       delete last;.   }. . . private:.   //a private type.   struct Node {.       friend List;.     Node *next;.     Node *prev;.     T datum;. .     //~Node(){.         //delete next;.         //delete prev;.     //}.   };. .   //REQUIRES: list is empty.   //EFFECTS:  copies all nodes from other to this.   void copy_all(const List<T> &other){.       for (Node* np = other.first; np; np = np->next) {.           push_back(np->datum);.       }.   };. .   Node *first;   // points to first Node in list, or nullptr if list is empty.   Node *last;    // points to last Node in list, or nullptr if list is empty. .   int elements = 0;. . public:.   ////////////////////////////////////////.   class Iterator {.       friend class List;.     //OVERVIEW: Iterator interface to List. .     // You should add in a default constructor, destructor, copy constructor,.     // and overloaded assignment operator, if appropriate. If these operations.     // will work correctly without defining these, you can omit them. A user.     // of the class must be able to create, copy, assign, and destroy Iterators.. .     // Your iterator should implement the following public operators: *,.     // ++ (prefix), default constructor, == and !=.. .   public:.     // This operator will be used to test your code. Do not modify it..     // Requires that the current element is dereferenceable..     explicit Iterator(Node *p):node_ptr(p){}. .     //public constructor.     Iterator():node_ptr(nullptr){}. .     Iterator& operator--() {.       assert(node_ptr);.       node_ptr = node_ptr->prev;.       return *this;.     }. .     Iterator& operator++() {.         assert(node_ptr);.         node_ptr = node_ptr->next;.         return *this;.     }. .     bool operator==(const Iterator& rhs) const {.         return node_ptr == rhs.node_ptr;.     }. .     bool operator!=(const Iterator& rhs) const {.         return node_ptr != rhs.node_ptr;.     }. .     char* operator*() {.         return (char*)&node_ptr->datum;.     }. .   private:.     Node *node_ptr; //current Iterator position is a List node.     // add any additional necessary member variables here. .     // add any friend declarations here. .     // construct an Iterator at a specific position.     //explicit Iterator(Node *p).     //    :node_ptr(p){};. .   };//List::Iterator.   ////////////////////////////////////////. .   // return an Iterator pointing to the first element.   Iterator begin() const {.     return Iterator(first);.   }. .   // return an Iterator pointing to ""past the end"".   Iterator end() const{.       //return Itterator(last)++;.       return Iterator();.   };. .   //REQUIRES: i is a valid, dereferenceable iterator associated with this list.   //MODIFIES: may invalidate other list iterators.   //EFFECTS: Removes a single element from the list container.   void erase(Iterator i){.       if (elements == 1) {.           pop_front();.           elements--;.           return;.       }.       if (elements == 2) {.           if (i.node_ptr->next == nullptr) {.               pop_back();.           } else {.               pop_front();.           }.           elements--;.           return;.       }.       Node* after = i.node_ptr->next;.       Node* before = i.node_ptr->prev;.       before->next = after;.       after->prev = before;.       //delete i.node_ptr;.       elements--;.   };. .   //REQUIRES: i is a valid iterator associated with this list.   //EFFECTS: inserts datum before the element at the specified position..   void insert(Iterator i, const T &datum){.       if (elements == 0 || elements == 1) {.           push_front(datum);.           elements++;.           return;.       }.       Node* newNode = new Node();.       newNode->datum = datum;. .       i.node_ptr->prev = newNode;. .       //Node* before = i.node_ptr->prev;.       //Node* after = i.node_ptr->next;.       //before->next = newNode;.       //after->prev = newNode;.       elements++;.   };. . };//List. . . ////////////////////////////////////////////////////////////////////////////////. // Add your member function implementations below or in the class above. // (your choice). Do not change the public interface of List, although you. // may add the Big Three if needed.  Do add the public member functions for. // Iterator.. . . #endif // Do not remove this. Write all your code above this line."|5|0|private|I ended up just avoiding it all together. ||0
laemiwxfudf42u|Testing for self assignment|"I am trying to test my assignment operator for the special case where a list is assigned equal to itself, by creating a list, pushing back some values, and then saying:. . list = list;. . My compiler is throwing an error message when I try to make List_tests.exe. The error says ""explicitly assigning value of variable of type List<int> to itself."" Is this not something we're supposed to be able to do, and if so why is there a check for it in the assignment operator?. . Thanks!"|128|1|active|The compiler will tell you to stop doing something like this in this trivial case. I think that the reason we have this check is if we have something hidden behind layers of pointers where the compiler doesn't keep track of if something is itself.. . For example, the following will also be a self assignment but probably not something the compiler bothers to evaluate:. ```cpp. int l[] = [a, b, c];. int* ptr = l;. l[1] = *(ptr + 1);. ```||1
laelz37vuv207|&#34;Delete&#34; not deleting nodes|EDIT: Solved, the memory leak error I thought I had simply came from referencing nodes after their deletion . |63|0|active|Marking resolved||0
laelwczuar76f9|Exec format error|. When executing code in CAEN, I get this error: cannot execute binary file: Exec format error. post @3386 had this same issue, but the solution offered wasn't helpful to me (I've tried recopying code to the CAEN multiple times, and as you can see above compiling isn't helping. Any ideas?|45|0|active|Marking as resolved. Please follow up if not.||1
laelttyexv547n|Question about T&amp; Back()|. . Hello. I can't seem to debug T& back(). I went through it in Office Hours and made a piazza post, and I'm not sure what's wrong. When I use it to get the reference of the last value, it keeps returning 5460801, but I can't dereference it because it's an integer. I'm not sure how listOther.back() is getting that number, and how to correctly test T& Back.|5|0|private|This is most likely an issue in your push_front() and not your back() function. It may be that push front is pushing uninitialized memory onto your list somehow. I would recommend setting a breakpoint in your testcase and stepping into your push_front function to make sure all of your variables are set.||0
lael4gn5e3k4ly|Seg Fault on Insert Function|I keep getting a segmentation fault when trying to insert elements into the middle of the list; does anyone know why this keeps happening?|124|0|active|I'd recommend drawing this situation out and reasoning through the order in which you connect the three nodes. [previous node] [node being inserted] [node iterator points too]. Usually, seg faults happen when making the prev and next connections in the wrong order (because you can lose track of nodes). Another problem could be not increasing the list size.. . ||0
laeky630g2512g|Why is my code leaking|Any help at all would be appreciated, I know you guys can't say anything outright!. . I am asking course staff to look at my group's submission.. . I am 90% sure that our code leaks in the insert function, in the second part of the control loop, the else {...}.. . I do not understand why. Do I need to worry that I am passing the iterator as a copy, not by reference? Stepping through my insert using my debugger doesn't show a difference, and the list gets updated correctly.. . Additionally, I have triple checked that prev and next are being updated properly.. . I am just at a complete loss as how the ```newNode``` is leaking.|4|0|private|I think it's because you are not increasing list size in the case where the node is being inserted in the middle of two nodes.||1
laekorqajsf2y4|How to check that list is correct?|When testing a list, how can we identify a specific element in the list? (Like, if we wanted to see if the 5th element was 5, how do you check that? :)|113|0|active|You would make an iterator and traverse to get to the 5th element. For example. ```cpp. List::Iterator i = list.begin();. ++ ++ ++ ++i;. ASSERT_EQUAL(*i, 5). ```. The above you can also do with a `for` loop or any method you want.||0
laekfm0yaoc7la|T&amp; back() Question|For T& back(), can we just do the same thing as T& front(), or does the nullptr change things? Can we just get the datum of last?|45|0|active|yes, you can just do that. the nullptr shouldn't change things since the nullptr is one past the last element and back wants what' in the last element.||0
laejbksc3sl3ms|When implementing my constructor there is an error for first and last|When I implement my default constructor my complier says that firs and last are not included in the class. This is the exact error for first . . No type named 'first' in 'List<int>::Node'|67|0|active|first is a member variable of the list and it appears you are using it as if it is a member variable of the node||0
laej4lme29l6fb|heap-use-after-free in push_back|"I'm not really sure how to ask this without showing my code, so this I'm opting to only send this to instructors.  . . The relevant code is as follows:. . void push_front(const T &datum){.    Node* newNode = new Node();.     newNode->datum = datum;.     if(empty()) {.         first = newNode;.         last = newNode;.         elements++;.         delete newNode;//memory freed here.         return;.     }.    newNode->next = first;.    newNode->prev = nullptr;.    first->prev = newNode;.    first = newNode;.    elements++;.    delete newNode;. };. . void push_back(const T &datum){.     Node* newNode = new Node();.     newNode->datum = datum;.     if(empty()) {.         first = newNode;.         last = newNode;.         elements++;.         delete newNode;.         return;.     }.     newNode->next = nullptr;.     newNode->prev = last;.     last->next = newNode;//ERROR.     last = newNode;.     elements++;.     delete newNode;. };. . The way I'm understanding this is I initialized a pointer, and deleted the memory after use.  Then for some reason it's picking up the same memory and never reinitializing it in the second function?  As long as it's deleted properly I read that it's completely ok to reuse the same name.  What's even stranger is that even if I use a different name (say newNode2) in the second function, I get the same error.  . . I did consider that perhaps the error lies in last->next rather than newNode, but ""push_front"" uses the same process and has no fault.  Also, the error log shows the freed memory to be from newNode.  . . Am I following the right process with handling memory? If not, where did I go wrong?. . Thank you!. . Address Sanitizer logs from List_compile_check:. ====================[ Build | List_compile_check.exe ]==========================make --jobs=6 List_compile_check.exec++ --std=c++11 -Wall -Werror -pedantic -g -fsanitize=address -fsanitize=undefined List_compile_check.cpp -o List_compile_check.exe./List_compile_check.exe1===================================================================33101==ERROR: AddressSanitizer: heap-use-after-free on address 0x000104c01f00 at pc 0x0001029572f0 bp 0x00016d4ae8a0 sp 0x00016d4ae898WRITE of size 8 at 0x000104c01f00 thread T0    #0 0x1029572ec in List<int>::push_back(int const&) List.h:76    #1 0x1029544e4 in main List_compile_check.cpp:24    #2 0x184ccfe4c  (<unknown module>). 0x000104c01f00 is located 0 bytes inside of 24-byte region [0x000104c01f00,0x000104c01f18)freed by thread T0 here:    #0 0x102d72330 in wrap__ZdlPv+0x74 (libclang_rt.asan_osx_dynamic.dylib:arm64e+0x4e330)    #1 0x1029568a8 in List<int>::push_front(int const&) List.h:52    #2 0x102954464 in main List_compile_check.cpp:23    #3 0x184ccfe4c  (<unknown module>). previously allocated by thread T0 here:    #0 0x102d71ef0 in wrap__Znwm+0x74 (libclang_rt.asan_osx_dynamic.dylib:arm64e+0x4def0)    #1 0x102956570 in List<int>::push_front(int const&) List.h:46    #2 0x102954464 in main List_compile_check.cpp:23    #3 0x184ccfe4c  (<unknown module>). SUMMARY: AddressSanitizer: heap-use-after-free List.h:76 in List<int>::push_back(int const&)Shadow bytes around the buggy address:  0x0070209a0390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x0070209a03a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x0070209a03b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x0070209a03c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x0070209a03d0: fa fa fa fa fa fa fa fa fa fa 00 00 00 fa fa fa=>0x0070209a03e0:[fd]fd fd fa fa fa 00 00 05 fa fa fa 00 00 00 00  0x0070209a03f0: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00  0x0070209a0400: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa  0x0070209a0410: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00  0x0070209a0420: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00  0x0070209a0430: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa faShadow byte legend (one shadow byte represents 8 application bytes):  Addressable:           00  Partially addressable: 01 02 03 04 05 06 07   Heap left redzone:       fa  Freed heap region:       fd  Stack left redzone:      f1  Stack mid redzone:       f2  Stack right redzone:     f3  Stack after return:      f5  Stack use after scope:   f8  Global redzone:          f9  Global init order:       f6  Poisoned by user:        f7  Container overflow:      fc  Array cookie:            ac  Intra object redzone:    bb  ASan internal:           fe  Left alloca redzone:     ca  Right alloca redzone:    cb==33101==ABORTINGmake: *** [List_compile_check.exe] Abort trap: 6make: *** Deleting file `List_compile_check.exe'. Process finished with exit code 2"|5|0|private|You’re deleting the node after setting first and last to equal it in push_front. That means it’s now invalid to access that node, and any references to first (or last if the list has one element in the end) will cause segfaults.||0
laeiqicmkir28d|Cant pop back when there is one element in the list|For some reason when there is one node in my list I can only use pop_front on it to successfully remove the element. If I use pop_back then I get a heap-use-after-free error. I implemented both of these functions very similarly, so I can't understand why one works while the other does not.|91|0|active|It might be that you forgot to set the last element of your list to the last element when you reach one element. The issue could be in when you make that one element and only set it to the front, or when you remove elements.||0
laeikft0do3307|Size Function|To create a private member variables, let's say int sizes, where am I suppose to declare it in my program? Right now I have it declared as a static int in in the private members of class List, but I'm getting errors like . undefined reference to List<int>::sizes|86|0|active|It should a non-static private member variable. If you declare it as static, then all List instances will share a size member. This isn’t correct since not all lists have the same size.||0
laehta3ibj250h|Insert|If I make a new Node and then set it equal to i.node_ptr, if I try to change prev and next for the new Node, will it also change the prev and next for i.node_ptr since the new node is technically a pointer?. Sorry for the confusion.|104|0|active|Yes, `i.node_ptr` is pointing to the node that you just made and are changing.||0
laehrkotpss7bc|keeping track of size|I made a private variable of size like this, static int size = 0;, and did size++ and size-- whenever we inserted or deleted something in the list, but I'm getting errors like . ./List.h:57:5: error: reference to non-static member function must be called    size++;    ^~~~. does anyone know how to fix this?|121|0|active|Autograder looks like it may have been fixed but please follow up if you are still getting that error!||1
laehd1b9rhc1fc|pop back malloc error|When I run my list tests, I keep getting a malloc error whenever I try to use pop back. For my implementation, I use the same basic implementation that I used for pop front, but in the other direction. My pop front does not seem to be showing any error and I don't understand why this pop back is.. . |114|0|active|Its hard to say exactly what is wrong. Alot of times in this project a bug in one function that may set a pointer to the wrong thing will cause a segmentation fault in another. In this instance, it looks like you double deleted (so potentially a pointer was duplicated somewhere).  I would suggest using your visual debugger to step through the test case it is failing on and make sure all the pointers are accurately set after each line of code. If you can find where the pointers are incorrectly set, you can find the bug.. . Hope this helps!||1
laehbrtgb025aw|Copy_all/copy ctor/assignment error|The only difference between my copy ctor and my assignment operator is that my assignment operator checks for self-assignment. Then, they both call copy_all, which has a clear at the start to make sure the list is empty. However, when I make copies of using the ctor and the assignment, only one will fail. In my copy all I have the option of iterating through rhs with a while or for loop. If my original (rhs) is of size 5, the while loop causes the copy ctor to make a list of size 6 and the assignment will make a list of size 5. The for loop does size 5 and 4 respectively. Considering I thought that the while and for loop were functionally identical, I'm not sure what's wrong, and I have no idea why one would work but not the other.|123|0|active|Marking as resolved. Please follow up if not.||1
laeh6wgqzfm72m|How to call end function|Hi, I'm trying to call the begin() function in the insert function using i.begin(), but I'm getting an error. ./List.h:259:25: error: no member named 'begin' in 'List<int>::Iterator'    if (i.node_ptr == i.begin()). . Does anyone know what is wrong here?                      ~ ^|128|0|active|begin is to be used on a list, not an iterator.||1
laegl8hi15s6a0|Prev|If it’s the first element of the node, is the first element’s prev a null pointer? |52|0|active|Yes, the first node in a list will have `prev == nullptr`. Similarly, the last node of a list will have `next == nullptr`. Note that the first node will also be the last node when the list only has one node.||0
laegkrmq7pz173|memory leaks in student list tests|Hi, I'm getting memory leaks in my recent autograder submit coming from my student list tests. I'm confused if I'm just writing my tests wrong or if there's actual memory leaks in my list.h insert function because when I run tests and debug on my own, I don't see any memory errors. Any guidance on how else to debug this if I'm not getting any errors when debugging on my own? Thank you!|99|0|active|If you haven't already, enable the [address sanitizers](https://eecs280staff.github.io/p1-stats/setup_asan.html). They will let you know what line causes memory issues and what type of issue it is.||0
laeg52z52ej6br|No test cases submitted|"On VScode, my code runs and works (List_tests.cpp and the compile_check.cpp), but on Autograder it states ""No tests cases were submitted"". My unique name is malvear. "|5|0|private|On my now current attempt, I know why there was a compilation error but I'm not so sure if the Tests get recognized after fixing the warning.||0
laeg1gk8r07786|bad_access error|Hi, I was wondering what the cause of this bad access error is. Is it because the old last node is not being deleted? any help would be much appreciated!|4|0|private|You need to consider the case where there is only one node in a list.. In this case last->prev = nullptr. This means hold_node =nullptr.. Then when you do hold_node->next, you have a bad access error, because nullptr doesn't have a next.. ||1
laeft0k6q4n3w7|I&#39;m getting a segfault in a function that I&#39;m not calling|As the title suggests, I'm getting a segfault in a function I'm not even calling. . The line causing the segfault is the first = first->next or last = last->prev line in my pop front or back function, like we had in lecture:. . Specifically, the segfault happens in pop_front or pop_back one line after I call either function in my clear() function, so if I use pop_front in clear, I get a segfault in pop_front and vice versa. clear runs perfectly fine, but once I get to the next line of code in my tests, I get a segfault. The line causing the segfault is located in an if/else branch, and the segfault happens even if that branch doesn't execute.. . I am very confused. If anyone has any suggestions or help, it would be greatly appreciated.. . Edit 1: After some further testing, it looks like the line does not cause a segfault if the if/else branch it is located in does not execute, but I still don't know why I'm getting a segfault after the function causing the segfault has seemingly gone out of scope. . EDIT 2: HALLELUJAH, I FIGURED IT OUT. I think. Not entirely sure what the solution to the problem is, but it seems like the pop functions are setting last to nullptr prematurely when the pop functions are called as part of clear() when it is called in the destructor, which is why it appears that the function causing the segfault isn't being called. This isn't the only situation where I'm getting the segfault, but this was the most confusing one, and I should be able to get rid of the rest of them on my own.. . Edit 3: Instructor's answer is correct.|138|0|active|It looks like you’re trying to dereference/access member variables of a nullptr somewhere.||0
laefn0v1yp96og|Confused about purpose of end()|What is the purpose of the end() Iterator function? Wouldn't we want end to bring the iterator to the last pointer? How can we use the end() function in our test cases if it points past the list itself?|151|1|active|"The main purpose of the end() being one past the end is so that we can iterate through the linked list. Our condition when we iterate is ""iter != end()"". If end() gaves us a pointer to the last element then the last element would not go into the for loop. Most for loops are done on every single element of the linked list so this would be a bug if everything but the last element went through the for loop."||1
laefhvymras1bo|list_compile_check iter3!=iter.end()|Hi, we are currently confused by the output of the list_compile_check file. Everything compiles fine but this is the section we are confused about:. .      b = iter3 != my_list.end();.      b = my_list.end() != iter3;.     cout << b << endl;. in our output, 0 is printed, and we are not sure if it is supposed to be 1 or 0. Also, how do we know what the whole output is supposed to look like? thanks.. |66|0|active|`b` is a boolean, so 0 means false and 1 means true. In this case, it should print 0 because `iter3` is an iterator with a null pointer and so is `end()`. This set of test cases is only meant to check if your code will compile, I don't believe the actual expected values are provided.||0
laee8isgfmm6yh|List assignment operator test|Hi, so I'm a bit confused on how to test the list assignment operator without using ASSERT_EQUAL. I created a list, filled it, then created another list, and made the second list equal to the first. using ASSERT_EQUAL on the two lists results in a compiler error. How do I proceed?|127|0|active|You could traverse both lists and check if each node is the same.||1
laedt8wu5na1lw|Autograder says I have no test cases|Problem is just like it describes, I put my project into autograder and it claims that I didn't upload any tests, even though clicking on my test cases file in the submission shows that they are there. It worked in previous submissions so I'm not sure what changed, whether it's my code or autograder malfunctioning. It says that List_tests compiled fine as well, and UID is identical to it as well, so I really couldn't say what happened. The only thing that changed was I added more tests, but that really shouldn't have caused anything to break.|51|0|private|I had the same issue, check that you aren't including any public functions that aren't part of the starter file (postincrement and decrement functions shouldn't be there either). From the FAQ:. . > Q: Why does my test case compile on CAEN, but not on the Autograder?. >. > A: Double check that you haven't added any public functions or made one that was originally declared private, public. Also, double check that you've not put using namespace std in a header file. Also, you can't compare an Iterator with a pointer.. . Related issue: @3378||1
laedghbj5cm1v5|Destructor Unit Test|Should we write a test for the destructor? It seems like if the destructor didn't work it would be obvious due to a memory leak since it's automatically called at the end of a program. If we were to test the destructor in the unit testing framework, what kind of asserts would we do since we can't necessarily test if there is a memory leak? Would we be just checking to see if certain pointers still have objects?|115|0|active|See @3372.||0
laecsmvmbgj3br|Shallow vs Deep Copy Constructor &#43; Assignment Operator|In the List class, are we to use a shallow copy constructor/assignment operator or a deep copy constructor/ assignment operator?|120|0|active|For a shallow copy - think about what that'd mean for a second list. Your new list would be pointing to the exact same nodes as the original. Let's now say you call pop_back on the first list - your second list now points to the previous last node, which very likely is deleted.. . In other words, since you're dealing with dynamic memory in the list, you want to do a deep copy.||0
laecsey5783qy|Won&#39;t pass compile check|"Hello. Last night I was using a Mac with VS code, on which my code was compiling fine. Overnight, my computer updated to MacOS Ventura, and now I can't pass the compile check. I'm assuming something with this update messed with my VS code. There is a red squiggly underline under #include  and when I do make List_compile_check.exe, I get this message ""xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun"". Does anyone know what this is and/or how to fix it?? Thank you!!"|72|0|active|resolved. if anyone has the same problem, I fixed it by just redownloading VSCode and following the mega setup tutorial from scratch.||0
laebxqe19zv2vl|P4 Initializing nodes in Insert Function|How should we initialize a node in the insert() function? In the P4 FAQ @3162 shows that one way of doing this is to use the default constructor and then initialize the it.. . Node* n = new Node{};. n->datum = datum;. This is what we did, but on the second line we get an error (we use 'ptr' instead of 'n' but otherwise it is the same). . ‘ptr’ does not name a type. I'm not sure why this isn't working?|104|0|active|~~Are you defining the `insert()` function inside the class? If so, try moving it outside of the class - it might be throwing errors because it might think `Node` isn't yet defined while inside the `List` class: [thread here](https://stackoverflow.com/questions/2133250/x-does-not-name-a-type-error-in-c).~~. Resolved as first followup.||1
laebbsv3e7631r|Function stubs for the erase and insert function|What do the function stubs look like for the erase and insert functions at the bottom of the header file? Are we also allowed to implement these at the top of the header file?|100|0|active|You are allowed to implement functions wherever you want as long as all the variables and functions they depend on have been declared already. Typically it is good style to implement all your functions at the bottom of the .h file so that all the declarations and function stubs are easy to read.||1
laeahafa6bd6g5|Compiler error in autograder.|My autograder is giving me an error for the List compile check. Does this mean we have to add our own assignment operators like assignment==() or assignment++() in addition to assignment--()?. . ![Screenshot_2022-11-12_135602.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkt04r5j3l2i2t6%2Ff6c030b133a05453564e2bc150667327c683cc19b8c2ea7beb751e9f171392e4%2Fimage.png)|129|0|active|Yes, the top of the class has this comment:. > // OVERVIEW: Iterator interface to List. >. > // You should add in a default constructor, destructor, copy constructor,. > // and overloaded assignment operator, if appropriate. If these operations. > // will work correctly without defining these, you can omit them. A user. > // of the class must be able to create, copy, assign, and destroy Iterators.. >. > // Your iterator should implement the following public operators: *,. > // ++ (prefix), default constructor, == and !=.. . Also, it wouldn't be `assignment==()` but rather `operator==()` (and the same for the rest of the functions)||0
lae9gsyqqyk6o6|Seg fault: List_compile_check|"Hi, my code is saying ""1"" and under that ""Segmentation fault"" for the compile check; what does this mean I'm missing? Any help is appreciated, thanks."|95|1|active|It means you are trying to access memory you shouldn't. Try using [address sanitizers](https://eecs280staff.github.io/p1-stats/setup_asan.html) and making/running `List_compile_check.exe` on your machine to see where this could be.||0
lae998h82w87of|Insert valid pointer|For the insert function, the require clause wants us to check if the iterator is pointing to a valid node. But when I get the iterator through end(), which is one past the last node (which is the nullptr, right?), how do I check if the iterator is pointing to one past the end or just an invalid address?|145|1|active|The iterator past the end will always have `node_ptr` be the `nullptr`. A way to check if the pointer is valid is to traverse the list and check that the pointer matches the address of any of the nodes or is the `nullptr`, but this makes your program slow (any function that does this is now automatically O(n)).. . If you're only using this check for debugging purposes, then you can actually just ignore the check. You'll know that the iterator is not pointing to a valid node when you try to dereference it (it'll crash the program).||0
lae8ctkhkc92zn|Push front/back memory leaks|. . I'm getting this error in the autograder every time I call push_front() or push_back() in my test cases. I drew out memory diagrams using my code but I'm still not sure where the leaks might be coming from.|135|1|active|It looks like you're using the new operator in push_back with some object that you never end up deleting. Walk through your code and see if you can find any dangling pointers.. . Also, please update your Piazza display name to include your uniqname (@6). That'll help us look at your autograder submission quicker.||2
lae6bkrcch87dl|Private Templating test not compiling|All the other tests in my autograder submission are passing, except for the private templating test. What does this mean and how do I go about fixing it? My uniqname is gilfond.|3|0|private|In List.h line 263, you are asserting *i. The compiler is yelling at you because not all types can be casted to a bool. Instead, try to assert that the node pointed to by the iterator is not a nullptr.||1
lae3y5dystl7j3|failing student tests run time|My copy constructor test is failing runtime in the autograder, but it's passing in my IDE. Screen_Shot_2022-11-12_at_10.52.56_AM.png|86|0|active|Its hard to tell from the screen shot what could be going wrong. Usually with copy constructors your while loop has got an incorrect condition (think about how you evaluate empty and when you may forget to update the variables empty depends on) or you set pointers to the wrong elements. It may be passing locally due to undefined behavior (something you don't initalize before you use it). Make sure that even in the copy constructor you set first and last because they wont automatically be set to nullptr (thus the first time you use them will be a fault). I would suggest using your visual debugger to step through and make sure all the pointers and variables are set to the correct values.. . Hope this helps!||0
lae33ce835l1wr|Setting up launch.json for Windows VS Code|"Hi, I'm having trouble using my visual debugger in VS Code. Because we aren't required to implement api.exe, what should our launch.json file look like? I've provided mine (which isn't working) below:. . ```. {.     ""version"": ""0.2.0"",.     ""configurations"": [.         {.             ""name"": ""(gdb) Launch"",.             ""type"": ""cppdbg"",.             ""request"": ""launch"",.             ""program"": ""${workspaceFolder}/List_tests.exe"",.             ""args"": [],.             ""stopAtEntry"": false,.             ""cwd"": ""${workspaceFolder}"",.             ""environment"": [],.             ""externalConsole"": false,.             ""MIMode"": ""gdb"",.             ""setupCommands"": [.                 {.                     ""description"": ""Enable pretty-printing for gdb"",.                     ""text"": ""-enable-pretty-printing"",.                     ""ignoreFailures"": true.                 }.             ].         }.     ]. }. ```"|63|0|active|@8||1
ladyrh4ccmm6v8|Push_back|I got an error message saying” runtime error: member access within null pointer of type 'struct Node'”. But not sure what this exactly means.|90|0|active|You are trying to access the member variables of a Node * that is actually a nullptr. It's invalid to dereference a nullptr, so you also can't dereference a nullptr and access its member variable (because they technically don't exist).||0
ladxozatpjo4ef|destructor for list class|for the destructor for the list class do we need to iterate through the list and delete all the nodes or do we just need to delete the first and last pointers? Also same question for the copy constructor do we need to iterate through and copy each node individually?|114|0|active|"Every node is created using the ""new"" keyword so they are all on the heap; therefore, all nodes must be deleted. I would think about other functions where you delete nodes from the list and think about how these functions can be used in the destructor. For the copy constructor, you also need to copy each node individually. Think about whether you have already implemented other functions that copy nodes."||0
ladwnq53cv65rf|Adding a head and tail node|Would this break the List interface and the comment rules for first and last?. When I initialize a List object, I set first to head->next which is nullptr, and I set last to tail->next which is also nullptr. Technically they both point to nullptr if the list is empty and would point to first and last node in list otherwise.. . Edit: unless I make the iterator dereference function return ->next instead and an if statement if there is only one node. Just trying to have my end() function return an iterator that is able to have the overloaded — move back to the last node.. . Edit2: a nullptr doesn't meet the requirements of operator-- because it is not dereferenceable, thus I will carry on.. |8|0|private|You should have a node pointer to the first and last elements in the linked list so you can reference them in your public member functions. You intuition is correct that you need to set them to nullptr if the list is empty. However, you can just set head = nullptr instead of head->next = nullptr. The second case will actually cause a segmentation fault because you can't access elements of a node (datum, next, prev) that doesn't exist. . . Not sure if this answers your question so please follow up if you are confused!||0
ladmvix4h0u6ax|make -j error|When I run the make -j command, I get the following message. Is this just a compiler version issue?. |64|0|active|`make -j` compiles pretty much everything, including the optional Web API part of the project. The linker is complaining that it couldn't find a `main` function in `api.cpp` and thus doesn't know what `api.exe` should do when you run it. Stick to `make List_tests.exe`, `make List_compile_check.exe`, etc. instead.||0
ladklaj0ud143y|How to check for special cases in insert?|How do I check if an iterator is pointing at the beginning or end of the linked list? Currently in my insert function I try to compare them to the begin() and end() functions. However when testing, I found that when I tried to insert something in the middle, not only would it not insert in the middle, but it would insert at the end and beginning instead. When I changed this to comparing the .prev or .next to nullptr, it caused a segmentation fault.|140|0|active|If an iterator points to the beginning of a linked list, then its node pointer has to be identical to first. If it points to the end (as in List<T>::end()), then the iterator is defined as referencing nullptr.. . You most likely got a segfault for trying to access .prev or .next when referencing a nullptr, which is invalid.||0
ladjzm33hud1hr|deleteing structs|So when I have a function such as pop front or back do I need to delete the struct afterwards to avoid leaking memory? If so can I just delete the node or do i have to delete all its member variables first?|73|0|active|You have to delete any memory that is dynamically allocated. If you don't delete the individual struct afterward (an update the members of other nodes properly), will delete ever be called on that pointer by anything else.. . When you delete a node, is it really necessary to delete its member variables? Or can we ensure that whatever nodes they point to will get deleted at another time?||0
ladjjpsgfhu71f|Copy constructor not working as intended|My constructor is not behaving as expected, and the debugger is pointing to these two lines:. . . p -> datum = datum. in push_back, and. . push_back(node_ptr->datum);. in my copy_all function.. . . I'm pretty much completely stumped by this. How would debug this?. . . . |3|0|private|Could you please update your Piazza display name to include your uniqname (@6). This will help us look at your autograder submission quickly.||0
ladiqj95onf5cv|Segmentation fault|Hi, I got segmentation fault in my code (pop front), and I do not know how to fix it. Can you help me to view it? Thx! |3|0|private|It looks like, at that line, first is a nullptr. You're trying to access the next member variable there, which is invalid.||0
ladi9d7a4iv3ib|Iterator ==|Should the iterator == operator return true if the iterators point to nodes with the same datum, or if they point to the exact same node (next and prev also ==).|127|0|active|The exact same node. Your overload of the dereference operator * will allow you to compare datums.||0
ladi3htu4bp7kk|Iterator erase() function seg fault|My partner and I keep getting a segmentation fault in our erase function, and we're not quite sure why. The debugger pointed us to line 294, but we have been struggling to find an issue with it. Is it a minor syntactical error, or is it likely the issue is elsewhere in our code?itersegfault.png|3|0|private|If the issue actually is at line 294, you're most likely trying to access a member variable of a nullptr, which is invalid. My guess would be that (i.nod_ptr->next) is giving you a nullptr, and the ->prev is causing a segfault. Step through to that line with a debugger and see if this is the case.||0
ladhr2gm9qc4np|compile error|hi, i'm getting this compile error:. Undefined symbols for architecture x86_64:. what could this be from?. |63|0|active|"The lines after ""Undefined symbols"" list the functions that you declared, didn't define, and used. An example is the `foo` function below:. . ```cpp. int foo(int x);. int main() {.   foo(2);. }. ```. The program doesn't know what to do because `foo` is not _defined_, or not _implemented_. In short, you are calling functions that have not been implemented. The error lists all these functions. Your solution is to implement all the functions listed."||0
ladgk8p56sc362|How to fix this error?|Getting this error in the Autograder saying that functions in my iterator class are private. I get the idea of what to do in the List.h file but I'm struggling to do it. . |93|0|active|Are your operator== and operator!= overloads both public in the Iterator class?||1
ladgj2k6e64cd|Iterator Operator Error|Resolved|3|0|private|Update: I think the dereferencing error was just because I did *list instead of *pos. However, I am still having trouble with the assert statement in the ++ operator.||0
ladfh6veiz62ja|architecture arm64 error|. I keep getting this error when trying to debug my project. Would anyone be able to help?|65|0|active|If we simplify the error message, it reads like:. > Duplicate symbol `main()` in `List_tests` and `List_compile_check`.. . So you compiled both files at once, and both files provided a main function. Which one should the program run? The linker is confused. See @656 for resolution steps.||1
ladf7vxqmz24c5|Question about List|"In P4, is the ""List"" class a general term to describe a group of any data type, both on the stack or the heap (generic template name)? Or is it explicitly another calling for ""linked lists"" (specifically for heap purposes)?"|68|0|active|The list class is just a class that keeps track of nodes to organize them in a way that makes sense as a list or array. A list can be made on the stack or the heap, but that shouldn't change how you define your `List` functions. The name `List` doesn't mean anything special inherently, but it's just an appropriate name for what we're building in the class.||1
laddsjyo6pj37g|Student list tests failing student list|Hi,. I have been working on writing test cases for list.h. Right now my code fails two of my test cases, and from what I can tell this has to do with an issue with my list copy constructor and the clear function, which I believe could also be because of issues with my push_back and pop_front functions. I am really confused, cause I copied these implementations off of the lecture slides from class. Am I doing something wrong?. My uniqname is Jsegalla and if u can give me any feedback on my push_back and pop_front functions or anything else, I would very much appreciate it. |7|0|private|Looks like you figured it out :)||0
ladcgrcce767oh|Not passing List Private Templating Test|Everything is compiling except for the private templating test. My partner and I have seen similar posts about this issue but most of them were resolved on an individual basis by uniqname instead of a public resolution. My uniqname is montulli. |74|1|active|Looks like you figured it out :)||0
ladc1o5lbg43zw|Error Output|. . . What exactly does this error message mean? I don't see it when I run it on my IDE.|63|0|active|Check line 171 in list.h. if copy_all is giving you problems then your push function could be running into issues||0
ladbngj2f2j20a|How to make insert work at the end of a list|I know that the end function points past the linked list. How are we supposed to insert things behind it? When I tried to implement it in the insert function I got a segmentation fault.|167|0|active|If you want to insert at the end of the list (so the new node would end up being the last node), you can just call push_back()||1
ladbmfi96k75ag|Error Initializing new Node using brackets {}|. I'm using the second option given in the P4 FAQ: Node * ptr = new Node {___, ____, ____}; but it's giving me this error. If I'm interpreting this correctly, the compiler seems to not understand that I'm trying to initialize next, prev, and datum? Am I doing this wrong?. . . EDIT: resolved, I messed up the ordering of the parameters in the brackets|38|0|active|Marking as resolved, the order the student needed is `new Node{next, prev, datum}`.||0
ladbg8qk2dz7b|Delete Pop_front and Pop_back Error|"Hi! I'm having problems with deleting nodes in pop_front() and pop_back(). I followed the implementation that was covered in class for pop_front() and used the same idea to write pop_back, however I am getting the error ""free(): double free detected in tcache 2"". When I used the visual debugger, I found that even when I deleted first/last, the node didn't actually delete. I used ""delete first"" and ""delete last"" for reference. How do I go about solving this error? I thought ""delete first/last"" would work?"|8|0|private|Marking as resolved. Please follow up if not!||1
ladb75h0kcq39o|Insert|If the specified element is the nth iterator, can we say that the previous node is (n-1)th iterator?|89|0|active|not sure what you're asking but the current iterator allows you to access what's previous/next||0
ladanta33on46|Function Stubs|Do I need the List<T>:: if I'm implementing the stubs inside of the class? Can it just be bool empty() const { implementation }?|53|0|active|See followup||1
ladadysnxp268x|Indirection Requires Pointer Operand Error|. . May I ask what to look for to solve this compiler error?|56|0|active|Resolved||1
lad9wwjnv9t48a|Problem when running public test|Could anyone help me with what this error means. Its happening when I try to clear the list and is on the line where I delete the temp node in my pop_front().. |99|0|active|The error seems indicative of a _double delete_ or _bad delete_. I'd recommend that you set up your [Address Sanitizer](https://eecs280staff.github.io/p1-stats/setup_asan.html), compile the tests, and run them again. This should give you a much more detailed (and colorful) error describing where exactly the invalid free took place, which would help you find the root cause.||0
lad99n42fs61jw|Autograder not recognizing written tests|My partner and I submitted our files to the autograder and it's not recognizing the tests we created. I'm not sure what the problem is because it shows that we submitted the List_test_.cpp file. My uniquename is julchami.. Screen_Shot_2022-11-11_at_8.30.22_PM.png|8|0|private|Looks like you figured it out :). . Also, could you please update your Piazza display name to include your uniqname (@6)? This will help us quickly find your autograder submission in the future.||0
lad8sz8m2uu1ee|Revealing Bugs|Hi guys, I have revealed 20 bugs and need help coming up with more edge cases. Can anyone give some tips as to what are some things that I could test?. I tried writing tests for == & !=, but the tests I wrote did not catch anything. Are there any extreme cases I should consider when I write these (or other) test cases?. . Any help would be great; thank you! :)|234|2|active|"It might help to think (1) in terms of logical combinations and (2) in terms of mutations.. * **Combinations**: What logical situations can a list be in? Empty, 1 element, 2 elements, many elements? What functions can be called in each situation? Combining these, we get a list like _(empty `push_back`), (1 element `push_back`), (2 elements `push_back`), (many elements `push_back`), (empty `insert`), (1 element `insert` at `begin()`), (1 element `insert` at `end()`), (2 elements `insert`),_ etc. Ensure that each of these combinations is tested for.. * **Mutations**: We call finding our buggy solutions ""mutation testing"" because we generate the bugs by mutating a small part of the correct staff solution, like changing a `<` to a `<=` or removing an edge case check. Ensure that your tests exercise every line of your implementation code, including all the branches taken, and try generating some bugs by mutating your own implementation code. Then, see if your tests catch those bugs, and if not, add a test that catches them.. . Also, you can take inspiration from the names of the private tests. For example, maybe follow the spirit of the templating private test and write a test that uses `List>`."||2
lad8nfn5rcs2gt|&#34;No test cases were submitted&#34; error|". . Hello, I ran into a same error as @3378, but this time my list_tests.cpp are compiling on my VSCode. I just want to confirm if this error was due to the ""Code Duplication"" error I got on the Autograder for making the test cases too similar or if it is something else I am not aware of.. . . My uniqname is wanpilc. Thank you so much for your time and kind help. "|10|0|private|"The exact cause of ""no test cases were submitted"" is that the iterators named `first` defined on lines 350 and 377 are unused.. . I think your local compiler should be able to catch this issue. Check line 4 in your Makefile for `-Wall`, `-Werror`, and `-pedantic`, and use `make List_tests.exe` to verify that your tests compile before each submission."||0
lad8jdb9ty52hy|Node stuct|If the node struct member variables are datum, next, prev, does that mean that every time we create a new node, it makes places for all three of those, inside of a new node?Also, if the first pointer  is outside of the struct, does that mean that prev box is not made in the first box? I’m having a hard time understanding the memory diagram of this.|64|0|active|"Yes, a node will create space for the three mentioned variables when it is created. Each time a node is created, it will have its own space outside of any other nodes in the stack or heap (depending on if you used `new`).. . Nodes don't actually store themselves in other nodes. They only store the pointers for other nodes in them. Each ""box"" is made separate of each other and they just contain addresses to know which box comes before and which box comes after. It's like having a phone directory of people in your neighborhood. In the directory, you can see where someone lives and how to reach them, but it's not like their entire house is in the book - it just tells you where to find it."||0
lad4ilasd7jhv|List Private Templating Test|Hi we are having trouble with the templating error on autograder, does anyone know what could cause this kind of error?|75|1|active|@3444||1
lad4fh5179z3wv|Code stops running for test|Hi, I'm not sure what's wrong with my code. Once I run the test, it keeps stopping.|3|0|private|If it's stuck like that, it's probably in an infinite loop. Perhaps you accidentally wired the last element back to the first element such that `last->next == first`, but we can't really tell because you seem to have never submitted this test to the autograder.||0
lad3p5xc4i05tl|List push_front function seg fault|Hi, we keep getting a segmentation fault on our push_front function, specifically when we try to write first->prev = n_ptr, where n_ptr is a new Node. How do we resolve this?|103|0|active|it's hard to say since we don't know what's happening before/after. I would say to think about special cases that could raise when we push front. What if first doesn't exist? ||0
lad36cak3ny73t|I need help setting up my visual debugger|I'm trying to use the visual bugger in visual studio code and at this point I don't know what I'm doing wrong. I copy and pasted the launch.json file format from the EECS 280 website. When I run it, nothing happens. Office hours ended before I could ask.. |100|0|active|Try removing lines 11-15 from `launch.json`. They specify that the the program's `cin` should be wired to the contents of `main_test.in`, which is specific to Project 1.||1
lad224lrish2k2|List Private Templating Test Not Compiling|. . I am failing the LIst Private Templating Test but I am not sure why. I have a 21/21 on the Mutation Testing Suites but I am not compiling on these tests. . . My uniqname is tanmayd. |116|1|active|The templating test checks if we can create a List of any element type, not just int. Add a test that uses `List` (or something else, just not `int`) to your own test suite, and fix the resulting compilation errors.||0
lad1h03t1kt1lj|end function testing|I am trying to write a test for the end function but I am having a hard time writing the ASSERT_EQUAL() part since I can't assert that test.end() is equal to nullptr. Is there a way that I can dereference test.end() and assert that it is equal to null? Or how should I do this? Thanks|104|1|active|Try to create another Iterator from begin() and walk to the end of the list. Then make a comparison with end().||1
lad0603j4yx3mx|Help with ubuntu not lauching|I'm having trouble launching ubuntu every time I try to start it I get the message below. Not sure what caused this or how to fix it.. |3|0|private|Resolved.||1
lacyq94tebh6lx|List private templating test|I'm not sure why my code is not compiling for this test. I was wondering if someone could give me any insight. My uniquename is ryanbird |3|0|private|Looks like your test is compiled in your new submission. Are there any other problems?||0
lacyacoc4ey4vl|Memory Leaks|I'm getting a memory leak I believe from push_back. I'm confused because I created a new node but did not delete it as it is added to the list and deleted using clear() in the List destructor. Any ideas about what might be going on?|159|1|active|In addition to the students' answer, drawing memory diagrams by hand and following your code could help you understand the root cause conceptually and progress toward a solution.||0
lacxndqvaxae|List_compile_check error|When trying to compile List_compile_check, what might this error mean? It does not specifically reference any lines.. |54|1|active|@3437||0
lacwj3arz6f14p|Autograder error for size() test, but test passes on xcode and when run on terminal|My size() function is working as it should and always returning the correct value when I run my tests on xcode and through my terminal, however, when I submitted to the autograder, it showed a different output for my size() function that was incorrect when I did a test for my copy constructor.|155|0|active|When a List constructor gets called, and it doesn't explicitly set the internal size variable (int) to 0, the internal size variable takes on an indeterminate junk value, which causes undefined behavior and is responsible for the discrepancy between your local output and the autograder's output. Therefore, check that all your List constructors explicitly set the size variable to 0.||1
lacvm0laevp69d|duplicate symbols error|hi, when I try to compile my list.h, I get this duplicate symbols error. how do I fix this?|65|0|active|"@656. . The linker emits this ""duplicate symbols"" error when it finds multiple function definitions with the same signature. Double-click on the entire project in the file hierarchy and go into Build Phases. Check that no function is defined in multiple source files being compiled (like, for example, ""main()"" being defined in both List_compile_check.cpp and List_tests.cpp), and remove duplications."||0
lacve1rw71i6h9|List Object Error (RESOLVED)|"When I am creating a List using the syntax List<int> my_list; I am getting an error saying ""argument list for class template ""List"" is missing"", where is that coming from? Would it be some problem with my default constructor?"|3|0|private|Resolved! For some reason VS code was giving me errors when there were none, I just had to restart the application.||0
lacum9g493w24c|When to include  in List.h|Since List is a template class, I am unclear on when it is necessary to refer to List as List<T> and when it is acceptable to just say List. For example, for the default constructor, is List() ok or is List<T>() necessary?. . Similarly, for the assignment operator, I have the following:. Is the <T> necessary for the return type, and/or the parameter type?. . Thanks!|109|1|active|It seems that both `List` and `List` are acceptable syntax for the no-argument constructor and `operator=`, and they are equivalent.||0
lacuj4lobhe3oo|Help with memory leaks in List|I got a bunch of memory leak errors but I'm not sure why? I know its because of how I pop elements:. . I think it might be because of how I wrote in the case size only equals one, but I don't understand what else to do in that case other than assigning nullptrs since first and last would point to the same node?|4|0|private|You create a new node temp and immediately set temp = first, so you will lose access to the new node and never be able to delete it. Actually, you shouldn't create a new node in the pop functions. Instead, you only need to delete the node that is popped out from the list.||0
lacudfsvgj85v8|How to delete nodes created in push functions|How do I delete the new nodes I create in the push functions? In the pop functions I just made another new node and assigned it to the first/last node and deleted it, but that still results in a memory leak since the original created node was never deleted. I just can't seem to figure out how to prevent this leak.|125|0|active|"It sounds like you are making a completely new node and then copying the information from the *first or *last node pointers. Deleting this new node would not delete the original nodes that you are trying to remove from the pointers. Instead, I'd suggest creating a node pointer. Let's call it n_ptr and then pointing node_ptr to what first/last is pointing to. Then you would be able to do ""delete n_ptr;"" which would delete the node you created originally from the push_front() and push_back() functions.. "||0
lactvm94lbk3e6|What should front and back return when the list is empty?||100|0|active|Your situation violates the REQUIRES clause, so it will never be tested.||0
lacslun2i875on|Autograder Visual Studio Code discrepency|I have written some test cases on VS Code, and they all pass. However, when I run the same code on autograder one of my test cases fails. I'm confused on why it works for one and not the other. Is there any way I can get the two to be consistent?.  <- Autograder.  <- VS Code|87|0|active|If your program has different behavior on different systems and platforms, it probably has undefined behavior. With VSCode and WSL, you can enable the [Undefined Behavior Sanitizer](https://eecs280staff.github.io/p1-stats/setup_asan.html), which should point out any instances of undefined behavior occurring in your program with line numbers. Its errors should help you find the root cause.||0
lacsjgsz8l41lt|Autograder List Private Templating Test|Can an instructor direct me to the error in my code causing this error? My uniqname is jilljou.. . Thank you!|5|0|private|"I saw that you are trying to compare the datum in two nodes. `datum` is of type T, which doesn't have a matching operator, that's why the error message says "" no match for 'operator=='"". Instead, you should be comparing the Node pointer instead of the datum."||0
lacsevj0ba75ll|end() Iterator func|I was wondering about the end() Iterator function...is it required that the list in question is not empty? Or should I account for the fact that for an empty list, the function should just return a nullptr?|140|0|active|"No, the list could be empty. This function always returns an Iterator whose note_ptr is pointing to ""past the end"" in the list. You should never return nullptr. Think about what ""past the end"" means when the list is/isn't empty."||2
lacruh7hgr021t|Seg fault pop_front and pop_back|"When trying to make first->prev in pop_front and last->next in pop_back null pointers, I get a segmentation fault and it tells me that ""The signal is caused by a UNKNOWN memory access"". Is there another way that I am supposed to assign prev and last, or is there another reason for this error?"|128|3|active|resolved||1
lacrj6m7zbh6v2|How to create a list?|What is the syntax to create a list? I have List<int> list = (4, 1); and it's causing an error. How would you create a list of 4 integers with {1, 2, 3, 4}?. . Are we supposed to #include <list> anywhere? (at the bottom of the spec, it says not to do it outside of ai.cpp). . Thanks. :)|137|0|active|Based on the starter file you only need to implement a default constructor and a copy constructor, so you can either create an empty list and then call other functions to add elements to the list, or you can create a list calling the copy constructor that will be a copy of another list. ||0
lacr41l2puy6xi|Erase function|What should our program do if an argument for iterator is passed in that equals end() which is one past the end, for the erase function? Should it throw an error because we can't erase a nullptr because that it basically what end() gives?|237|0|active|The requires clause for erase states that i should be a valid iterator, so the function doesn't have to handle the case where i is a nullptr. It could be a good idea to have an assert statement in erase to make sure the requirement is met, to make debugging easier. ||0
lacqs62jlhe1ht|Iterator testing|I'm not sure how to test the == and != operators for Iterator. Could anyone give me some ideas or point me in the right direction?|145|0|active|!= and == are comparing if two iterators are equal or not. You could test this by creating two iterators that point to elements in a list, and then comparing them to each other using these operators. To move the iterators along the list you can use the ++ and -- operators. ||0
lacq1doz47h28a|False positives for erase test case|I keep getting a false positive for a test case when using erase at the end of a list. I set an iterator to end of a list, and then pass the iterator into the erase function and removing the last element. The test case is passing but I'm not sure what's wrong|189|0|active|"Are you setting the iterator to the end of a list using the end() function? The end() function returns an Iterator to ""past the end"", so it's not actually pointing to the very last element but ""past it"". Then if you call erase on the end, it shouldn't work because end isn't actually pointing to an element. "||1
lacpsx5hti02pq|Push_back seg fault in copy all|When writing copy_all every time I try using the push_back function that works elsewhere in the code I get a seg fault. I am having trouble figuring out if there is a reason why push_back can not be called within the function or if I am just implementing it wrong.. . . Does not give a line number but with cout statements I can tell it is when I call push_back|113|1|active|If you enable the [Address Sanitizer](https://eecs280staff.github.io/p1-stats/setup_asan.html), compile the tests, and then run them again, you should get a much more helpful (and colorful) error message detailing when exactly the illegal memory access occurred, including line numbers. That should help you pinpoint the problem.||0
lacp5ffjcp92ps|List Private Templating Test|List Private templating test is not compiling for me in the autograder, I am not sure if I need to change something to T or change something to not be T, any insight here appreciated|78|0|active|Can you include your uniqname in your piazza user name? This allows us to lookup your submission on the autograder||1
lac3cfl9uck35m|Autograder can&#39;t find student tests|The autograder doesn't recognize my List_tests, much like @3378. That post suggests that my tests aren't compiling, though they are on CAEN and my machine. The P4 FAQ lists these as possible causes of this mismatch:. . > Double check that you haven't added any public functions or made one that was originally declared private, public. Also, double check that you've not put using namespace std in a header file. Also, you can't compare an Iterator with a pointer.. . - I have checked and I haven't added/used any public functions to my `List` class other than the default constructor and the big three. For `Iterator`, I added the functions instructed ~~and the `operator->`, but only as a private function and only used in the `List` functions and not the tests~~.. . - There is no namespace in my header file.. . - I have looked through my code again and I don't think I'm comparing an `Iterator` with a pointer. Even if I were, it should've (?) thrown an error since the single argument constructor for `Iterator` from a pointer was marked as `explicit`.. . What is odd though is that the `List_tests` file does seem to be compiling, given in this later section in the autograder:. ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fl7nv0y6f4pf5aa%2F2715e0cfb2bd30e8a72c38689e848e069cf25e72b36d7f61574f60d071f9df28%2Fimage.png). . My theories are:. - ~~autograder didn't think the file compiled because it failed a style check~~ fixed and still fails to find tests. - ~~autograder doesn't like `explicit` keyword~~ removed and still fails to find tests. - ~~autograder doesn't like `operator->` override~~ removed and still fails to find tests. . ~~I will test these accordingly but if there's a glaring issue you see that I missed that would be helpful.~~ Could someone please take a look at my submission and point me in the right direction or give me the console output of why the autograder is not finding my tests?. . Thanks!|3|0|private|Resolved. In general, try to only use the prefix ++ and -- operators on iterators.||0
lac1whmpr542pj|Cannot catch edge case bugs|Hello, I have been writing normal and edge Iterator and List test cases, and for some reason the Autograder only catches 15 out of 21 bugs. . . . . Before I added any Iterator test cases, I was able to catch 9 bugs, and adding the normal iterator begin and end test cases, insert cases (start and end), one normal erase case, one copy char constructor (which was formerly copyCookie and now. . z_assignmentCookie which the latter is currently running into memory leak issues), and one push_back test with a single element, I caught four more bugs. . . . . . . However, after I implemented Iterator test cases where I included normal, one element, start, and end for each of the functions along with one helper function identicalLists that implicitly tests the != operator and the ASSERT_TRUE function testing the == operator, for some reason I only caught two more. I'm not sure why this is the case, but I deduced that it must be the issue with the Iterator functions. If it is something else besides this, please let me know.. . Can you please take a look at my test cases as well as my Iterator functions to see why I can't catch these edge cases? Here are my code files for your reference: List.h and List_tests.cpp,and my uniqname is wanpilc. . . Thank you so much for your time and kind help. |7|0|private|Resolved||0
lac1h3dx2n23tk|Problem with pop_back|When implementing pop_back, I'm trying to use a similar method as pop_front, but assigning last to last->prev. I'm getting multiple errors, but I can't think of another way to go about this. Any suggestions? Here are the errors:. |116|0|active|When creating a Node, are you initializing both its next and prev pointers to something (either nullptr or the address of another node)? It looks like some pointer was not initialized, hence the junk data.||0
labz7zcsrna6ld|No red squiggles for list.h|I'm getting an issue for list.h where I can't find my syntax errors and vscode won't show red squiggles. However, it could do it for the test. Anyone know how to fix this?|83|0|active|"Can you make sure error squiggles are enabled, please? Open your command palette (ctrl + shift + P, or command + shift + P on macOS), search for ""IntelliSense,"" and select something like ""enable errors squiggles."". . If this doesn't work, unfortunately, templating seems to mess with IntelliSense in VS Code (at least on my machine). Like the student answer suggests, you can rely on your compiler for syntax errors, though I recognize this isn't ideal.... . After some experimenting, it looks like if you remove all templating from your implementation (ex: Replace all T types with int), code linting works. However, I don't recommend this approach if you've already made substantial progress -- if you're just starting, you might consider trying this, but then you'd have to add all templating back before submitting, as well as update your tests to use templating too. It's tedious..."||0
labz2jj73bxpy|List Private Templating Test - Autograder p4|"I can't figure out why the List Private Templating Test on the autograder won't compile. I made tests for different types to assure that the templating works for any data type, and my code passes the tests. The only thing I can think of is using the keyword ""typename"" in front of the operator++ like in the lectures, but when I do that I get the error, ""expected a qualified name after 'typename'."" Would love some insight on why it won't compile this test in the autograder, thanks!"|137|0|active|Please include your uniqname in your Piazza user name so we can lookup your submission on the autograder||3
labyoe3ftbj26y|How many possible bugs are there?|Like @1107, I would like to know the total number of buggy implementations that we could possibly find. I understand we only need to find 21, but obviously, if you only catch 21 with your test cases, and there are more than 21 bugs total, then you could still have a bug in your own code! If any instructor could share, or any student who has found more than 21 (in autograder), that would be much appreciated. Thanks a bunch!|168|0|active|Our tests found 23 bugs||0
labydyxm6sz646|Copy Instructor|"When we write a copy constructor, can we assume the ""this"" object is empty?. . . "|103|1|active|You can assume that none of the values in `this` are initialized. Keep in mind, however, that this does not exactly mean they are zero/null by default.||0
laby7yfuzu86ts|Extra Qualifications on member functions|Getting this error but i copied using the lecture notes. What can I do to remove this error?. Sorry I need to give more context. I copied the format for the big three from lecture notes, wouldn't this work?|63|0|active|You might need to change some of those to List<T> instead of just List.||0
laby7010dhz4c6|prev pointer|I'm writing the push_front function and and im confused on how to access the previous node so I can set p->prev to that. I know that for the first element prev will be nullptr, but what about after that.|67|1|active|resolved||1
labwtpaix3v6dy|memory leak|i'm getting memory leaks for these functions, in which i create a new node named p:. . how do I delete the node through the pop functions since the node is not being recognized as p outside of the function where it is created?. . for additional info, attached is also how i have my pop function right now. . . |4|1|private|p doesn't need to be in scope or recognized, for example, say I call push_back() and add node p to the list, then I call pop_back(), we don't need to keep track of p, because if we're calling pop_back, we know we just wanna delete the last node, which you can do by doing something like:. . delete last;. . It doesn't look like you are attempting to delete p anyway, it looks like you are saving whats last as a temporary then deleting that (which looks good me). . If you still have a memory leak, can you follow up with a screenshot of the error?||1
labwg71cahd2e9|memory leak|"how can i call and delete a node in (for example) pop_front when the node was created in (for example) push_front?. . i'm getting ""use of undeclared identifier"" error"|106|1|active|For example, if you wanted to delete a node in pop_front(), then you know the node you want to delete is going to be first,. so doing something like:. . delete first;. . should work, you just have to remember that you save whatever the new first is going to be before you delete first||0
labw4dg049t5x8|Writing implementations in the class|"If we decide to just write the implementations in the class, does this mean we can just implement them with the signature as is? Or do we have to make it so it has the same format as if we were implementing outside of the class? For example:. . T & List<T>::Iterator::operator*() const. On another note, I'm trying to implement the Iterator operators in the Iterator class, and I'm getting the error "". Non-const lvalue reference to type 'List<int>::Iterator' cannot bind to a value of unrelated type 'int'."" I'm using the exact implementations that were shown in lecture. Does anyone know what problem I might have? Thanks!"|116|2|active|If you implement them in the class you can just use the signature as it. You shouldn't need any scope resolution. On another note, make sure you include a friend class to access the list function (if you haven't already, that could also cause problems.)||0
labw2oldqb07od|Initialize first and last pointer|How do I initialize the first and last pointer in my default constructor?|72|0|active|You can set both of them equal to nullptr like so:. . ```. first = nullptr;. last = nullptr;. ```. . or use the initializer list if that's your preference: `List() : first(nullptr), last(nullptr) { ... }`||0
labvjo502hoo6|Why does this if condition lead to a segmentation fault?|this is an if-condition under my erase() function. I fixed it already by changing the condition altogether, but I am wondering why this previous condition i used led to a segmentation fault, since i am not accessing or dereferencing anything in dynamic memory?. . |4|0|private|It might be segfaulting in the case where the list is already empty, because technically, next and prev would probably be nullptr too. . . Doing something like:. . if (i.node_ptr == first) {.    pop_front(). }. . might be better||0
labupxfr15a3t|how would I ensure that the iterator is valid for insert and erase|Hello, I basically have the functions implemented at this point and they work correctly. However, I do not know how to implement the requires clause here. I cannot just check to ensure that the iterator being passed is not a nullptr due to the fact that that is used to represent the end of the list. Would using empty() work at least for erase? It could possibly be empty if we are using insert or am I not understanding that correctly and the list has to be populated in order for something to be inserted? |249|0|active|Basically, all you have to make sure is if you pass an iterator into insert() or erase(), don't pass that same iterator into another function again, because it wouldn't be valid anymore (unless you re-initialize it)||1
labt57168x25z2|Error with clear function|I have been stuck on this error for some time now and was wondering if anyone has encountered anything similar|8|0|private|Since you're sharing code, I converted your post to private. In the future, please don't share code publicly -- you don't want anyone stealing your ideas!. . Quick clarification to the student answer: You can continue to use a pointer after delete has been called on it, so long as the pointer has been re-assigned the memory address of a valid object. In this case, what you're doing with curNode is fine.. . However, does your clear() function work correctly on a List that's already empty? Consider what happens if first is null to begin with.||0
labt08mbq626t6|erase()|When testing the erase function, we can't reuse the iter after using erase right? For example:. ++iter;. list.erase(iter);. ++iter;. list.erase(iter);. This will fail because erase will delete the ptr from the iterator right?|194|1|active|Correct.||1
labsv50szoa4ii|Assignment operator in List|I am getting a compile error in the autograder in my assignment operator function for List. Can I not use the == to check if the lists aren't equal? Is there another way to check this condition?. . |112|0|active|"You can use == to check if two Lists are actually the same object, but consider the types of these two variables: ""this"" is a pointer to a List, while ""rhs"" is a regular List variable. Can you think of an operator that would help you check if ""this"" points to ""rhs""?"||0
labsloraahj2j7|Is it possible to deep copy an iterator?|"In the project it says a user must be able to ""create, copy, assign and destroy iterators"". Is it possible to make a deep copy of an iterator, considering an iterator is a pointer itself? Or is it asking for us to be able to make shallow copies of iterators?"|104|0|active|If you're not sure on this I would double-check the iterators lecture. Remember that the point of an iterator in this project is basically to be able to iterate through a linked list like you can iterate through an array using pointer traversal. With that in mind, does it make sense to deep copy the node pointer of the other iterator when copying?||0
labs4wthadudk|push_back changing next pointer|For push_back, I want the original last node to point next to the new node, but when I try to change the value of last->next it segfaults. My code looks similar to how it is implemented on the class slides. How to fix this?|79|0|active|What happens if you call push back on an empty list?||0
labrzlum2sa6h|Problem with pop_back and empty TESTING|I made a previous post about how my pop_back isn't working (@3382). I fixed the part with previous, however, I have a question related to testing pop_back and empty. When initializing a List and pushing back 4 variables and then using pop_back to delete them all, I use empty to check if the List is empty. This is where I get my memory error:. . ==1728==ERROR: AddressSanitizer: heap-use-after-free on address 0x6030000006d0 at pc 0x555555591530 bp 0x7fffffffd310 sp 0x7fffffffd300. . I think this means that I am trying to access memory that has been deleted. When I use empty with pop_front after deleting the entire List, I don't get a memory error. However, when I use pop_back and delete all variables from the list and then use empty, I get a memory error.. . Any tips? |120|0|active|I ran into this error a lot while debugging my program. The best advice I can give is to use the visual debugger. It should allow you to see the head and tail nodes, and what they connect to. You can then traverse through the connections to see where something went wrong - for me it was usually forgetting to reassign the head and tail pointers of the list.. . ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fl7nv0y6f4pf5aa%2Fa8c926a0b06da1b51bbfa538f23a6e09cce4138a5694c71506356c05de7be8e1%2Fimage.png)||0
labrn490o196us|Operator overload &lt;&lt;|Are we supposed to overload operator<<?. I keep getting the error saying there is no operator<< |105|0|active|No. You may be calling `||1
labr9qzdbss7b4|Testing Functions Given|Should we test functions if they were already written for us in the starter files? For example, Operator--, begin(), and end()|114|0|active|I don't believe you *need* to, but you should probably be using those functions in your iterator tests anyway.||0
labr7bk71zy1i3|identifier &#34;T&#34; is undefined|"Getting an error: identifier ""T"" is undefined,  in the node struct in the code i copy pasted below the line that says to add your code"|68|0|active|"Do you have ""template <typename T>"" declared above the List class?"||0
labn9g5tf6n76t|end() function question|The RME says that the iterator will be pointing at “pass the end” in the list. What does this mean? Should it not point at the last node of the list, but  one after it? Wouldn’t that be out of the list?Thanks!|133|0|active|Well, the last node's next pointer points to `nullptr`, right? So `nullptr` would probably be a good representation for past the end of the list.||1
labn7f7hzha3w3|What should be the correct behavior for insert if given an Iterator pointing to the end.|. void insert(Iterator i, const T &datum);. What should be the correct behavior of the following codes.. . List<int> list1;. List<int>::Iterator iter1 = list1.end();. list1.insert(iter1, 10);. Should 10 be added to the back of this list, or nothing should be happened? Thanks!|141|0|active|Since insert places the element behind the element the iterator points to, you're correct that it'd be placed at the back!||1
labj4hqwekk1tr|void copy_all function|Hello! I just had a quick question about the copy_all function. It seems like this function is private within the List class, thus is it necessary to test it in our testfile?|120|0|active|Since copy_all() is private, you cannot directly call it from your tests. However, are there public List functions that do call copy_all()? You should definitely write tests for List's public functions!||1
labfr8q5bzqo9|Autograder acting different than vscode|Mutation test suites is not compiling, and I am getting errors when trying to compile on CAEN. What could be the reasons that it is only compiling on my compiler and what should I do?|80|1|active|I just checked your last submit, and I don't see any compiler errors... Could you share the errors you're getting on CAEN, please? It's possible your local compiler isn't configured to be as strict as the one on CAEN.||0
labfjb3rqnk1ga|Memory leak in copy constructor|Me and my partner are getting memory leaks in our copy constructor and we tried CAEN and Valgrind but it wouldn't compile even though it compiles on VSCode. It says our memory leak is when we do p->datum but we call clear() in the copy ctor so we aren't sure how to fix this. Our pop_back() and pop_front() have been tested to delete nodes properly.|184|0|active|"Before addressing memory leaks, I would address any compilation errors you're getting on CAEN. Then, I recommend re-compiling and running with the address sanitizer enabled -- it tends to give more helpful messages than Valgrind.. . Debugging pro-tip: What if you created a default constructor and destructor for Node? In the constructor, you could print a message like ""created Node,"" and in the destructor, you could print something like ""deleted Node."" Then, you can run your tests, and then ensure the number of creation and deletion messages are the same. Just make sure to remove these changes before submitting to the autograder."||0
labebomu4ka1s0|Error running on CAEN|"Hi, I'm trying to run my code on CAEN, and I get the following error:. . ""-bash: ./List_tests.exe: cannot execute binary file: Exec format error"". . I'm not really sure what the problem is so I'd appreciate any help/guidance. Thank you! "|60|0|active|This error means you're trying to run a program that was compiled for a different platform. For example, if you compiled the binary on macOS, it won't be able to run on CAEN's Linux distribution. Try re-compiling List_tests on CAEN, and this error should go away.||0
laba1b6fz1o3ab|Mutation Testing Suites not compiling|"Hello, had a weird issue today when submitting my tests. For some reason My List_tests.cpp file did not compile on the autograder under the Mutation Testing Suites. The file compiles fine on VS Code, and weirdly enough compiled everywhere else on Autograder including ""Student List tests on student List"", ""List private test case compile check"", and under the ""List Private Tests"" tab. Any idea on why this might be? Under the Mutation Testing Suites I got an error for Exit Status: 2."|116|4|active|We were running into the same issue, try checking the types that you are comparing inside of your ASSERT_EQUALS() and ASSERT_TRUE(... == ...). For example, ASSERT_EQUALS(nullptr, list.end()) isn't valid because list.end() is an iterator and nullptr can't be compared to it. Running it locally or on CAEN didn't catch this error and the test seemed to return as a PASS, but the autograder wasn't able to run the tests because the error. Checking the types that you're comparing should fix the autograder error.||1
lab7pz1bdkzdu|pop_back|When I am using pop_back, I used the same code as pop_front as shown in the lecture. However, it keeps adding the item I want to delete into the list. Basically, pop_back acts like push_back even though I am deleting the last item in the list like done in pop_front. I am getting this error as well: free(): double free detected in tcache 2. . I also tried setting lastnext as nullptr but throws the same error instantly: free(): double free detected in tcache 2. . Edit: I just realized that free(): double free detected in tcache 2 is a memory error. But I am still confused as what is state above with the behavior of the function. Any tips?. . Any idea why this is?|205|0|active|You only want to delete each node once. A typical case is that you did not set first or last correctly, and had maybe two pointers pointing to the same node and then tried to delete it twice. You need to think about in which cases you create a new node, and in which cases you want to delete it.||0
laamkjiwza11cc|Debugging Help|"I've been stuck on this bug for so long, I'd appreciate some help!. . .   template <typename T>.   void List<T>::push_back(const T &datum) {.     Node * new_node = new Node;.     new_node->datum = datum;.     new_node->next = nullptr;.     new_node->prev = last;. .     if(empty()) {.       first = new_node;.       last = new_node;.     }.     else {.       last->next = new_node;.       last = new_node;.     }.     elts++;.   }. I've gotten my debugger to work, and it tells me that an exception occurs at the line with ""    new_node->datum = datum;"". which I really don't know why.. Only thing I could think of was that datum was being passed in as a reference, so perhaps that would mean new_node would be sharing the same datum (same location) as the object from which it is getting the datum from? I am not sure why we are passing in by reference either."|10|0|private|Your logic seems correct to me. Can you make clean and remake the exe? If you did not make clean and remake, the new cpp file won't match the old executable which may indicate the wrong lines where the code went wrong. Also, if you think you only called push_back() so this must be where the bug is, I encourage you to check the constructors and destructors because they are also called (implicitly).. . Typically we don't encourage student to put the code in Piazza and ask what might be wrong. You may get more help if you can join our Office Hours.||1
laalaxtph324zp|List Private Templating Test - Compiling Error|Hello,. I just submitted my ode but the private templating test is not compiling and I'm very lost as to what went wrong. Is there a way for me to figure out what I can possibly change with my code? . uniquename: syuchien. . Thank you so much!|6|0|private|In your insert function, you use the datum to check if the list is first or last. We cannot do this because the list is allowed to have duplicate items and not all datums (in the sense of being templated) can be compared. So to fix your problem, I would try to find a different way to check for first or last.||0
laaknepihxo3ee|question about Mutation Testing Suites|"I only finished half of this project, but I am confused why I still have a 0/21 on this test, and it said ""No test cases were submitted"". I do have some test functions for pop_front, pop_back, front, back, push_back, etc. . "|186|0|active|Your list_tests.cpp file is not compiling, so it is not running and it looks as if no test cases are being submitted.||1
laajlt925p41g2|How to call list copy constructor in list tests|I'm trying to test the copy function and my custom overloaded constructors using this test(copy) but I don't know how to call the copy constructor such that ListB is dynamically allocated. I am getting the double free or corruption error, which usually indicates that it needs to be dynamically allocated. I've tried something like List<int> *ListB = new List(ListA); and List<int> *ListB(ListA) = new List<int>; and scouring the internet, but I can't figure it out. I've also attached my constructor/copy function in case there is something wrong with that which is causing the error..  . |4|0|private|First off, you don't need to dynamically allocate your lists. If you are getting a double free error, that means your code itself is not handling its data properly, most likely in the destructor.. . In general, seeing a double free does not really mean that you need to dynamically allocate something, it just means you are deallocating something multiple times. You should modify what you have to only deallocate everything exactly once.. . If you are curious, though, here's how you would invoke the copy constructor:. . List<int> *l1 = new List<int>();. // Do some stuff with l1.... List<int> *l2 = new List<int>(*l1);. You need to dereference the list you want to copy because the copy constructor takes in the list object itself, not a pointer to one.||0
laahr0qqxa2774|should our test.cpp also contains tests for iterators?|As the question desribed.|120|1|active|Yep, iterators are a part of the List.h file, so you should write as many tests as you think you need for those.||0
laahkagr9oh5a4|Insert function yielding memory leak|. . Hello! It seems like my insert function has been yielding a memory leak. I've spent a lot of time going over the code and making sure that I'm no leaking any memory. I have deconstructor that pops_back every single node and asserts that the List is empty. It's just whenever I call insert, I get a memory leak. Any tips or ideas?|7|0|private|Mark as resolved.||1
laagrymp557d9|Copy Ctor test|Should we write a test for the copy constructor or will this not be a bug in the private tests on the autograder?|169|0|active|Please consider having tests for all the functions you are able to do so for.||0
laagbpwtwex6r0|Autograder, No test cases submitted|When I submit my List_tests.cpp it says that I submitted no tests and gives an exit code of 2. Any idea on how to fix this?|4|0|private|Your list_tests.cpp file is not compiling, so it is not running and it looks as if no test cases are being submitted.||1
laafnm0wrz74b0|destructor test|Just a quick question, is there a way to explicitly test the list destructor or does it automatically do it on its own? Thanks!|222|0|active|You should avoid calling the destructor explicitly, but if you take a look at when your destructor triggers itself (automatically), you can write other tests in a way where the destructor will perform its operations to clean up.||1
laafibkftim34g|test cases not submitted|I am confused why my test cases aren't being submitted. |140|0|active|Mark as resolved.||2
laadzzlbps46gv|resolved|I just figured out, thanks|4|0|private|Resolved ||0
laacy6dgv264ru|How can I understand the word this here|As the picture below. |114|0|active|"""this"" is basically the class object pointer here. In this case, we are just returning the iterator object for which it's member variable node_ptr has been ""incremented"". "||1
laa7e987gzi70v|can i add a member function to the list class as a helper function?|Can I add a member function pop_all() to the list class as a helper function for the destructor, the copy ctor, and the assignment? I don't want to break the interface but I want to avoid duplication in implementing the big three, so I am not sure whether I can do that. |156|0|active|clear() would perform this||1
laa63epkszo4b6|Iterator is undefined|"My partner and I are writing test cases. We are trying to declare an iterator but we're getting an error that says ""identifier ""Iterator"" is undefined"". We have include ""List.h"""|144|0|active|Do you have the scope operator before it?  Such as: List<type>::Iterator ||1
laa4kjesl05mj|First and last for single element lists|If a list has only one element, should both first and last point to that element?|69|0|active|Yep! If there is one element then first and last should both be pointing to that single node.||0
laa1wlpmq203e|re-definition error except the re-definition is the definition itself|literally what is happening here. i went to virtual office hours and neither of the two AI's we talked to know how to fix this. . |75|1|active|...Did you modify/remove the include guards? Because that's the only way I could see a double definition error is through doing that. Your List.h file should start with. . #ifndef LIST_H. #define LIST_H. and end with. . #endif. If you remove those (which the default file tells you not to do) then it's possible for a definition to repeat.||0
la9zfmkd3rf7iv|memory leaks for AG but not for Xcode/terminal|I have enabled my address sanitizer for both Xcode and for compilation at the terminal, but I'm having trouble using the visual debugger to find the memory leak because the memory isn't leaking on Xcode, only on the Autograder. Has anyone experienced this problem/has any tips for debugging (I have tried running though CAEN and still no errors)?|173|0|active|I'm not sure why these errors are not coming up on your Xcode, but after taking a look at your autograder submission I think I can give some guidance on what's going wrong.. . For the leak happening in erase, you should not be using the new keyword in the erase function. You are creating an extra node when one should be deleted.. . For the leak happening in push_back, it seems your pop_back function sets last = nullptr then tries to delete last. You will want to delete last first.. . I hope this helps!||0
la9wbcqt9mm5us|Assignment Operator for Lists between types|How should the assignment operator behave for lists if List<int> a and List<double> b. Is this undefined behavior or can a =b or b =a? |121|0|active|The assignment operator assumes that they are of the same typename, so a = b would be undefined behavior.. . In fact, the compiler would very likely not even allow this - as when the compiler instantiates templates it will effectively create something like this:. . class List<int> {.   //....   List<int> operator=(const List<int> &rhs);.   //.... }. . class List<double> {.   //....   List<double> operator=(const List<double> &rhs);.   //.... }. As you can see - there is no declaration of operator= for something like List<int> = List<double>. Thus, the compiler will say that you can't even do a = b.||0
la9tu346lsx6y4|make style displays weird errors|I don't understand what these errors mean. On line 204, I have the Iterator begin function where I return an iterator pointing to the first node in my list as shown by the lecture notes. Can someone please explain what this means?. . |108|0|active|The error is telling you that make style could not be run due to the compile error on line 204 of List.h.. . You are attempting to access the 'first' private member variable of List from within Iterator, and recall that the friend declaration will only give List access to Iterator's private member variables (not the other way around). I would double check whether the function you are calling 'first' from should be defined in the Iterator class.||0
la9t74jghl12ii|Overloading|what does it mean to overload operators?|117|0|active|"Overloading operators is really just altering the way that operators work for objects that do not normally use those operators. The operators like ++ and -- make sense for integers (where they increase or decrease the integer by 1), but in terms of nodes, there is no preset function to do that. In project 4, there is a ++, --, *, and != operator for iterators, so it is up to you to figure out how to implement these overloaded operators to work for iterators (almost all of these are already implemented for you in lectures 16-17: linked lists- iterators). . . Also, overloaded operators are covered in one of the earlier lectures I think (I've been trying to find the lecture for like 10 minutes, but I can't seem to find it. But I'm pretty sure it's there somewhere). There are also a lot of resources online that are helpful (just search up ""Overloaded operators c++"").. . Hope this helps :)"||0
la9skkqccmr3at|Iterators|For iterators, do we only use ++, ==, and !=?|152|0|active|Please note the following comment on line 86 of the starting file for List.h:. . ```. Your iterator should implement the following public operators: *,. ++ (prefix), default constructor, == and !=.. ```||0
la93ncr4sk53ip|How to access next and previous pointer elements of the node that the iterator is pointing to|Im trying to write the erase and insert function but i cant figure out how to access these elements.|186|0|active|I think you can try this: `itr.node_ptr->prev`||0
la93bnmeg266if|how are nodes stored|I noticed that only first and last nodes are stored, so they are the only ones that appear in the debugger. I'm worried this leads to losing data. Are we supposed to create another variable that stores nodes in between first and last? My iterators increment from first to last and nothing in between.|110|0|active|You shouldn't have to create another variable that stores the node between the first and last node pointers because of the way that linked lists function. Linked lists will allow you to access and traverse forwards and backwards between the different nodes through the Iterator interface. Check if there is any problems with implementing your ++ operator for the iterator class.||0
la91q2o96hp7n5|autograder disallow lib confusion|4841667961642_.pic.jpg. 4861667961673_.pic.jpg. when I uploaded my files, I got these three errors. Does it mean that we should not include <cassert>,<iostream> in List.h file? In this case, how can we check the REQUIRES?|63|0|active|are you including <algorithm>? It's saying that it might be including that library, which is not allowed.||0
la91n2dp1z029t|Erase and Insert|For the erase function, if the iterator is pointing to the first or last, I'm calling pop_back and pop_front. Is this the wrong way to go and the functions are independent of each other? When I'm testing my code, it keeps saying that im trying to access deallocated memory and I'm not sure where to go from here...|279|1|active|I am getting a similar error. For my erase function, I am trying to access the prev/next pointers in the prev/next nodes. After deleting the node between them, they should still be doubly linked by the prev/next pointers.. . However, in my erase function, I am unable to access these members within the Node (I believe I am getting the exact same error you are).||1
la8ytxp3w414br|Some confusions about operator in Big 3|"As the picture attached below, ""this"" is a pointer, and &rhs means the address of object rhs. If (this==&rhs) just means the pointer points to rhs => they are the same thing?. "|80|0|active|Yes, it means that the pointer `this` is pointing to the same object that `&rhs` is pointing to. Which also means that the object this is being run from is the same object as `rhs`.||0
la8qr2zkbtg2lp|Compiler Not Giving Errors|"My compiler doesn't put squiggles under errors or show error messages next to obvious errors, for example it allows me to write statements without a "";"", allows me to declare integers as string types, and the only way for me to see these errors is when I compile. I have tried uninstalling the C/C++ extension, I checked to make sure ""Enable Squiggles"" is on, I have deleted the project and created a new one, among other things. I went to office hours and they were unable to tell me what I should do. Has anyone else had a problem like this and what did you do to fix it. I can't work on the project without compiling every few minutes to make sure there is no errors. Any help would be appreciated. "|109|0|active|||1
la8pefqi8rb1ua|Default constructing node segfaults|When I initialize a new node, my code segfaults and I am not sure why.. . This is how I am initializing a new node:. . Node \*n = new Node{};. . Since this is the recommended way in the FAQ, I am not sure what is happening here. Visual debugger confirms it is this line that segfaults.. |79|0|active|Based on autograder submission, marking as resolved.||2
la8p6myln8g2j8|Deep copy for first/last|Since nodes are private member variables, how do we create a new node based off a node that already exists in a way that lets us deep copy? We can publicly access a pointer to a node, but how do we access the nodes data after that? Are we just copying the same datum not the same prev/next?|110|0|active|"You would want to just copy the datum into a new node and add that to your ""this"" list. There are already functions for adding elements to a list (push back/front) which should take care or first/last.. . Copying the prev/next would make it a shallow copy, because the new nodes in the copy list would be pointing to the nodes in the original list."||0
la8p3pk4cct4d3|Lecture 17 and p4|Are the matarials from lecture 17 covered in project 4? |67|0|active|Yes. Lecture 17 is on iterators and how they work with linked lists. You'll have to implement the functionality of the iterator class for P4.||0
la8obnl6i3ne7|Is there a set up guide to working on the Caen computers on north?|Laptop screen was recently damaged and want to work on P4 more before it gets fixed. I have all my work uploaded to gitlab and work with vs-code using the debugger with ubunutu off windows. What would I need to do in order to work off the CAEN computers on my project? |63|0|active|I think the CAEN computers should have already vs-code and WSL installed. So you should just be able to clone the repository and work on it! Sorry to hear about your laptop :(||0
la8nwe5xncq10h|Pop_front() runtime error|I am confused why my code is causing a runtime error.. |4|0|private|I would consider what should happen with the 'last' pointer in this function.||0
la8jxwkvcs679u|Does Iterator need a dtor?|I had memory leaks in my test cases and I realized I needed to add a dtor to List and that solved a lot of them but there are still some left.. I was wondering if it was necessary to add a dtor to Iterator, although I am not exactly sure how to write one. . . Thanks! |233|0|active|A destructor for the iterator class is not necessary. If there are still nodes that are not being deleted, that might be due to an issue in one of your pop functions, destructor or maybe erase()||0
la8jqdmcp4ueb|Heap use after free|. When I test my erase function I get this error. I am unsure if this means that there are issues with size(), pop_front(), erase(), and push_back() functions or if this means something else.|211|0|active|It looks like you are using memory after it has been deleted. I would take a look at your erase function, and make sure that the pointers are being assigned in the correct order, when removing an element in the middle of the list. I'd also double check that the size is being decremented in the proper places.||1
la8if0uyrd8261|List_compile_check|resolved|65|0|active|Resolved||0
la8i4fv4oyr1k9|List compile test|So whenever I run the compile test we were given its as if it gets stuck after the last 42 is printed out, idk why. I always have to kill the terminal after it thats why you see an ^C at the end. Any help on this?. |6|0|private|I would recommend putting breakpoints inside of the list_compile_check.exe and see at which step it get stuck in an infinite loop. One thing to double check is that you are incrementing/decrementing list_size in the various push_back/insert and pop/erase functions as needed. Because, if you use list_size as a condition somewhere and it doesn't get modified properly it could cause an infinite loop.||0
la8fii5du736ko|List Private Templating Test Fail|Got this error and for my most recent autograder submission. . I saw another piazza post where a student had the same issue and was asked for their uniqname. My uniqname is hafoster if that is helpful.|14|0|private|Looks like you solved this on your own - as you probably realize, you were trying to assert the dereference of an iterator (which is of type T and might not always be interpretable as a bool) instead of the pointer (which is what you want anyway).||0
la8f61hyhwm5i|Testing with typename code|When you write tests for typenames where there could be different data types, is it enough to only test one and assume every variable type works? Or should I write tests in different variable types?|94|0|active|I think it could be beneficial to write a few tests with different variable type, but I don't think your tests need to revolve around this. I'd focus more on the edge cases of the different functions.||0
la8dg01v6cn5ul|Angelagz?|"Autograder says we need an additional file named ""Angelagz"" which wasn't there yesterday. Just wanted to make sure everything was good. "|48|6|private|Thanks for letting us know! It shouldn't have been there. It should be updated now.||0
la8crr938f57ep|Question about reusing iterators|Hi! I am wondering if there might be situations where an iterator variable is used more than once. For example:. ```c++. .... List my_list;. . my_list.push_back(1);. my_list.push_back(2);. my_list.push_back(3);. . List::Iterator itr = my_list.begin();. my_list.erase(itr);. my_list.erase(itr);. .... ```. For the code above, the itr is used twice. Do I need to implement my functions so that the code above won't crush?|186|0|active|There are cases where you will reuse an iterator more than once, for example with insert or dereference:. . . . List<int>::Iterator it = list.begin();. ASSERT_EQUAL(*it, 1);. ++it;. ASSERT_EQUAL(*it, 2);. ++it;. ASSERT_EQUAL(*it, 3);. ++it;. list.insert(it, 4);. ++it;. list.insert(it, 5);. .... . However, specifically for the erase function this behavior does not make sense. To understand why, I would take a look at the RME for the erase function and the iterator operator RMEs, and ask whether you can perform any operations on an iterator after it has been erased.||0
la8avhgq7662ac|populating last?|In regards to adding a node to an empty List, should I populate last when I do push_front ? Should I populate first when I push_back? . . I am having a bit of trouble with this part because if I have to I am not really sure how to update the last's prev pointer for push_front unless and updating the first's next pointer for push_back. I might be populating both of the pointers wrong in the first place.|101|0|active|I'd recommend having a separate case in both the push_front and push_back that deals with the case where the list is empty, where you can change both the first and last pointers accordingly.||0
la7r7wkipvw158|List Private Templating Test not compiling in autograder|Hi, the List Private Templating Test is not compiling and is instead returning a value of 2. Could you potentially describe what the issue is? I am assuming it is associated with some kind of a return of the template type that isn't doing so correctly? Maybe you could direct me and my partner to the malfunctioning member function?. . We also noticed an error in List_compile_check where our destructor is failing at the end of the entire main being unable to delete victim for one of the lists. Could this be the issue?. . Thank you!|6|0|private|"I believe this issue is coming from your statements where you are saying ""assert(*i)"" such as in line 281 in List.h. This is because i is an iterator, and you've created a function that overloads the * operator for an iterator, which returns a type T. The compiler doesn't know how to handle this because since it's returning any generic type T, it's not guaranteed to be a boolean, which is what assert() is looking for. "||0
la7q7vohfnk3fq|List_Compile_Check aborted follow up|I am still having trouble debugging this issue where my program crashes when I try to run List_Compile_Check.exe, saying. . free(): double free detected in tcache 2Aborted. . I am pretty sure the problem is happening with the destructors when they call pop_all(). I can confirm the problem happens when the second destructor is called. Since destructors are called in reverse order, it seems like list4 gets deleted with no problem but the program crashes the moment it tries to call pop_all() for list3. . I have submitted my code on autograder. Could I get some assistance? |150|0|active|It looks like your deconstructor and pop_all() function is set up correctly. Often times in this project, a bug in another area of the code may set a pointer to incorrect memory which then causes another function to fail. It looks like in your code you use first == nullptr to determine when the list is empty. If you empty the list and then don't set first == nullptr any where in your code, the empty check will fail because when the first element is deleted it doesn't automatically set the address to nullptr. This could be causing the error you are getting in the destructors because the program eliminates all of the nodes but does not evaluate to empty.. . Try using your visual debugger to make sure that all the pointers are set to the correct addresses.. . Hope this helps!||0
la7nna3jgxl3yf|stuck on finding last bug in autograder|My partner and I have been to office hours a handful of times since last Monday, trying to find one last bug. We have been at 48/49 since the 31st.We made tests that use functions individually or all together, clever edge cases, etc., and are open to suggestions/insights.. . |218|0|active|I would first make sure that you have tests for all List/Iterator functions and operators (including the List big 3 and iterator operators). Then I would focus on testing edge cases for the functions that required the most implementation on your part (i.e pushes, pops, insert, erase). You may find that these functions have different cases based on if branches in your implementation. Make sure that you have tested all of the different paths that your code might go down within these functions' if branches. ||0
la7l13cxtg2il|Iterator begin() function error|I get the following error for Iterator begin() when I run List_compile_check.cpp, and I’m not sure what it means. Here is the error:. . . undefined reference to `List<int>::Iterator::Iterator(List<int>::Node*)'. Since this function was given and I didn't edit it, how do I fix this?|106|0|active|The begin function is implemented for you, however it calls the iterator constructor, which you have to implement. It seems like the computer can not find the iterator constructor (or the constructor has the wrong parameters). ||0
la7kellkm737g4|How to test for copy_all|For my test cases for copy_all, I am making two lists: List l1 and List l2. I am pushing back a bunch of values and when I am trying to use the copy_all like this - l2.copy_all(l1), I am getting an error stating that it is inaccessible. How do I go about solving that?|310|0|active|Since the purpose of `copy_all` is to be used in the big 3, you can implicitly test it by testing the big 3, i.e. the overloaded assignment operator and copy constructor||1
la7iidhhod11u9|difference between overloaded assignment operator and copy constructor?|Is there a difference between what these two functions are intended to do? Should one make a deep copy while the other makes a shallow copy? Or are they identical but differently implemented and we can pick which we use? |144|2|active|They are two different functions with two different purposes, and when implementing the big 3, both must be implemented.. . The copy constructor is called whenever you **initialize** an object with another object:. ```. List list1;. List list2 = list1; // Copy constructor called. ```. The assignment operator is called whenever you set a **pre-existing** object equal to the value of another object.. ```. List list1;. List list2;. list1 = list2; // Assignment operator called. ```. Both must work properly and use deep copies to ensure the data is properly copied over between lists.||0
la7hwhd181o4ek|List_Compile_Check aborted|My program crashes when I try to run List_Compile_Check.exe, saying. . free(): double free detected in tcache 2Aborted. . What does this mean?|95|0|active|"Check out Lab 8 slides: ""Double Delete: deleting a previously deleted dynamic variable will throw an error""."||0
la7fznq46a24zz|Is this a correct output for the copy constructor?|I think I am generally confused on the concept of a deep copy.. For list, I have gotten this output for my copy constructor. . (list1 is the first list, list2 is the copy) Should a copy constructor create a list that points to the exact same nodes, or a new node with the same datum?|141|0|active|"We want our copy constructor to make a deep copy so we need to make new nodes. Since we are modifying ""this"" in the copy_constructor, we can call functions that we have already written (push functions) that take in a datum value and add new nodes to our current list.. . If the new list you've created has the same data in each node, then your implementation's output seems correct."||1
la7ft54qbne1gp|Iterator Function Stubs|Where is my function stub for end() going wrong?. . |120|0|active|The end() function should be a member of the List class, not the List<T>::Iterator, so be careful how you are using the scope resolution operator here.||0
la7ehn761ah3vj|Compile Check Error on Laptop but not autograder|. Hi I get these errors when I run the List_compile_check on my laptop, but the files pass all the compile checks on the autograder. Does anyone know why there might be an issue on my MacBook but not the autograder?. Thanks|105|0|active|Looks like you've got a memory error. Specifically, it looks like somewhere, you did a bad delete or double delete. I'd reccomend stepping through your debugger to see where that's happening.||1
la7c0dbiill7f2|Autograder Not Finding Student Test Cases|"When submitting my project (List.h & List_tests.cpp) the autograder is not picking up on any test cases I submit. When looking under the Mutation Testing Suites it writes ""Exit Status: 2...No test cases were submitted."" even though I submitted my List_tests.cpp file with code in it. My List.h compiles and so does my List_tests.cpp.. . . This is the beginning and end of my cpp file.. . . // Project UID c1f28c309e55405daf00c565d57ff9ad. . #include ""List.h"". #include ""unit_test_framework.h"". . using namespace std;. . // Add your test cases here. . {My implementations of test cases}. . . . . TEST_MAIN(). . . . If you need to see the rest of my code, I have attached my List_tests.cpp below. . List_tests.cpp"|6|0|private|"This is because your List_tests.cpp is causing a compile error. I would try running ""make List_tests.exe"" locally and fixing any compile errors to resolve this issue."||1
la7ar7bxjbr3ck|Testing operator= in List.h|"I have written most of the test case for operator= but I am having trouble calling the actual function when I try to use ""ASSERT_EQUAL."" Does anyone have any tips on how I might be able to successfully do this?"|161|0|active|ASSERT_EQUAL(a,b) would call a==b which we haven't overloaded for lists.. However, we can use iterators to do that. For example, we can have it1 for list a and it2 for list b do ASSERT_TRUE(i1==i2) or ASSERT_EQUAL(i1,i2)||1
la78qp21tkf5yn|Compiler not giving syntax errors|My compiler is not giving any syntax errors and is allowing me to do stuff like this. |16|0|private|Try CMD + SHIFT + P, then search for C++ Intellisense - Enable Squiggles (might be a little different) and make sure it's set to true.||2
la77r929yt11i|destructor for list|"Do we need a destructor for list? I initially created one but I am getting ""double free detected"" error during some tests that goes away when I remove the destructor. "|134|0|active|Yes, you should have the big three for List. Check to make sure you're not deleting memory elsewhere where you shouldn't be.||0
la749lfc1f3ob|Insert and Erase|Hello,. . I was wondering if my insert and erase functions have to cover when there are no elements in the list? Furthermore, I was wondering if my insert function has to be able to insert one after the current iterator (similar to the push_back() function). Any help would be appreciated :)|229|0|active|"Looking at the requires clause for erase, the iterator must be. dereferenceable, which is violated with an empty list. The insert requires clause doesn't specify this, meaning it should be able to handle an empty list.. . Also, looking at the RME for insert, it ""inserts. datum before the element at the specified position,"" not after."||0
la71rqxes1ltd|Memory Leaks|Hello, I am getting that there is a memory leak in my push_back and insert functions even though i delete the node is both of my pop functions, I was just hoping you could help clarify why I might be getting this leak?|209|0|active|I would make sure that in all of your functions that remove nodes (i.e pop_front, pop_back, erase), there is no way the function returns without having called delete on a node pointer. If this is already the case, you may be deleting the wrong node pointer in one of these functions. I would step through with your debugger to see what is getting deleted when to resolve this.||0
la70i82ufge1d4|copy constructor infinite loop|I am having an issue where the copy constructor in list.h seems to be stuck in an infinite loop. I am copying the 'first', 'last', and 'list size' from the 'other' list in the constructor member initializer list.. then I am calling the copy_all function. My copy-all function seems to work fine when used as a stand-alone function though. So using the debugger didn't help either. Am I doing anything wrong? Am I supposed to use the copy_all in my copy constructor? Any help would be appreciated.|154|0|active|If your copy_all function modifies first, last, and list size for the List object you are trying to construct, would you want to set the member variables of this constructed List object to other's member variable values before you call copy_all?||0
la6zx6sbxs25v2|errors in Link_compile_check.cpp|When I try to run make List_compile_check.exe, I get a lot of errors in the List_compile_check.cpp file. Any idea how I can fix this?. |119|0|active|Adding on to student answer - make sure you have at least a function stub implementation of == and != for the iterator class. If you're implementing outside of the class, make sure you use the template typename syntax along with `List::Iterator::[your function name goes here]` and not just `Iterator::[blah blah blah]`.||0
la6729r6euq9z|Defining copy_all outside the class and accessing the Node struct|"Hi,. . My partner and I are defining the copy_all function outside the class. We are trying to do it by using a traversal by Nodes, using List<T>::Node *np. However, when we do that and create a for loop, any time we refer to the variable np, we get an error ""undefined reference to np"". We are very confused about this error. If we copy the same exact code within the class, everything works fine. Does anyone know why this error occurs?. . Thanks!"|124|0|active|Copy all needs to be inside of the List class. Try using the List:: scope resolution operator if you want to define it outside of the List class.||0
la64uhygdks3vf|How do you test an iterator?|Currently trying to debug my code but I not sure what a sample test would look like for project 4 with respect to testing iterators.|3|0|private|Take a look at List_compile_check.cpp.||0
la5xzc1xeh46vw|My for loop is infinitely running for copy constructor|This is my code for the copy construct and when I cut next it is not equaling the nullptr it is equally another place in memory and I can not figure out the problem|5|0|private|It might have something to do with your other functions, such as any that interact with the `first` variable. Make sure that the ends of the list always have null pointers (i.e. `first->prev = nullptr` and `last->next = nullptr`), and make sure first and last are similarly nullptr when the list is empty.. . It'll also help to know what test this is happening in. Can you post a screenshot of that as well?||0
la5uf0n4h2380|Student list tests on autograder|Do these bugs/points also come from iterator? Or is it just from the list class|133|0|active|The iterator is part of the list class, so yes, bugs can be found when using iterators too.||0
la5rkxu0ba54tg|What condition to use when iterating through a list|Hello.. . For all of my loops through lists, I am struggling with undefined behavior because the condition is not stopping the loop when I would want it to. When I iterate using iterators, end() != an iterator is never true, even though end() is defined using a nullptr. When I iterate by pointer, checking that the pointer is not null still does not stop my loops.. . When I look at this in the debugger, I can see that the iterator is pointing to a null object and that the for loop condition should be true. However, it never stops.. . The only way I have been able to iterate is by using the size variable. Is this acceptable for this project? If not, why might this be happening?|170|0|active|> When I iterate using iterators, end() != an iterator is never true, even though end() is defined using a nullptr.. . When you finish iterating through the list, the iterator should be equal to `end()`. As the students' answer suggested, check your iterator implementations to ensure that this actually happens.||0
la5p0gksfwv4j4|Compile error|My partner and I implemented the functions that are described in lecture and in the lecture notes. We haven't been able to compile and at this point we don't know why.|115|0|active|I believe the solution here lies in the scope resolution operator. Try to remove the List<T>:: in front of the function definitions, especially if the functions are inside the scope of the List class.||1
la5i7zrjwhi3lm|Clarification on &#34;List::Iterator i&#34; in insert and erase|what exactly is List<T>::Iterator i? I know it's an iterator object but what is it declared as in Main to in order to make it access the addresses of specific things in the list? . . The way I did it is I set a List<T>::Iterator it = list.begin() and used the increment operator on it to traverse the list using a for loop but I don't know if that is good practice for this circumstance.|216|0|active|I think the RMEs associated with the insert and erase functions in List.h should provide some clarification here. The Iterator i which is being passed in as a parameter to each function has slightly different properties based on the REQUIRES clauses, but ultimately is an iterator that we guarantee will be pointing to a valid object within our List when insert or erase is called. As the student answer suggests, you should be able to utilize the fact that an iterator can reference the next and prev elements in our list to help you achieve the desired behavior of these functions.||0
la5hqeazu8n19a|Memory Leaks|I'm getting memory leaks for my push_back, push_front, and insert functions. I create a new node and this can't be deleted because it becomes a part of the list. I'm not sure how I should fix this because it is reflecting in my lists tests and lists.h|205|0|active|Memory leaks in push_back, push_front, and insert functions mean that you created the node in these functions and never delete them when the nodes get popped out.||1
la4vvn32qzm783|operator==|"When trying to overload the Iterator operator==, I declare the function as such:. . . bool operator==(const Iterator* lhs, const Iterator* rhs){.       .... }. . . but the List_compile_check.cpp does not recognize the operator==, and it says ""no operator matches these operands"", even for the comparison between two iterators. What am I missing? Is the function supposed to return something different than a bool? . . Also, should I declare the parameter types as a (const T* lhs, const T* rhs) from a template<typename T> to accommodate for other pointers of different types or should I declare three different operator== functions?"|198|0|active|operator== is going to be a member function in Iterator so it only takes in one parameter. You are trying to compare `this` with another Iterator.||0
la4s2lp89q31ha|Linker command error|Whenever I add friend class List, I receive this error and I don't understand why. . . |8|0|private|I believe its because you are missing function definitions in your List class, outside the Iterator class.||0
la4nsua1vp44qk|clarification on where to write code|"""This List also contains an iterator interface.. Do not modify the public interface of the List class. Implement a doubly-linked list."" . . Do we write functions for both the List class and the Iterator class? In the specs, what is the public interface that we are not supposed to modify referring to?. . edit: I think I understand now"|159|0|active|Yep, you write all the needed functions for List and Iterator. You'll know when you've got them all when List_compile_check has no errors and compiles and runs properly. . . The interface you're not supposed to modify is the general implementation of List, so don't change, for example, the function header for size or front, just write your own implementation for those interface functions. There are some sections that tell you specifically to add things, so for those cases you can go ahead and make those additions.||0
la4nce2mhx33tx|Memory Leak in push_back function|We have no idea why we are experiencing a memory leak, code is implemented almost exactly as shown in class examples with some added precautions on our part. Please let us know if there is anything we can do. I have linked the files below. We also used Valgrind which showed no errors in comparison to our normal address Sanitizer, please get back to us soon.. . List_tests.cpp. List.h|4|0|private|A snippet of your code in `pop_back()` below:. ```. if (first == last){first=last=nullptr;}.   else.   {.     Node *back_pop = last;.     last = last->prev;.     delete back_pop;.   }. ```. Try to think about what the list will look like when `if(first == last)` is true. Is there anything you forget to delete?||0
la4hjw279458|Making test cases for the copy constructor|What are some ideas on how to implement test cases for the copy constructor? So far, I just check if the size of the original and copy is the same, but I was thinking of doing a more in-depth check.|155|0|active|You could try using `List::front()` and `List::back()` to check the actual values that were copied.||1
la4g1x0lu363wo|Segmentation error|I am getting the same issue as @3282, but my last pointer is being set to a nullptr. My sanitizer is returning a null pointer reference, but I'm confused since I already have it set to that. Is it in the wrong place? I have included a screenshot of my push_back() function below.. . . |55|0|private|I would strongly recommend that you step through this program with your debugger. It should be much easier since the address sanitizer should tell you where in the program your bug is.||0
la4fkt0yhxg3zq|Expected Behavior When Using List::begin() on empty list|I'm currently writing a test for `List::erase()`, and while thinking of ways to check if the `List` has been correctly emptied I considered using `List::begin()` to see if the `first` variable has been changed. . . However, I noticed that the RME for `List::begin()` doesn't specify how it should work on an empty `List`. Would it return an `Iterator` pointing to `nullptr`? Should it even be called at all if the `List` is empty??. . I already used the debugger to inspect the variables, but I'm curious if this could still be done in `List_tests`.|4|0|private|When the list is empty, then `List::begin() == List::end()`||0
la4fgi7f97e5aq|No operator matches these operands|"I am testing for my iterator operators; when I write i++, I got a compilation error ""no operator ""++"" matches these operands. But I have already defined it in List.h. But ++i works! "|132|0|active|Student answer is correct. `i++` fails because we only have you implement the prefix operator.||0
la4e2uzni5w71j|size()|how do you keep track of the size of a list using a private member variable? when I return the private member variable size that I made in the size function it doesn't return the proper size for my test cases.|163|0|active|If you have a private member variable keeping track of the size, you should be updating that member variable whenever the size is affected. For example, in pushback and pushfront, you are adding a node and therefore should be increasing the size by one. Similarly, when you popfront and popback, you should be decreasing the size by 1||0
la4b0v1gbj2mj|Undefined behavior|I just tried submitting to the autograder after writing some tests for list and all my tests passed, but I got this error on the autograder. What does this mean? . |202|0|active|You might have forgotten to delete something created with the keyword new. ||1
la49w470r991fo|For loop causing infinite loop|I used the template in the lecture for my for loop when copying over one List to another and I am getting an infinite loop, any tips? |133|0|active|If you're using the copy_all function and getting an infinite loop, I'd double check that the next value of your last node in the list is properly set to nullptr. Otherwise, what I suspect is happening is your loop never finds a value of nc->next that equals nullptr, so it runs forever. . . What's a bit confusing, though, is that it loops forever instead of just segfaulting when it tries to get the datum of a null pointer. I'd definitely check the next value is properly set as your first fix, but there might be a second issue as well if that turns out to not be the cause.||0
la49fvl8zrw5p7|Setup Function Stubs|What does the. . Start by copy-pasting each function prototype from the class declaration at the top of List.h to the bottom of the same file. . tip mean? Do I copy and paste the whole class to the bottom of the file?. |96|1|active|Just the functions! It would be similar as to writing the functions in a cpp file, but you are doing it at the bottom of the h file. You can also just directly write inside the class if that's easier for you||0
la47ml328co2gr|trying to test for list self assignment test case gives false positive|. // TEST(self_assignment){. . // //try assigning a list to itself. . // List<int> list;. // list.push_back(6);. // list.push_back(5);. // list.push_front(4);. // //4 6 5. . // List<int>::Iterator i1 = list.begin();. . // list=list;. . // List<int>::Iterator i2 = list.begin();. . // ASSERT_EQUAL(list.front(),4);. // ASSERT_EQUAL(list.back(),5);. // ASSERT_EQUAL(list.size(), 3);. // ASSERT_TRUE(i1==i2);. . // }. This was my test code. I feel like self assignment is an important case to test for but I don't know how to do it when the list = list line is giving an error. How can I test for this?. |10|0|private|Please include your unique name in your piazza profile so that we can look at your code. @6||0
la468b3je3m154|Iterator constructors|Why are there 2 constructors for the Iterator class? Is the one declared as private supposed to be called as a helper function for an Iterator function?|122|0|active|The Iterator constructors are private because you are not supposed to call them directly. They should be used by other functions in the List/Iterator class.||0
la455aviavk2ig|pointer not being allocated error when testing/debugging|"Hi, I was testing my pop_back and pop_front and I got ""List_tests.exe(9879,0x102710580) malloc: *** error for object 0x13b606d80: pointer being freed was not allocated"" when testing pop_back. However, pop_front seems to be working fine and I based both functions off the lecture slides, so I'm confused on how to fix it. I was wondering if anyone had ideas or ran into similar issues. Thank you!"|141|0|active|You're trying to delete something that was either already deleted or not created yet. Check if the pointer is pointing to the right position :(||0
la44skr13dl2x5|Inserting a node in an empty list|When we call the insert() function on an empty list (where node_ptr is null), should it also modify the iterator's null_ptr to point to the first node?|134|0|active|There is no need to modify the iterator's note_ptr.||1
la3vz8cnxbn5xr|Seg fault for back() function|I am getting a segmentation fault in Line 37 of list compile check when the back() function is called, it does not do this for the front() function, any ideas on how to fix?|146|0|active|If you set up sanitizers (https://eecs280staff.github.io/p1-stats/setup_asan.html) and it reports a nullptr reference, you likely forgot to set your last pointer in the List class. If it's any other address, check that you're properly updating the last pointer when you remove elements.||0
la3hskru26rqq|Checking if Iterator i is valid|Hello! Would the following statement . . assert(i.node_ptr);. be the correct way of checking if Iterator i is valid? |119|2|active|That code would check if the iterator is a past-the-end iterator. However, there are several ways an Iterator could be made invalid. For example, if an Iterator is created at the beginning of the List and then pop_front() is used, then the Iterator has become invalid because the Node it points to no longer exists.. . Be sure to read the [course notes on iterator invalidation](https://eecs280staff.github.io/notes/17_Iterators.html#iterator-invalidation), which give a description of how this works.||0
la39eb7szw61n|Declaring functions outside of class|".   //EFFECTS: returns the number of elements in this List.   //HINT:    Traversing a list is really slow.  Instead, keep track of the size.   //         with a private member variable.  That's how std::list does it..   template <typename T>.   int List<T>::size() const {. .   };. .   //REQUIRES: list is not empty.   //EFFECTS: Returns the first element in the list by reference.   template <typename T>.   T & List<T>::front();. size() compiles but front() does not, giving me an error saying ""member function ""List<T>::front"" may not be redeclared outside its class"". . Why is this happening, and how can I fix this if I still wanted to implement my functions outside of the class definition?"|137|0|active|add:. {.    assert(false);. } . after T &  List<T>::front(). . instead of T & List<T>::front();||0
la307atmr3p1cw|Iterator constructor for list is private|Hello, I am trying to implement . . Iterator begin const(){}. by calling the constructor for Iterator and passing in this->first into the constructor, however, the constructor is private within the Iterator class. Is there a reason why that is? |123|0|active|I'm good now! Just define a friendship||0
la2yyva3g9n285|No selection for running tests on xcode|. Hi, so I'm trying to run test cases but when I go to the product editor/place to select which files to run, a blank screen comes up like this. I selected the product in scheme in this folder, but nothing comes up. When I run it, it runs the compile check but I'd like to just test my own tests. . . Thanks for your help!|125|1|active|Try to include your own tests in the compile source and remove compile check from it. https://eecs280staff.github.io/p1-stats/setup_xcode.html#compile-with-xcode||0
la2x9sumk4542o|Editing List.h|Do we just directly edit the list.h file? Do we make a separate .cpp file? Can we implement directly in the function headers or do we need to copy and paste the function headers at the bottom of the list.h file, and then edit these to add our implementations?|108|0|active|Due to it being templated, yes; your implementation is in the header file. I believe that you can either write functions directly or use the scope resolution operator. ||0
la2uj2ulmw5b8|List Private Templating Test not compiling in autograder|Just submitted to autograder and got this nasty error... what does this do?|154|0|active|Please include your unique name in your piazza profile so that we can look at your code. @6||1
la2r0ekaba34mb|How to Debug Undefined Behavior without Autograder|I ran into some Undefined Behavior in my test cases but I don’t know how to debug it on my end. Is there a way to check?Thank you!|101|0|active|"It's difficult to tell what is wrong by ""undefined behavior"". However, typically the error message would include more information like which file which line throws out the error. Likely, for this project, your undefined behavior may relate to dynamic memory."||1
la2n6nq6lmk6bi|erase not modifying the linked list|I'm a bit confused because I thought deleting `node_ptr` was enough to erase the node?|166|0|active|Remember that just deleting the node_ptr won't suffice when you want to remove a node. What happens to the next and prev pointers for the node to be deleted, as well as the ones that currently point to it?||0
la2lx48u6o772i|Iterator Tests|My partner and I are trying to figure out how to best test the iterators -- is there a resource we could turn to that demonstrates how they are commonly used? Specifically an example of how to declare an iterator?|146|1|active|You can check out the class notes on iterators for more information and common examples: https://eecs280staff.github.io/notes/17_Iterators.html#iterators||0
la1v6j5v82929h|Question on bad access error|I'm currently trying to write an implementation in List.h and I keep getting a bad access error when I try to do something similar to (last = something->next). I was just wondering if anyone had any tips on how to fix this or if I should be pointing in a different way.|106|0|active|This is usually an issue with dereferencing null pointers or pointers to junk memory. Try stepping through the code to see if `something` ever becomes null or invalidated at any point.||1
la1tsiuyj0d68g|Iterator Default Constructor|"I understand that the default iterator points past the end so it is a null pointer. However, I'm confused on how to make this useful in code because you can't really use null pointers with any of the iterator functions. I was thinking maybe you make the previous value for the node_ptr the last value in the list but that doesn't work because last is a private value. All I've done is made the default constructor create a nullptr but I'm getting compile errors so I think maybe I don't understand how we are supposed to be using this ""past the end"" aspect of the iterator. "|177|0|active|Marking resolved||0
la1sfg4y2gg1an|Memory Leaks|I'm getting memory leaks for every new node created even if I have a list destructor that calls clear()|178|0|active|This could be a number of things but it's hard to say without seeing your code. If you've submitted ot the autograder, can you change your name to include your uniqname so the staff can have a look? @6||1
la1ra1w9tob4nt|forward_list|I'm getting this error in the autograder. I haven't added any new libraries to my tests file, so I'm not sure how to fix itScreen_Shot_2022-11-03_at_8.24.04_PM.png|116|0|active|Double check your include section to make sure you are not including <forward_list>||1
la1oxt1xifm1dx|Additional Functions|SHould we be adding and implementing additional functions to use in our destructor such as pop_all?|118|0|active|That's the same thing as `List::clear()`||0
la1nz97mmx1ps|erase with a list of 0 elements|if we make an empty list called l1 and have an iterator pointing to l1.begin() and then call erase using that iterator should the list size stay at zero or go down to -1. or is this not a scenario we should consider? |177|0|active|You should not consider this scenario as this would be undefined behavior. Assume that you only ever erase on a nonempty list.||0
la1nudri9vf4ii|Editing header declarations in List.h?|Hello, I was wondering if something (not exactly, but the point is that I'm editing the function stub) is allowed for List.h or should we not edit any of the function stubs?. . Thanks!|125|0|active|Please do not change the function headers!||0
la1jo9m974t73z|Copy Constructor Seg Fault|I'm getting a seg fault when i call my copy constructor. Can anyone help me fix this?. . . My seg fault only happens in the command line and the autograder, it does not occur in visual studio.|7|0|private|The error means that you are accessing a pointer out of bounds, which usually means you are using nullpointers unintentionally.. . While the error may is technically coming from the copy constructor, it may be originating from somewhere else. If the push_back function has a bug in it, for example, this bug would show in your implementation of the copy constructor because it calls the push_back function. Have you tested the push_back function? I would suggest thoroughly testing that first before testing your other functions. . . If you still can't find your bug in testing, I suggest using your visual debugger to make sure all the nodes point to the correct location as well as going to office hours for more one on one help. The queue is very light this week!. . Hope this helps!||0
la1hrm3v9tx2j9|no operator != matches these operands error|I've been having trouble with an error that doesn't recognize my overloaded != operand for Iterators. Below is a screenshot of the error in List_tests.cpp.. Above the for loop is an explicit variable initialization of end and when I implement that, the error is gone.. . I've also attached the implementation of end() and != just in case there's something wrong with either of them.. . . Also I should note that this error doesn't appear if I do the same thing in List.h (it != end()). Any help is appreciated.|19|0|private|This should work......potentially try closing down your IDE and force it to recompile (sometimes it does not compile correctly). Where you able to fix it? Please followup if not!||1
la1f8vojois37a|cannot open a source file List.h|"I am getting a error in my List_tests and List_ public test under #include List.h. . . #include errors detected based on information provided by the configuration. Provider setting. Squiggles are disabled for this translation unit (/mnt/c/users/eecs280/p4-web/List_public_test.cpp).C/C++(1696)cannot open source file ""List.h""C/C++(1696)"|106|0|active|Are you able to run the code on terminal/on your debugger?. If not, make sure List.h is in the same directory as your test files. Make sure your VSCode is open in WSL, as well as try restarting VSCode, and possibly reinstalling Intellisense. Let me know if none of those directions help!||0
la1cyrja3tl1j1|first node prev|Node *first will point to the first node in the list and the first node will have a prev node. In this case, where does the prev node for the first node points to?|113|0|active|. nullptr||0
la1btbiqpvo2mf|insert function|How should we approach writing the insert function? I'm a little confused on this|228|1|active|For the insert() function, you want to consider 3 cases:. . 1 - you are trying to insert at the beginning of the list (you can probably just use push_front() here). . 2 - you are trying to insert at the last spot: (similar to 1 you can probably use push_back). . 3 - you have to insert somewhere in the middle between 2 nodes: you are basically going to have to think about how you can reconnect pointers, to be pointing at our new node. . Try this out and feel free to follow up if you have more questions||1
la1brdehrc54s1|insert function|"I'm a little confused about the insert function. When I create a new node (n) and set that equal to the node the iterator i is pointing to and then do . . n->prev I'm getting ""address points to the zero page."" I have an if statement that first checks if n->prev points to nullptr and if it does returns from the function so I'm not sure why I'm getting this error.. . "|143|0|active|Resolved||1
la1bkzkiuid43g|Autograder Submission-- says &#34;no test cases were submitted&#34;?|Hi. I was submitting my project 4 files on autograder, and the autograder says that I did not submit any test cases. However, I did upload List_tests.cpp that has ~15 test cases with the correct project UID, and it worked until yesterday. How do I fix this? Is this a bug?. . |9|0|private|"You have a few unused variable errors to fix in your List_tests.cpp. If you run ""make List_tests.exe"" you should see the warnings listed as errors."||0
la19bs6jc7f3xx|Implementations|Are we allowed to just implement the function definitions where they are instead of copy pasting? or is that bad style? It just is less confusing for me.|91|0|active|@3228tl;dr, yeah, go ahead (it even says so at the bottom of the code) if you want to, it can make life harder for complicated programs but for this one I prefer to do them where they are, I agree it's less confusing.||0
la17kmqkhn25xy|Compile Error|Hi im trying to compile my starter files but I keep on getting this error. I have already implemented the function stubs.. . Thanks!|108|0|active|Have you added anything to api.cpp yet? If it's completely blank I don't believe it will compile. You can edit your makefile to remove the line for api.cpp in 'make test' if you're just working on linked list to avoid this error.||0
la0qmqtmk1c12k|autograder question|"What does the ""1-5 matches"" mean in the autograder? It says - List_tests.cpp (1-5 matches) under what files to submit."|114|5|active|Just submit a single file matching List_tests.cpp||0
la0kxft684n529|First and Last Node Question|Since first and last are node pointers to the first and last nodes, does it make sense to use first-> next to obtain the first node? Or will first->next refer to the second node? |98|0|active|`first->next` would point to the second node. `first` is the pointer you'd use to just get the first element (index 0).||0
la0ku5z2p5v4lz|Delete keyword question|template<typename T>. void List<T>::pop_front() {.     assert(!empty());.     .     if (size_count == 1) {.         delete first;.         size_count = 0;.     }.     else {.         Node *delete_me = first;.         first = first->next;.         first->prev = nullptr;.         delete delete_me;.         size_count--;.     }. }. . Can I use the delete keyword on first? Do we assume it is declared as a new node using the new keyword? Otherwise, I'm not sure how we would be removing a node from the end or back for pop_front / pop_back |7|0|private|All nodes are added to the list with `new`, so when removed, they'll be removed with `delete`. `first` doesn't exist until you start adding elements to the list, at which point `first` points to a dynamically allocated `Node`||0
la0je0z2i304rd|Declaring constructors as a friend|"When declaring the Iterator constructor as a friend, I'm getting the error ""Must use a qualified name when declaring a constructor as a friend."" What does this mean? I was following the lecture notes on this pretty closely, so I followed the method that was used there. Any help would be appreciated!"|145|0|active|Without seeing your code, make sure that your class name is correct and that the scope of the friend class is actually inside the List class. Come to office hours if this doesn't solve your problem.||0
la0hyv1p3ubuz|Running List Compile Check|"Are we also meant to run the compile check for list? Or do we just ""make"" the file in order to see if it compiles? Because I think the compile check violates the requires clause for insert because it passes a null iterator when it calls insert on an empty list (line 36). So it compiles for me, but I get a seg fault when I run it."|267|1|active|"You can have an iterator to nullptr (""one past the end""). This will cause a problem for erase because you can't erase something that doesn't exist. You should have an assert to catch any errors on erasing an empty list.. . The compile check should pass....if it doesn't I would suggest using your visual debugger to make sure every node points to the correct things as it might be a ""silent bug"" as discussed in the followups."||1
la0hltgneql7f2|bug when overriding &#43;&#43;|"i am getting the following error message when using the overridden ++ operator: ""no operator ++ matches these operands."". . could someone explain how to fix this? any help would be appreciated, thanks!. . "|7|0|private|You have to do `++itr3` rather than `itr3++`||0
la0g8lotml6b1|Iterator Erase Function|What happens in the iterator erase function if the list is empty?, the requires clause doesn't require the list to not be empty but I'm not sure of the behavior of the erase function if the list is empty. . In general, for the erase and insert functions, what node should the iterator point to after running those functions?|248|0|active|By definition, the list cannot be empty if a valid iterator is passed into the function (the iterator has to point to a node inside the list which means the list isn't empty). You shouldn't change or modify the iterator at all (only modify the node it points to).||1
la0fiwygkx8oy|Defining functions inside classes|Just checking--is there any reason besides just style why we can't write all of our functions inside their class declarations in list.h? . For example, instead of. . template<typename T>. bool List<T>::empty() const {.   assert(false);. }. Can we just do. . class List {. public:.   bool empty() const {.     assert(false);.   }. .... . ?. . It seems like unnecessary code to define everything at the bottom of List.h. I can absolutely swear the docs said we were allowed to do either, but I can't find that line now. If it still passes the style checks/autograder, is there any reason we can't just keep things simple and implement things where they're defined? Is this bad practice that leaves us open to lots of potential issues, or something like that?. . Thank you!|117|0|active|You're correct that it is absolutely valid syntax to define your member functions inside of the class definition. On a broader scale, however, this is bad practice. Your code will be much more disorganized and incredibly hard to read the larger your classes get. . . Typically, we'd define the class in the header file with function and member variable declarations, and then we would include that file into a cpp file (List.cpp file for example), and define our functions in this separate file. It's much more helpful to have a succinct class definition with no unnecessary definitions in the header file.||0
la0e69oy3mq6en|Testing List in general|For our tests cases, should we make specific tests that make sure that list can handle all different types of data (strings, doubles, ints etc) or is it fair to assume that because the class is templated, it will work for all types of data?|110|0|active|All types should be handled the same unless you're doing some weird shit, so changing up the type of the template won't really have an impact. I did my test cases using only int and passed the mutation test suites, so you don't need to implement tests for many different types to pass the mutation test suites.||0
la0cy80lqr030c|List.h copy constructor|From my understanding we have to create a deep copy when we implement our copy constructor in the List class. . . I am trying to create an initializer list, however, I am confused on what I have to set within that list (first/last/size OR datum/prev/next). . . Can someone please let me know if I am understanding correctly and give any tips that might help me implement this function?. . Thank you in advance:)|192|0|active|You can give first last and size initial values in the initializer list, but you'll need to still copy the data into the list from the parameter. You need to manually copy all of the nodes into dynamic memory again to make the new List separate from the input List.||2
la0cku9i5qc4gc|is it possible to insert an element as the last element in the list?|The insert function in the list class inserts a new element before the element pointed at by the iterator, so does this mean you cannot insert an element to be the last element in the list (or in other words, append the element to the list)? Since if the iterator is pointing at the last element, you'd insert before that element. Or is it if the iterator is pointing at nullptr, that's when you'd insert the element to be the last element in the list?|114|3|active|@3253_f1. ||0
la0aocuhpfi2o5|= operator|Hi I am having some trouble writing the overload operator. I keep getting a memory issue and it keeps tying back to this function. Do you know what might be causing the memory issue? Once I clear the list, How do I effectively make a new list? Do you use the copy constructor? |6|0|private|"You shouldn't need to construct another List object. ""this"" list already exists, you just need to clear ""this"" List's dynamic memory and then copy from the other. See if that fixes the issue"||1
la0a8ytekjupc|Syntax error: unexpected token &#39;identifier&#39; following &#39;expression&#39;|For some reason I am getting this syntax error, my solution is just like the lecture slides. Can someone help me find my issue?. . . Edit: I did not realize that I had failed to finish a function below. That was the issue.. . Thank you.|3|0|private|resolved||0
la09kwh5gri5mw|testing for P4|Seeing as we might not be implementing a driver, is there a way for us to comprehensively test our List class as a whole, or will we be expected to test sufficiently simply through List_tests.cpp?. . I am mostly concerned about passing private tests post-autograder. Any advice is appreciated!|99|0|active|I plan to test through the List_tests.cpp. Consider that to be your driver file if that helps you, you can still perform lots of operations and lots of checks using Lists.||0
la0525pn1w44yq|Iterator functions|What is the point of the operator -- and operator ++ functions. We assume that they're needed to implement the erase and insert functions, but how should we go about this? Do the functions change the location that the iterator is pointing to? Why're we returning an iterator rather than just changing what node_ptr is pointing at?|235|0|active|Yes, it changes the node_ptr to point to the next (++) or prev (--) Node in the List. When doing iter++ you're effectively doing iter=iter+1, so you need to return the Iterator to reassign it. ||0
la04xh3hx9e4kb|Followup to @3185|I am wondering how to implement the erase function. In the starter code, the function erase is part of the list class, but outside of the iterator class. However, in @3185, the instructor answer says to use a private member variable from the Iterator class in the erase function. How is this possible if the erase function is supposed to be outside of the iterator class?|182|0|active|You can access private variables in the `Iterator` class from `List` if you make the declare the `List` class as a friend class to `Iterator`.||0
la04kgmfg1u3e8|undefined reference error for begin() and end()|```. /usr/bin/ld: /tmp/cc8p65eq.o: in function `List::begin() const':. /home/jacob/umich/eecs280/p4-web/List.h:148: undefined reference to `List::Iterator::Iterator(List::Node*)'. ```. . Why would this be the case? The `begin()` function returns `Iterator(first)`. (I did declare List a friend class).|184|0|active|I have seen this error if you haven't implemented the functions. The compiler does not give red squiggles because the function stub is there, however when making the executable the computer checks to see if the function implementation is completed. It throws an undefined symbol error if it can't find the implementation.||1
la03u329jeb2i1|Run errors|I keep getting this error when trying to run my code even though this was already implemented for us|98|0|active|I would recommend using the iterators instead for the comparison. So list3.begin() instead.||0
la03jrawvng4ge|cout &lt;&lt; *iter &lt;&lt; endl; not working|"```. no operator ""<<"" matches these operands C/C++(349). List_compile_check.cpp(56, 10): operand types are: std::ostream ::Iterator. ```. I have defined my `overload*()` function to just return `*this`.. I don't really understand why this would error out, because I thought `*iter` will dereference into an `int` type, which can be cout'ed normally..."|134|0|active|You need to implement the function within the Iterator class that overloads the * operator.||1
la039gf58195rr|What should List::end() return?|It says to return an Iterator pointing past the end, but I'm not sure what that means. Does `--iter` need to cause `*iter` to point to the back of the list or is `List::end()` only used to check to see if an iterator reached the end?|135|0|active|Try checking @3164||0
la03810tued6v8|Honor Code worries|If we use code from the slides for project 4, will it result in an honor code violation? How similar is too similar?|182|0|active|If they gave it to you you’re fine Im pretty sure. This includes slides||1
la01jsaekmk6yr|Valgrind tutorial link faulty|The tutorial link for using Valgrind for segfaults (in the FAQ) doesn't seem to work for me.|5|0|private|We have stopped using Valgrind as our main source for debugging, please take a look at the address sanitizer tutorial instead.||0
la004j3mj1c69h|Iterator Big Three|"In Lecture, Prof. Juett briefly said that there is no big three for the iterator class, but I saw in the AG that ""List iterator big three"" was a private test case for this project, so do we actually need to implement a big three for the iterator class?"|270|2|active|From the codebase comments themselves:. . // You should add in a default constructor, destructor, copy constructor,. // and overloaded assignment operator, if appropriate. If these operations. // will work correctly without defining these, you can omit them. A user. // of the class must be able to create, copy, assign, and destroy Iterators.. It would be prudent of the professors to include a test of the Big Three regardless of whether we ought to include the Big Three so that we cannot glean whether or not each class should have the Big Three implemented. The grading is merely whether a user of the class can create, copy, assign, and destroy Iterators. So long as a user can do that, whether you implement the functions or not, you will earn credit for this test.||1
l9zzyzdf84j29y|Error (Undefined symbols for architecture arm64)|Screen_Shot_2022-11-02_at_2.51.21_PM.png. I am getting this error whenever I try to compile List.h, I have no idea what this error means and/or how to go about debugging it.. Can anyone help point me in the right direction?|92|0|active|This likely means you didn't implement the constructor for `Iterator(Node *n)` but it was declared in the class definition. Make sure you have an implementation for it in your code. If you think it is properly implemented, try changing c++ to g++ when compiling (c++ can sometimes cause errors that g++ doesn't have).||0
l9zz42kxts56cn|attempting double free error message|what does this error message mean? we run into it when we calling pop_back and pop_front. any help would be appreciated, thanks!. . |4|0|private|Double freeing means you're calling delete on the same memory twice. Walk through your implementation and consider if you are potentially deleting the same node twice.||0
l9zx61mmv016oo|push_front(const T &amp;datum) function|Is this function supposed to insert the datum into the first node or do we create a new node with the datum and set that as the first node?|152|0|active|"You should create a new node, and connect it to the first node so that the newly created node becomes the first node of the list. You are not ""moving"" any node."||1
l9zr0ueasek1bb|Constructors for List.h|Hello,. . I was kind of confused on the constructors for the List class. I have a counter variable to keep track of size, and I initialize that, but other than that, do I need to do anything for the default constructor? Also, for the copy constructor, all I do is initialize the counter variable and then use copy_all. Am I approaching this the right way? Thanks in advance :)|205|0|active|For the default constructor, you would also have to initialize your head and tail pointers for the list. The copy constructor sounds like you're on the right track.||1
l9zqh96jylb3y6|Autograder Not Reading My test Cases|Hi, so for some reason on the Autograder, the mutation tests section says that I'm not submitting any test cases, they run on my IDE (I've also used the sanitizers to detect for leaks), and on the Autograder it says that it compiles and there is no undefined behavior. I've attached the file to this post(why I made it private), and was hoping to get some insight as to why this was happening.. . Thanks,. Jacob. . List_tests.cpp. Screenshot_2022-11-02_at_10.18.03_AM.png|9|0|private|It actually doesn't compile according to what I'm seeing, here's an example of one of the compile errors. You may want to try testing this on CAEN, it'll most likely generate the same errors as autograder. https://eecs280staff.github.io/p1-stats/setup_caen.html. . ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkeeutacclj53vw%2Faf45f2fa0457951ac235280f17a4d65addf67ff1ac803db12f90659fcd8362c9%2Fimage.png)||1
l9zq2tbkg5424s|Lectures for Project 4|What lectures would be covered in Project 4?|110|0|active|16 and 17, linked lists and Iterators||0
l9zplqoby5077y|Testing for Memory Leaks|Is there any way to write tests or somehow check for any memory leaks and misuses of the new and delete operator?|130|0|active|Address Sanitizer is AMAZING at detecting memory errors. I've linked the tutorial here. I 100% recommend using it for this project: https://eecs280staff.github.io/p1-stats/setup_asan.html. . Also, another conventional method I would suggest while writing the code is taking a particular node and tracing its journey from its conception to demise (too philosophical words for a node haha) and checking if it is being created just once and deleted just once. ||0
l9zpd5iy1a51hi|push_front and push_back populating pointers|I started looking at the notes for linked lists and I noticed that their push_front code does not populate the prev pointer that the Node struct has. Should it actually populate that with a pointer to the previous Node? What about when doing push_back?|155|0|active|Hello! May I ask what notes you're talking about?  The lecture notes talk about a singly linked list https://eecs280staff.github.io/notes/16_Linked_Lists.html while in this project you are implementing a doubly linked list. What sets a doubly linked list apart from a singly linked list is the fact that every node has a prev pointer as well. So, when you push_front, you're correct in assuming that the new node being inserted at the front has to have its prev pointer point to the previous node : )||0
l9z7xfzmu573u0|putting additional variables like keeping track of size in the Iterator class|Looking at the comments for the private member part of the Iterator class, there's a comment that says to add any additional member variables in that part (the part with Node *node_ptr and Iterator(Node *p)). Why are we supposed to put the member variables there? Shouldn't variables such as the size of the linked list be in the private member section of the List class? . . I tried putting the declaration for the size variable in the Iterator class, but whenever I try to use it for the size() function in the List class, it says it's not defined. I made sure to include the friend declaration as well, so I'm really confused. Anyone have any idea as to why this is happening?|150|0|active|You shouldn't need to keep track of the size in the List::Iterator class, as none of the functions in Iterator need to know the size. You can add additional private variables to the List class to keep track of this.||0
l9z23264j7cph|Why does this test fail on autograder?||11|0|private|Another side note : lst.end() returns an iterator to past the end. This essentially means that the node_ptr of the iterator returned is nullptr. Against this backdrop, I would recommend you to revisit the RME for the -- operator before using it on lst.end() : ). . I think most of your code in the followups should be resolved once you correct lst.end()||1
l9z0ny7bolwgq|(OPTIONAL) P4 API Overview Slides|Hi everyone! Since P4 doesn't require a driver, we won't be having an introduction review session. Instead, I'll link the slides to the introduction presentation for those who are interested in learning more about the API driver.. . https://docs.google.com/presentation/d/1kCSAwqcHm1K70GzooMj3FOvJuF0M15zQK-UEIytmb7I/edit#slide=id.g100700217d4_0_131. . Good luck on the project!. . |576|1|active|||0
l9z0bselns279c|&#34;May invalidate list iterators&#34;|"I see that for some Modifies clauses for some functions in the List.h file, it says ""MODIFIES: may invalidate list iterators"". What does this mean? Can someone please explain it?"|196|0|active|"So let's say we have a list of 4 elements [1, 2, 3, 4].. Let's now create two iterators pointing to the front, then erase the element associated with one of those iterators.. . //assume list is defined properly. List<int>::Iterator iter1 = list.begin();. List<int>::Iterator iter2 = list.begin();. . list.erase(iter1); //removes the first element. . //note that iter1 and iter2 are still ""pointing"" to the first element!. //as such, this next statement is undefined behavior:. int a = *iter2;. //we're (indirectly) attempting to dereference memory that was just deleted.. //that means both iterators are currently invalidated.. Basically, an iterator is ""invalidated"" if the data it is pointing to is no longer valid on that list."||0
l9yzlpo3v0f74n|#include aren&#39;t working|VS code has all of sudden decided that it doesn't like the includes at the top of both the Lish.h and api.cpp files. I barely downloaded the code and it immediately gave me errors. Does anyone know how to fix this?. |107|0|active|"If this happens, just try closing/reopening the tab and/or window. Sometimes it does that for me too, but it normally ""figures it out"" eventually."||1
l9yyrsik6ic6jw|Empty function|template <typename T>. bool List<T>::empty() const {.     return first == nullptr;. }. . What is wrong with this function? It is failing the given public test and returning false on an empty list that is true. In the spec it says that Node *first points to the first node in the list, or nullptr if empty. So shouldn't this be the correct way to implement this? |9|0|private|What error is the public test giving?||1
l9yxuu1is0643g|Why is the constructor for Iterator private?|Thanks|152|1|active|"Since Node isn't public (""not part of the interface""), an Iterator constructor using a Node should not be public either.. . We haven't learned it in lecture yet, but you can read about it in the lecture notes here: https://eecs280staff.github.io/notes/17_Iterators.html?highlight=iterator"||0
l9yw2rd7wo2oj|Function stubs for functions with Iterator type|"I'm trying to add the function stubs for all the functions in List.h, and for all the functions that have type ""Iterator,"" I am getting the error that it is an unknown type name. I keep trying things in hope that it will fix the issue, but I can't seem to figure it out. Is there a simple fix that I am missing?"|137|0|active|Are you using the typename keyword? From the staff lecture notes: . I followed this format and it worked for me. ||0
l9yv0pt1kzn6l8|Push_front error: member access within null pointer of type &#39;struct Node&#39;|Screenshot_20221101_074011.png. Screenshot_20221101_073932.png. I'm trying to write a test for my front() function, and I used the push_front() function inside the test. It wasn't working at first, so I used the debugger and got a seg fault when I stepped into push_front(). I don't really understand what it means. If someone could explain that would be greatly appreciated.. |4|0|private|A segmentation error in this project is almost always the misuse of a pointer. Make sure that the pointers you are using are pointing in the right place and are not being double pointed somewhere.||1
l9ypz7ssggn7et|Using a counter for linked list|is it practical to use a counter when constructing a linked list or should we navigate through the linked list node by node until we reach the final node?|159|0|active|Are you talking about the copy constructor? I don't see a way you could usefully employ a counter -- you need to go through and deep copy all of the other list's nodes either way, and you can't iterate through them with an index like they're in an array.||0
l9yo5x927vm4s7|Erase function|In the erase function, we are supposed to erase one element from the list given an iterator. However, we can't access what the iterator points to, so how do we know which object to erase? I thought about using the dereference operator to compare values, but if multiple elements of the list have the same value then this implementation wouldn't work. Since it is not possible to compare an iterator with a node and the iterator constructor is private, how can I check for which object to erase??|227|0|active|In the private field of iterator you have access to Node *node_ptr. Make use of that to figure out where the node is in the list is and erase accordingly.||0
l9yg0xa4ae62b8|Undefined Behavior|I am making this post private so that we can share our code. We are getting this error after following along with the lecture code and we're wondering why? We have not yet made a custom destructor --- would that fix the issue? Or is there another problem with it?. |8|0|private|The issue is that you're deleting a null pointer:. . `error: member access within null pointer of type 'List::Node'`. . A custom destructor wouldn't do anything here because the destructor in question is supposed to be for `List`, not `Node` (`Node` only requires the default destructor, which you don't need to implement).||0
l9ye1gk6w8t3py|Function stubs - resolved, I forgot to remove const|I'm getting declaration is incompatable for the following. I'm still a little confused with templates so I'm not sure what I'm doing wrong.. . . template<typename T>. T List<T>::front() const {.   assert(false);. }. . template<typename T>. T List<T>::back() const {.   assert(false);. }. . template<typename T>. void List<T>::push_front(const T &datum) const {.   assert(false);. }. . template<typename T>. void List<T>::push_back(const T &datum) const {.   assert(false);. }. |200|0|active|~~For future students, only one ‘template ’ is needed~~. . My bad I was looking at an older solution! You would write your solution either in side the stubs you've made or inside the class of the given starter files||0
l9y8ltwkj6v2f9|Laptop Broke|My laptop broke and the LSA loan does not let me download VS code. How should I work on the project? My IA recommended using the CAEN computers. How exactly does that work?|8|0|private|The CAEN computers are public University computers that have specific software already installed on them. They can be found in computer labs (such as the ones in the Ugli, BBB, the Dude, Mason Hall, etc.) You just use your umich name and password to login, and I believe VSCode should already be installed on them. . . https://caen.engin.umich.edu/computers/||1
l9y85idvw143i|* operator|I am confused about the * operator we have to implement in iterator, what exactly is it supposed to do? |154|1|active|Have you taken a look at @3160? Feel free to follow up here if you had additional questions about this||0
l9xp9s0akou5ix|Project 4 Specs|"I just wanted to make sure that all the information listed in the ""Queue Rest API"" section on the Project 4 spec is related to the driver file (optional)."|178|0|active|That is correct!||0
l9xkkaq1lnb1s4|Terminal Error|I am getting this error in my terminal when attempting to make List_public_test.exe. It compiles in xcode, so I'm not sure what the issue is. . . |159|0|active|Have you added function stubs per https://eecs280staff.github.io/p4-web/#compile ? If not, that's probably the reason your code isn't compiling.. . If you have written function stubs, make sure the function signatures match (e.g. you might have forgotten a `const` modifier on `bool List::empty()`).||0
l9xixcttdqb691|i made function stubs, but i keep getting these errors||194|0|active|It wont compile until you implement the List Iterator by default. It says it in the spec.||0
l9xiow3t20110y|[json.exception.type_error.308] cannot use push_back() with object||131|0|active|Note that this part of the project isn't required this semester. However, it appears you're trying to call push_back on something that's already a JSON object. Try creating a new empty JSON value (that's null by default), then push to it.||0
l9xif7ba30l1pr|MacOS Ventura command line tools error|Resolved; command line tools altered when upgrading to MacOS Ventura. . If other people run into this problem here is the post on stack exchange that helped me. |83|1|active|||1
l9xhe5qtank712|Compile Checks|"Why does my List.h file compile if I do ""make List_public_test.exe"" but doesn't pass the autograder's compile check?"|178|0|active|The public test is extremely barebones—check out its cpp file. The compile check is included in the project starter files, and won't compile if you haven't provided an implementation for every function.||0
l9xdrjf4oys2cx|Assignment Operator List Function|"Say we have a List y with 3 elements and we define a new List x and do ""x = y"", what is this supposed to do? Does this create a new List in the heap for x? Or does it simply point to the same object as y in the heap like a reference?"|168|1|active|"x = y should effectively create a copy of y and store it in x.. . Look into the lecture on ""The Big Three"" (lecture 15) for more information on how to implement that."||0
l9xdoijv6unwj|Where to implement copy_all()|Are we supposed to implement the copy_all() function in the class or should we write a separate function stub at the bottom of the file?|177|0|active|Either works. It's probably a good idea to follow what you're doing with other functions—if implementing them inline then do the same for copy_all, but do it outside the class if you're doing that for the other functions.||0
l9xcni7iep94o3|Function stubs for iterator return type|I fixed my mistake|4|0|private|resolved||0
l9xbqcod7y32s|Question about List::end|"The method `List::end` has the comment:. ```.   // return an Iterator pointing to ""past the end"".   Iterator end() const. ```. . I am confused what ""past the end"" means.. Does this mean that the iterator should point to the last element or some nonexistent value beyond it?. Ie. which of the following should be true?. ```. Iterator iter = list.end(); // Assume `list` isn't empty. assert(*iter == list.back()); // should this be true?. iter--;. assert(*iter == list.back()); // or this?"|216|0|active|It points to the spot in memory one after the last element, not the last element itself. The second should be true.||1
l9x8gwdyjnq7e5|Project 4 Vectors!|Are we allowed to use vectors for the list class under the list header? Or will we be forced to use an array? If we must use an array, what should the default capacity be?|170|0|active|While this question has already been answered by an instructor - it's important to note that using a vector/array would defeat the purpose of trying to make a linked list. A vector/array must store its memory in one contiguous fashion and to insert an item anywhere but the end would require moving everything over manually, a linked list can effectively store its data all over the place if it wants - which allows for much easier insertion and removal of arbitrary items theoretically anywhere in the list (though at the cost of making lookups outside the beginning/end much more difficult...)||0
l9x734v2eor6kc|Equal and * operator|For the equal operator in project 4, does equal mean just the same address? Furthermore, what does the * operator mean in the context of lists. I understand addition or subtraction of lists and integers, but I do not understand what multiplication would mean in this context.|157|1|active|The * operator when used with just one value after is the dereference operator. It's usually used when you have a `Foo *` and want to get the `Foo` that it points to. This is different to * when you have two values on either side, which is multiplication.||0
l9x26m1xpky6jy|Function stubs|When creating function stubs is it necessary to have. template<typename T> . before every stub or just the first? |157|2|active|It is necessary before every stub. Notice how the `template` line does not have a semicolon at the end. You can think of this as part of the function or class header.||0
l9wyjvsj4cu7fe|Version control setup|When I type the git branch -vv command, I get no output in the terminal. Did I go wrong somewhere or do I just proceed? . . |124|1|active|resolved||1
l9vv1rdqz967oo|Project 4|Hi,. I just was curious when Project 4 will be released. I believed it would be released after the midterm exam. I am aware that we can use old specs, but I wanted to hear from an instructor whether or not it is a good idea to try and get ahead with old specs. As well as that, when can we expect the project to release?. Thank you |13|0|private|I would say sometime next week for the project, I don't think the lecture material has been covered for this project yet as well, so try to take a break until it actually gets released. (Normally project 4 is not as much work as project 3). . but if you really need to start I guess you could use the previous spec||0
l9tinskuifb5jt|Project 4|When will the official project 4 for this semester be released? Should we be working on it based on the past semester's spec?|12|0|private|I would say sometime next week, I don't think the lecture material has been covered for this project yet as well, so try to take a break until it actually gets released. (Normally project 4 is not as much work as project 3)||0
l9sip8y6mer3ih|Project 4|When will the spec for project 4 be released? |12|0|private|$$Soon^{TM}$$. . (Real answer: in the next couple days, presumably by or on Monday)||0
l9j4iwbryqa4ig|When will project 4 be released?|Is it possible to upload the project 4 spec earlier? Does anyone know what the project is?|233|0|active|You can access future projects here: https://eecs280.org/archive/. You can access future labs and projects. I know for a fact that professor Beaumont has said that we can basically count on project specs not changing (at least not in any impactful way) mid semester.||0
l9dfhcj915x69i|No error squiggles for List.h|"I've been working on `List.h` and noticed that error squiggles don't show up despite them showing up in `.cpp` files:. ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fl7nv0y6f4pf5aa%2Fcaad0b7c78b0a34a28e747c9fcb3dd740fb596bfa0fc7c5a7fe0424a03a2717a%2Fimage.png). However, this seems to only happen when I'm defining templated functions. Outside of those function definitions, I still get squiggles. Even in the templated class definition, I'll get error squiggles. The only thing I found similar online was [this thread](https://developercommunity.visualstudio.com/t/visual-c-intellisensesquiggles-dont-work-in-a-head/487984) but this is for Visual Studio and has no solution. I have tried resetting IntelliSense and the ""Enable error squiggles"" option in the command palette. Is there a fix for this? I'm using VSCode on WSL 2."|154|2|active|My apologies. Have you tried directly enabling them (https://www.folkstalk.com/2022/09/how-to-re-enable-error-squiggles-vscode-with-code-examples.html#:~:text=Do%20Ctrl%20%2B%20p%2C%20and%20type,Disabled%22%20Change%20it%20into%20Enabled.)? ||1

post_id|subject|content|unique_views|good_question|visibility|i_answer|s_answer|num_followups
l0wkpcb15vl2z|AG Update: 5 Autograder Submissions|Hi everyone!. . Since the project has a quick turnaround (due a week from today), we have updated the Autograder to give everyone 5 submissions per day instead of 3. Happy coding!. . creaseInSubmissions |911|5|active|||0
l2ajrurjzog7r|q2|Screen_Shot_2022-04-22_at_10.47.13.png. what does single type of data mean (2nd choice)|10|0|private|Unfortunately that is not something we can answer.  Please use your best judgment based on the problem statement.||1
l2701accxkt46z|question about push, pop and empty|For push, is it OK to call `empty()` as the condition instead of `list_size == 0`? And for pop, is it OK to use `if (first == last)` instead of `if (list_size == 1)` as the condition?. ```cpp.   //EFFECTS:  inserts datum into the front of the list.   void push_front(const T &datum) {.     Node* p = new Node; p->datum = datum;.     if (empty()) { // if (list_size == 0).       p->prev = p->next = nullptr;.       first = last = p;.     } else {.       p->prev = nullptr; p->next = first; .       first->prev = p;.       first = p;.     }.     ++sz;.   }. .   //EFFECTS:  inserts datum into the back of the list.   void push_back(const T &datum) {.     Node* p = new Node; p->datum = datum;.     if (empty()) { // if (list_size == 0).       p->prev = p->next = nullptr;.       first = last = p;.     } else {.       p->next = nullptr; p->prev = last;.       last->next = p;.       last = p;.     }.     ++sz;.   }. .   //REQUIRES: list is not empty.   //MODIFIES: may invalidate list iterators.   //EFFECTS:  removes the item at the front of the list.   void pop_front() {.     assert(!empty());.     Node* p = first;.     if (first == last) { // if (list_size == 1).       first = last = nullptr;.     } else {.       first = first->next;.       first->prev = nullptr;.     }.     delete p;.     --sz;.   }. .   //REQUIRES: list is not empty.   //MODIFIES: may invalidate list iterators.   //EFFECTS:  removes the item at the back of the list.   void pop_back() {.     assert(!empty());.     Node* p = last;.     if (first == last) { // if (list_size == 1).       first = last = nullptr;.     } else {.       last = last->prev;.       last->next = nullptr;.     }.     delete p;.     --sz;.   }. ```. For `empty()`, is it OK to return `first == nullptr && last == nullptr;` instead of only `first == nullptr;`?. ```cpp. bool empty() const {.     return first == nullptr && last == nullptr;.     // return first == nullptr;.   }. ```|4|0|private|Those all sound reasonable. There are generally multiple valid ways to implement a given piece of logic.||0
l1pgwvdzcpe4g5|Copy Nodes Impl Question|"About the base case for tree recursion in this function:. . using a conditional to trigger either return (base case) or a recursive call on the left and right children, I am using the ""size_impl"" function to determine if the tree rooted at node is of size 1 or >1.  When it is equal to one, this is the base case and it means that either the tree is exactly one in size and this is the first (and only) call to the function, or this one of the final recursive calls in a tree of size >1, when the node passed in is a leaf node.  . . I'm trying to think of how to make these cases distinct – I tried use two if statements in the manner of:. if (size == 1 && node == root) //base case of a tree being exactly size 1. else if (size == 1 && node != root) //final stance for a recursive case (subtree is size 1). . but I cannot access root because this is a static member function.. . Am I supposed to use iterator here?  How else could I orient this conditional statement to distinguish between the final recursive base case vs the singular base case?. . thanks. "|72|0|active|Are you sure that you want your base case to be size = 1? Is there another way that you can check whether you've reached the end of a branch (i.e. that there are no more nodes/leaves)? . . Also, you shouldn't be distinguishing between a final recursive base case and a singular base case; those should be the same thing.  Consider the lecture example of height: does it have a different base case and final recursive case? If so, what is the difference?||0
l1kxew7mf2aqz|p4-web grade?|Recently the p4-web grades were released, and my partner (lisadai) and I got a pretty low score. However, we passed all of the tests, caught all of the bugs, and our valgrind isn't showing errors though the autograder shows errors. Can we get guidance on what were the errors in our project or code? Or might it be a problem with the valgrind set up? We're pretty confused as to what went so wrong ...|12|0|private|I'm sorry to hear that this happened. The best place to discuss project grades is proffice hours, and the professors should be able to help guide you towards what went wrong in your code.||0
l1ecv2dkelj1im|Are these compile errors fine?|Edit: Submitted it to the AG and everything compiles fine so I think it's fine.. . I used the examples from the specs and VS is saying that it can't find function definitions for the find() and operator[] overload functions. I tried rebuilding and a few other things, but it won't go away. I get the errors in the pictures below when running it in VS and that output when compiling in Ubuntu. main compiles fine when I make and run ./main.exe. Am I good to move onto the next steps in the specs and begin working on the actual implementations or am I doing something wrong?. . . . |88|0|active|marking as resolved per your note — follow up if you have more questions!||0
l1e8p4xqjkk3my|Why do we need typename in front of some functions in Map.h|What's the difference? Neither produces errors, I originally implemented mine without it and then noticed that the example included typename in front of the Map part in a lot of the functions. . template<typename K, typename V, typename C>. Map<K, V, C>::Iterator Map<K, V, C>::begin() const. {. . }. vs.. . template<typename K, typename V, typename C>. typename Map<K, V, C>::Iterator Map<K, V, C>::begin() const. {. . }|115|0|active|||0
l1e4u9q2k657ib|Example find() function doesn&#39;t work and confusion on out-of-line function implementations|When I use the example for the find() function provided in the p5 specs:. . . template <typename K, typename V, typename C>. typename Map<K, V, C>::Iterator Map<K, V, C>::find(const K& k) const. {.     assert(false);. }. It still says function definition for 'find' still not found. VS recommends this instead:. . template<typename Key_type, typename Value_type, typename Key_compare>. inline Iterator Map<Key_type, Value_type, Key_compare>::find(const Key_type& k) const. {.     return Iterator();. }. However, that doesn't work either and I have to add Map<K, V, C>:: before Iterator. I can remove inline and it still works, but when I switch everything to K, V, and C instead of the longer name parameters, it says it can't find the function definition for find() again. I also tried this and it gave the same problem:. . . template<typename K, typename V, typename C>. Map<K, V, C>::Iterator Map<K, V, C>::find(const K& k) const. {. 	assert(false);. }. . Also, I understand how to implement the simper functions like empty() and size(), but I don't understand why we need typename in front of some of the other ones as well like the example for find().. . I'm just trying to get my Map stuff to compile right now and am confused on what exactly everything means/why we need some stuff for some of the functions.|251|0|active|The first one should work.. . The suggestion VS gave you is okay but not necessary. `inline` keyword does not work in the way you think. It is only a suggestion instead of enforcement and most compilers know out-of-line definitions are `inline`. You are suggested to use `inline` only if your code could potentially violate ODR(One Definition Rules).. . ||1
l1bitifys5m2vi|Autograder private test|I don't know why my push_front test failed. What's the reason for failure? I implemented it the same way as push_back.|7|0|private|I can't see the test case it is failing on but potentially it could be when you insert the first element you don't set next = nullptr.||0
l1b5oo4kl5g3rn|Question about big three private test|Hi, I am just curious why my private test case failed here as I cannot find my mistake.|12|0|private|Can you put your uniqname in your username? This will allow us to find your AG submission that was graded.||1
l1b1fm0854aqv|Is there a way to see private tests?|Is there a way to see the private tests that broke my code? I understand why there are extra tests that run, but why can’t we see them? What’s the point in docking our grade, but not showing us the error? How do we learn anything and not make the same mistake next time?|171|1|active|"We do not provide ""private tests"", otherwise they would be ""public tests"".. My personal understanding towards the meaning of ""private tests"" is we want you to make your code more robust. When you are required to write a program on your own in industry, the clients are not responsible to find the bugs you had (they would only complain about the buggy behavior!), and you should have the ability to test your own code, not waiting for other people to find the edge cases for you.. As another student mentioned in the followup discussion, you can go to proffice hours for more help after the deadline, but we wouldn't reveal the exact private test cases we have."||2
l1awhojukxv14e|P4 Failing all private test cases|For project 4 I passed all my extensive test cases which catch all the bugs, however when I received my final grade, I failed all of the private test cases and I am extremely confused as to how this could occur. . . Could there have been some kind of mishap in my implementation location because I am extremely distraught as I thought I did well.|208|1|active|In general, passing all of the bug-catching test cases does not necessarily mean you will pass all of the private test cases. Though, it does mean you would usually at least get some of them, so that’s definitely unfortunate and I would assume it has something to do with a memory leak/some memory related problem.I think especially with this project, it is important to actually step through what your program is doing when you provide different inputs in order to ensure all of your dynamically allocated memory is cleaned up. By that I mean actually setting a breakpoint at the beginning of some of your test cases and manually checking every step it goes through.Like I said, this definitely could have been caused by one small error that threw everything off. Obviously you can’t go back and change your grade, but it would still be very beneficial to go back through your implementation and try to locate the source(s) of any errors.||1
l19v9n3z8o42t2|Question about the autograder|If I got the same scores on my three submissions, which one would the autograder use to generate the final score? Thanks|176|0|active|@5089||0
l19sr6pl1bb7c5|Valgrind Error even though no memory leaks are possible|Can somebody help me understand this error and what's going wrong even though there's no leaked memory?|175|0|active|see followup||1
l19sokqxuts4sq|Debugging memory leaks|I have an extension due to illness for p4, I have a memory leak with the only information to go off of being:. ==78== Invalid read of size 8==78==    at 0x406ED2: List<int>::Iterator::operator++() (List.h:229)==78==    by 0x40486E: iterator_erase_isert() (List_tests.cpp:166)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78==  Address 0x5aba0c0 is 0 bytes inside a block of size 24 free'd==78==    at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==78==    by 0x406CFF: List<int>::pop_front() (List.h:114)==78==    by 0x407130: List<int>::erase(List<int>::Iterator) (List.h:280)==78==    by 0x404832: iterator_erase_isert() (List_tests.cpp:164)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78==  Block was alloc'd at==78==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==78==    by 0x406891: List<int>::push_back(int const&) (List.h:90)==78==    by 0x4047C5: iterator_erase_isert() (List_tests.cpp:160)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78== ==78== Invalid read of size 8==78==    at 0x407186: List<int>::erase(List<int>::Iterator) (List.h:292)==78==    by 0x4049D7: iterator_erase_isert() (List_tests.cpp:190)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78==  Address 0x5aba248 is 8 bytes inside a block of size 24 free'd==78==    at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==78==    by 0x407181: List<int>::erase(List<int>::Iterator) (List.h:290)==78==    by 0x4049D7: iterator_erase_isert() (List_tests.cpp:190)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78==  Block was alloc'd at==78==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==78==    by 0x406891: List<int>::push_back(int const&) (List.h:90)==78==    by 0x4048D9: iterator_erase_isert() (List_tests.cpp:179)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78== ==78== Invalid read of size 8==78==    at 0x40718E: List<int>::erase(List<int>::Iterator) (List.h:292)==78==    by 0x4049D7: iterator_erase_isert() (List_tests.cpp:190)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78==  Address 0x5aba240 is 0 bytes inside a block of size 24 free'd==78==    at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==78==    by 0x407181: List<int>::erase(List<int>::Iterator) (List.h:290)==78==    by 0x4049D7: iterator_erase_isert() (List_tests.cpp:190)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78==  Block was alloc'd at==78==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==78==    by 0x406891: List<int>::push_back(int const&) (List.h:90)==78==    by 0x4048D9: iterator_erase_isert() (List_tests.cpp:179)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78== ==78== Invalid read of size 8==78==    at 0x407198: List<int>::erase(List<int>::Iterator) (List.h:293)==78==    by 0x4049D7: iterator_erase_isert() (List_tests.cpp:190)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78==  Address 0x5aba240 is 0 bytes inside a block of size 24 free'd==78==    at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==78==    by 0x407181: List<int>::erase(List<int>::Iterator) (List.h:290)==78==    by 0x4049D7: iterator_erase_isert() (List_tests.cpp:190)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78==  Block was alloc'd at==78==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==78==    by 0x406891: List<int>::push_back(int const&) (List.h:90)==78==    by 0x4048D9: iterator_erase_isert() (List_tests.cpp:179)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78== ==78== Invalid read of size 8==78==    at 0x40719F: List<int>::erase(List<int>::Iterator) (List.h:293)==78==    by 0x4049D7: iterator_erase_isert() (List_tests.cpp:190)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78==  Address 0x5aba248 is 8 bytes inside a block of size 24 free'd==78==    at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==78==    by 0x407181: List<int>::erase(List<int>::Iterator) (List.h:290)==78==    by 0x4049D7: iterator_erase_isert() (List_tests.cpp:190)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78==  Block was alloc'd at==78==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==78==    by 0x406891: List<int>::push_back(int const&) (List.h:90)==78==    by 0x4048D9: iterator_erase_isert() (List_tests.cpp:179)==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==78==    by 0x404DBB: main (List_tests.cpp:237)==78== . . . with a run in caen not being helpful (aren't there some caen commands to help debug memory errors?? it otherwise just shows this:. . . I feel at a loss for how to debug and its due at 8 (it runs and passes every test case in my IDE, but not autograder/caen). |282|0|active|According to your autograder submission, it looks like you still have a valgrind error.. . 24 bytes in 1 blocks are definitely lost in loss record 1 of 2. ==78== at 0x4C2E0EF: operator new(unsigned long). ==78== by 0x40688F: List<int>::push_back(int const&) (List.h:90) (in/usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so). ==78== by 0x40688F: List<int>::push_back(int const&) (List.h:90). ==78== by 0x4048DB: iterator_erase_isert() (List_tests.cpp:175). . Errors like this usually mean that you aren't deleting dynamic memory (hence definitely lost). Make sure that for every time you erase a new Node, you are also deleting it from memory. That goes for every instance of erasing, including through an iterator and all the edge cases for erase.||1
l19qzzma3lv1f4|Valgrind Errors|Hi. Is there anyone who can help me understand these Valgrind errors? I checked the previous posts and understand there might be some memory leaks, but I could not figure out where I did wrong. I always delete the new node I created and I also called clear() in my destroy constructor. Thanks. . . . |151|0|active|"The error doesn't appear to be a memory leak. It's saying that you have an ""invalid read of size 4"" which means you're reading memory you're not allowed to. The error is on line 74 of your List_tests (that's what the List_tests.cpp:74 means)"||1
l19o1uppejp2hm|project 4 scores?|Any idea on how much longer? will the project 4 scores be out today? seems like it was a very short project, that the autograder should've been able to grade it easily?|235|0|active|see follow-up discussion under @5098||0
l19m75tx84g1ka|Autograder issue|"On of my test cases is failing in the autograder but passing in my IDE.. . 1) how to solve?. . 2) is this what the ""false positive"" means for my mutation testing?"|13|0|private|A false positive in your test cases usually means that it asserts a false statement as true. To solve this, you probably need to rewrite your test case and ensure that the logic of the test case is actually correct. ||2
l19dizogjn641v|Question about insert|"What if we had a list with exactly one node that is both 'first' and 'last' in the list.  In the tsting suite, if I were to have an iterator named ""iter"" and did this:. . iter = list.begin(); //points to only node in list. ++iter;  //increment into next space in dynamic memory. list.insert(iter, 5);  //attempt to insert a node. . because insert inserts a node to there right (before) the pointed location, should I be overwriting the node that existed in the list beforehand, keeping the next/prev the same but changing datum?  or will I be effectively pushing to the back of the list w/o changing the data of the pre-existing node?. . "|6|0|private|You would be essentially pushing to the back of the list. Insert will always add a new node to the list.||0
l18be9xugi454|Autograder not working for tests|"I got an extension until Sunday to turn in the project but autograder doesn't seem to be working for my test cases. It keeps saying ""no test cases were submitted"". Is it something wrong with my tests or is it because it's past the due date?"|221|0|active|Here is your compile error for your tests:. . error: 'class List<int>' has no member named 'print'. . The student's answer is right. The tests can only use the list public interface as described in the spec and header file||0
l188t7xbj4r1so|@4887|Problem with erase, someone please take a look (I have extension due to illness, running into a deletion problem)|11|0|private|I notice you have a for loop in your erase function. You do not need a for loop to delete one element. There is no need for a for loop because you have access to the iterator node_ptr->prev and node_ptr->next. I love how you use pop front and pop back to your advantage but rethink how you access the node prev and node next when the node is in the middle of the list. I would suggest drawing out a diagram of a linked list with all the pointers so you can see exactly what pointers to change and what to change them to.. . Hope this helps!||1
l184dxqjcy72gf|Will our project 4 grades be out today?|Just the question in the title of the post|249|0|active|nvm just saw the post below this whoops||0
l183kb4oe6ya2|Grading Question|I am just wondering, is there an estimate of when the final grade for Project 4 will be released?|329|1|active|soon™||1
l1798lhyw3q1b6|first and new|should I be making first = new Node? or can I just make an entirely new Node and have first = node?|151|0|active|in other words, you can treat `new Node;` as a function that returns a pointer. If you don't set something equal to that function, you lose the pointer and leak memory.||0
l174tx4kmgj15m|Deleting Copies|How am I supposed to delete a copy of a list? Since my copy points to the same addresses in memory as the original list, when the destructor runs I get an error because it's trying to delete the object at the same address twice.|156|0|active|This is why you need to deep copy the list so that the copy does not point to the same address?||0
l172a611gbm1o3|Other Test Cases|I'm currently at 20/21 points on autograder after considering the different edge cases on the insert and erase functions. And I can't seem to get any higher. Any ideas for other edge cases to test for.|177|0|active|beginning, middle, end - do some combinations of pushback/front. . just some random suggestions||0
l171qrvlbsr7fq|Destructor with Copied List|I'm currently testing my copy_all function, but when the destructor takes care of the two lists (other and this) after it finishes, there is a malloc error.  I think it's because the destructor is trying to delete something that's already been deleted.  How can I fix this? |115|0|active|"make sure you are deep copying correctly - you could run the test case in question in your debugger and at the point of destruction look at the representation of the two lists and figure out if there are ""duplicate"" nodes in one of them"||0
l171buubpjc3iu|Valgrind Memory Leak Insert function|I found memory leak from insert function.So we declared <Node> type pointer variable and assigned it by node_ptr of Iterator.Also we created another <Node> type pointer variable assigned by new Node.Then we did our manipulation using those two pointers.Should I delete the pointer assigned with new Node here?? We didn't because we are inserting this new Node and we were afraid deleting would erase the newly created node.What should I do to fix my memory leak??I would appreciate any advice!|121|0|active|"I agree with your logic - don’t delete a node that you just inserted into the list. (This would be very bad. Accessing the list would access deleted memory - undefined behaviour!). . use your debugger and look at the representation of the list right as the destructor is being called. make sure all the nodes exist and the pointers are pointing to the right places.. . if you don't see all the nodes in there, then debug your `insert` function and figure out why you are ""losing"" a node in your list representation"||0
l170esxmcyr11s|Valgrind Pass in CAEN but NOT in Autograder|"Below are the results from CAEN and AUTOGRADER. What does the error mean and why are they different?. . CAEN. *** Results ***. ** Test case ""test_0_default_ctor"": PASS. ** Test case ""test_12_erase_edge_12"": PASS. ** Test case ""test_1_pop_front_back_basic"": PASS. ** Test case ""test_2_iterator_basic"": PASS. ** Test case ""test_3_iterator_complex"": PASS. ** Test case ""test_4_iterator_complex"": PASS. ** Test case ""test_5_list_single_push_pop"": PASS. ** Test case ""test_6_single_erase_clear_iterFront"": PASS. ** Test case ""test_7_single_erase_clear_iterBack"": PASS. ** Test case ""test_8_iterator_two_element"": PASS. ** Test case ""test_9_Big_three"": PASS. ** Test case ""test_copy_iterator_10"": PASS. ** Test case ""test_copy_lists_edge_cases_13"": PASS. ** Test case ""test_string_list_11"": PASS. *** Summary ***. Out of 14 tests run:. 0 failure(s), 0 error(s). ==2870447== . ==2870447== HEAP SUMMARY:. ==2870447==     in use at exit: 240 bytes in 10 blocks. ==2870447==   total heap usage: 312 allocs, 302 frees, 84,488 bytes allocated. ==2870447== . ==2870447== LEAK SUMMARY:. ==2870447==    definitely lost: 240 bytes in 10 blocks. ==2870447==    indirectly lost: 0 bytes in 0 blocks. ==2870447==      possibly lost: 0 bytes in 0 blocks. ==2870447==    still reachable: 0 bytes in 0 blocks. ==2870447==         suppressed: 0 bytes in 0 blocks. ==2870447== Rerun with --leak-check=full to see details of leaked memory. ==2870447== . ==2870447== For lists of detected and suppressed errors, rerun with: -s. ==2870447== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0). . . AUTOGRADER. ==84== 120 bytes in 5 blocks are definitely lost in loss record 1 of 32==84== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)3==84== by 0x409114: List<char>::insert(List<char>::Iterator, char const&) (List.h:304)4==84== by 0x405B3D: test_12_erase_edge_12() (List_tests.cpp:349)5==84== by 0x4021F0: TestCase::run(bool) (unit_test_framework.h:420)6==84== by 0x40291F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)7==84== by 0x406097: main (List_tests.cpp:408)8==84==9==84== 120 bytes in 5 blocks are definitely lost in loss record 2 of 310==84== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)11==84== by 0x40857A: List<int>::insert(List<int>::Iterator, int const&) (List.h:304)12==84== by 0x403FBF: test_3_iterator_complex() (List_tests.cpp:70)13==84== by 0x4021F0: TestCase::run(bool) (unit_test_framework.h:420)14==84== by 0x40291F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)15==84== by 0x406097: main (List_tests.cpp:408)16==84=="|127|0|active|try with `--leak-check=full` to get additional information from CAEN potentially?||1
l170b890w1m70b|Question|Hi, This Valgrind is reporting that there is a bug in erase function, and I'm not able to figure out what the issue is... Can anyone help me figure this out?. . . . |9|0|private|what happens if you run it in your visual debugger?||1
l16zsdiayuq2ig|Copy_all for loop conditions|For my copy_all function I want the iterator i to start at begin() and go until end(). But I am not sure how to write it, as I am getting errors when I do i.begin() and i.end(). What is the syntax for this?|77|0|active|This is from Professor Juett's Lecture 17 slides. . ||0
l16zc2obx2s2xd|project 4|Are the errors in my code because I'm not supposed to use functions on this project?|7|0|private|What are the errors? . . > because I'm not supposed to use functions on this project?. . I'm not sure what you mean by this since you are always allowed to use functions (they are necessary for any C++ program)||1
l16z16p2rbr3ig|Question|Hi, . . I don't have any idea, When I return i.noteptr for the insert function... Do we need to return the i.nodeptr at the end, or not? . . . . |114|0|active|The insert function should not return anything||0
l16ytfaeuj04nv|erase function false positive|is our code supposed to be able to erase the last element in a list? because in the erase requirement it says to make sure i is a valid deferenceable iterator we do this  by asserting that i is not equal to nullptr is this okay? also we had a test case give a false positive when it erased the last element of our list-- is our function not supposed to do that?|85|0|active|Yes, when you call erase() you should be able to erase the last element since the last node is not a nullptr, so this shouldn't break the requirements stated in List.h. It is fair to assume that, since you got a false positive, your erase function is faulty in some way.||0
l16ypykojjx667|Test Cases for List.h|My partner and I have 23 tests written for List.h and they worked when we had a few less but now when we submit it to the Autograder we get 0/21 points and it says we didn't submit any. They run perfectly on VSCode, XCode, Ubuntu, Mac Terminal, and Valgrind so we don't know what is wrong. If someone could tell us what to do that would be great. Essentially the only thing that we've changed between the 2 submissions was adding test cases.|100|1|active|see followups||1
l16yigmu1fp28n|Can someone help me understand this valgrind error?||91|0|active|The top line in that call stack (`pop_back`), at the line mentioned, is accessing a variable which is uninitialized. Try to track down where that variable came from and where it was created, and figure out why it was never initialized with a value!||1
l16ycaqmlhq11b|Errors in List_compile_check.cpp|My Iterator function implementations are inside of the Iterator class and I'm using List as a friend class, I don't know why it's not recognizing the type name for the compile tests or the tests from List_tests.cpp.. . I have a bunch of compile errors saying that there is an undeclared identifier that looks like this:. |79|0|active|for future reference, compiling in the terminal is a good sanity check to see if the errors are related to your code or if it's a problem with your IDE.||1
l16y21gxck83hx|Valgrind error in autograder but not in CAEN|I have a valgrind error at autograder:. Screen_Shot_2022-03-25_at_5.34.43_PM.png. . But I have no error in the valgrind check from CAEN:. Screen_Shot_2022-03-25_at_5.36.32_PM.png. . What is happening|80|0|active|The screenshot you are showing from caen says you have a valgrind error. ||1
l16xxootgdc1bt|Can I use a helper function in Line_tests.cpp?|My test for the copy constructor for list and my test for the assignment operator for list have very similar code, so to make it not duplicate code I created a helper function. I thought I had heard someone say helper functions wouldn't work though. Is this fine, or does my test cases have to work solely on their own?|123|0|active|You can create helper functions to minimize duplicated code if you want to.||0
l16xhej4lu653h|&#34;List::List() [with T = int]&#34; is inaccessible|"All of my List function implementations are outside of the List class and have template <typename T> before the implementation and each function is defined with the scope resolution operator List<T>::[function name].. . I'm getting a lot of errors in my List_compile_check.cpp file and my List_tests.cpp file that say ""List::List() [with T = int]"" is inaccessible whenever I try to declare a new List."|60|0|active|> All of my List function implementations are outside of the List class. . Easiest way to fix this at this point is probably to put them inside the class (assuming that is the only compiler error)||0
l16xeuev8gk2xr|indirectly include disallowed libraries|"The autograder keeps rejecting my submissions with the error message ""List.h may indirectly include a disallowed library: 'algorithm'"". I double checked and my List.h does not include the algorithm library, or any other disallowed libraries. Why could this be happening?. . A side note is that I initially was including some allowed libraries, like cassert, twice, but I fixed this and still am recieving the same error message.. . update: i am not including a library called json. The only library that I'm including which is not on the list of allowed libraries in the specs is 'cstdef,' but that was already included in the starter code."|56|0|active|marking resolved as the deadline has passed.||0
l16x9uuhjgf6ps|Calling clear() after every function in List_test| I kept getting valgrind memory leak errors on my List_test.cpp even though it wasn't happening for my List_compile_check or List_public_test runs.I noticed that when I declared a single list with one thing in it, valgrind still said I had a leak. But when I put list.clear() at the end of the test function, no memory was leaked- so I just put .clear() at the end of every function for every list and now I have no memory leak errors. However, I'm not sure if I am supposed to do this. I was under the impression that the deconstructor was supposed to automatically delete it after the last closing function bracket. Does anyone know if you're supposed to manually clear everything?. And if so, what could be wrong with my deconstructor if I am just using clear() in it?|87|0|active|Your pop functions should also delete the node so that they aren't just removed from the list which would leave you with no way to access the nodes and no way to delete them. . . Check that all the functions that are supposed to remove nodes use delete.||0
l16x8l5p1944b1|AG and Compiler differences|I have passed the List Public test on my computer, and my student tests all run without error on my computer, but the Autograder says I am failing both of these categories. Any advice would be appreciated|56|0|active|It is possible that your code passes locally on your computer but not on the AG.Based on your submission, it looks like you have many Valgrind errors that prevent your code from running properly. You can view a description of the Valgrind errors by clicking the red bars on the AG.||0
l16x64zuynv4tb|I don&#39;t want to submit again in case this happens again|. I turned in my project to see how it would go and it's saying that I didn't write any tests even though I clearly did... I don't want to waste more attempts testing if this was a one-off bug or something.|90|0|active|"Looks like you created a function inside of your List class called ""print"", which is preventing your tests from running on the AG.As per the spec, you cannot modify the public interface of the List class by adding new functions."||0
l16x1aem4hi7j9|Exit status of 1|I'm getting this error and I'm not really sure why all my functions are implemented and passing the compile check. |76|0|active|"Looks like you have a line of code doing ""if(iter_node->datum == *i)"".Not that this statement may not always work in a templated class.. . If T is a type int/double/string, there exists a way to compare those types using ""=="".But if I were to implement a custom type called newType, with no overloaded == operator to describe how to compare elements of type newType, then ""if(iter_node->datum == *i)"" would not work and is a template issue."||1
l16wt0w0aqg7bc|When are two lists considered equal?|Are two lists considered equal if the data they hold are the same and in the same order, or if the data + pointers they contain are the same?. Do we even need to include an equality operator for List?|84|0|active|You do not need to implement an equality operator for lists, only iterators.||1
l16wqu84th63w2|Does Iter&#43;&#43; need to work if you pass in an empty list and then add something?|For example, you create an empty list, and an empty iterator. Now you use the iterator to insert an element. But the iterator is still on a nullptr, so if you iter++ is that supposed to work? I don't see how it can but I wanted to be sure.|64|0|active|iter++ should not work in this case, since iter points to a nullptr.If you want to have an iterator pointing to the new element, you will need to create a new iterator.||0
l16wo8f46vz1sv|CAEN Valgrind Permission denied|Hi when I try running my tests on CAEN in order to test valgrind it says permission denied to access List_tests, I was wondering if anyone had insight with this issue?Thanks|51|0|active|`make clean`?||0
l16wo6zo1fn7fo|Error lines in vs code for no reason|"When my partner and I open Project 4, the test case files have error lines on many of the test code, as well as error lines on other files. The error explanations are something like ""forgot a semicolon"" or ""missing ::"" even though the code is written properly.. "|36|0|active|"Do you have #include ""List.h"" and #include ""unit_test_framework.h"" included at the top of your file?. If so, are you still able to compile on the terminal with make List_tests.exe? Sometimes the red error lines aren't correct on VSCode."||0
l16wms3h6z279l|for loop Error in erase() function...|"In my erase function, I traverse through the lists with list traversal (for(Node *p = first; p; p = p->next)). . . When I finished my code, I tested out the erase function, but it gives me an error on the line of the for loop: ""for(Node *p = first; p; p = p->next)"". Is there a reason for this or a way to get around this problem?. . I've tried deleting the pointer (p) outside of the for loop by setting a Node *temp outside of the for loop. However, it still is giving me an error on the line of the for loop..."|59|0|active|@5000||0
l16wlruybbw1ti|Compile check printing out the wrong values|. Does anyone have any idea why it would be printing out 1 for b instead of 0 for the second value?|34|0|active|your debugger is a great tool for answering this question||0
l16we45h30x6nd|Inserting at the end|Say List has 3 elements, all integers: 1, 2, 3.. Iterator itr is pointing at 3.. If we insert the integer 4 at itr, does the list change to 1, 2, 4, 3 or 1, 2, 3, 4?|84|0|active|If itr is pointing at 3, then the insert function would result in the list 1,2,4,3. This is because the iterator is supposed to point past where you want to insert.If you wanted 1,2,3,4, you’d need to pass in an end iterator (nullptr) and hint! check for that condition in your insert function.||1
l16wb4gskgl1wq|memory leak|I am having problems with this memory leak. I have checked over every time I call in new and delete and also checked my destructor which uses the pop_front (in clear). I am really confused as to what the issue is. Also, are we supposed to use clear within each test case/time we use a list or will the destructor do it for me. I have been stuck on this for many hours and the most recent code is submitted to the autograder. Has anyone had the same issue or has tips? Maybe a professor could look at my code? . |107|1|active|If you didn't use new to create a List object in the test functions and you only created them as a local variable, then you don't need to take care of cleaning them up since the destructor will do it for you. . . It is enough to just delete the node. make sure you have deleted it in the pop functions/erase function and any place where you think you need to clean up the memory.. . Please include your unique name in your piazza name. @6. ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkt103pdags15va%2Fda8d89dda04b3d67f5cb76865feffd65526a9e1e6fc8475cf72f5c14656a5c53%2Fimage.png)||3
l16w2hhyun81iz|False positives on test end|Our test end says it has a false positive, but all we are doing is pushing/popping and then asserting what the end is. Where could we be going wrong?|82|0|active|"`end()` is ""one past the end"" - so don't dereference it"||0
l16w06xfytr3os|Valgrind error|I have this error in my valgrind:Screen_Shot_2022-03-25_at_4.35.58_PM.png.. These are my codes for the error lines:. Screen_Shot_2022-03-25_at_4.38.47_PM.png. . Screen_Shot_2022-03-25_at_4.38.59_PM.png|6|0|private|what is your question?||0
l16vvizsd92yx|segmentation error|what might be causing a segmentation fault for the public test case?. |59|0|active|You probably dereferenced a null pointer somewhere.||0
l16v62g74fp4jr|Valgrind Error| |58|0|active|@4929||0
l16ur6dnf4h7f6|node_ptr insert|If we assign an iterators node_ptr to point to the beginning of a list then insert a new node at the beginning of the node does the node_ptr now point to the new node at the beginning or still points at the same node?|69|0|active|Still points at the same node.||0
l16ufvwvzds5aw|Tests giving less points|Originally we are getting a 19/21 on the test cases, but when we write more tests our score goes down to an 18/21 and I don't know why writing more tests would expose fewer bugs.|111|0|active|If you are writing more test cases into the same test then that could decrease your score if one of those new cases is a false positive.. . Say this test gives you 1 point:. . TEST(test_case) {. 	// Good tests. }. . If you were to do this to that same test case. . TEST(test_case) {. 	// Good tests. 	// False positive test. }. Then I believe the autograder doesn't run this particular test case, so you can't get points for it. In other words, the points you gained from this test cases were nullified because of the new faulty one you added.||0
l16ufiyjylc151|Test Cases|Can an individual test case catch multiple bugs if there are multiple functions being tested within the test case?|51|0|active|Yes||0
l16ua4729nf674|erase function failing|. . My erase test function is giving me a segmentation fault and I can't figure out why. The first test of erase in the first image works perfectly fine with my function but the second call of the erase function in my test on a list with two objects results in a segmentation fault. I believe it has something to do with having the node pointers looking at nullptrs but I can't figure out why this would cause an issue and how I could even go about fixing such an issue. Any ideas on what the problem is and how I can fix it?|6|0|private|running the code in your debugger will show you exactly where the segmentation fault is occurring - you can then look at the internal representation of the list to figure out what caused you to arrive at the bad memory access which is causing the segfault!||0
l16u1gn4xpg2cx|Bad Access in List_tests|. When I run my list_tests I get this error, does anyone know how to fix this?. |48|0|active|Maybe you're accessing an invalid object somehow in one of your ASSERT tests. Did you delete something then try to access it?||0
l16u0kkx98d3nr|Issues with traversal by iterator|I am having issues when trying to write loops that traverse through a list by iterator. I have looked at the course notes and other questions, but for some reason I am having the issue of an undefined reference to the Iterator(Node* p) ctor, despite creating a friend class to List in my Iterator class. Is it incorrect to structure the loop in the way I have shown below?. . . . This only occurs when I try to call this->begin() within my insert or erase functions in List.h, I never call begin() at any point in my test files, so I am confused how my reference to Iterator(Node* p) can be undefined if a friend class is called and am editing within the class.|87|0|active|"Your loop here seems fine (although I would personally structure it as the following to make it more ""pretty""). . `for(auto j = begin(); j != end(); ++j) {`. . The `this` is implicit, and you don't need to call the function `.operator++` - you can just use `++j`!"||1
l16tpv417th639|How to test pop_front / pop_back|I have tests for pop_front/back for lists with length > 1. I am trying to write tests for these functions where the list is of size 1, but I am not sure how my assert function would be.. . Should I have an iterator at the front and assert whether than iterator becomes a nullptr or something else.. . |90|0|active|One thing you can test is whether your list size becomes zero, the first and last pointers become null pointers.. ||1
l16temitm4jcu|project 4 autograder|Our test cases are compiling but it says there's an error when it runs and we don't know what's wrong.. |92|0|active|use your debugger! It's great at answering these types of questions (it's very hard for us to answer them comparitively)||1
l16tcte6v732d2|Iter&#39;s Position After Erase|Let's say there's a list of elements connected in this order: 1->3->5. and a valid iterator called iter associated with this list.. . Then calling erase function like this. list.erase(++iter); will erase element 3 right?. . My question is, at this point, if iter is dereferenced, which element should it return? |72|0|active|You didn't say what iter points to. To erase the 3 in the middle of that list we would need an iterator that points to it. You can do this by initializing an iterator with .begin() and then incrementing the iterator once. Then call erase with the iterator.. . After the element is erased, the iterator is no longer valid because it doesn't point to any element of the list.||0
l16t1mzg5144jm|Double Free Error on Assignment Operator Test|One of my tests creates a list, fills it, creates a second list and then uses the assignment operator to set the second list equal to the first, but when I run this test I am getting a double free error. I don't understand where the double free could be coming from. |74|0|active|You should set up the address sanitizer and run on valgrind to see where it happens. After you figured out which functions cause the problem, try to debug it with your visual debugger to see where the double free happens. ||0
l16swqypp6d81|rapid fire queue not open|Can one of the instructors open the rapid fire queue, it says it only opens up at 5 pm|56|0|active|@5035 it closed at 3 and will open again at 5.||0
l16suxksv84305|Dereferencing Null Pointer in push_back|I've implemented the pushback function precisely as shown in lecture, however I'm still getting the valgrind error that maps to dereferencing of a null pointer. Below is the method shown in lecture to deal with this issue which I've implemented.. . |105|0|active|There are a couple of things I can think of that may be causing your error. . Make sure you have the same cases in push_front() (this assumes that the error is happening when you are running List_compile_check)Make sure in your constructors you initialize first, last, and list_size so that they aren't undefined and your code enters the correct case when calling empty(). . For a more specific answer, I would recommend coming to office hours so that we can see your code.  ||1
l16srl4xhzd1e1|Cant understand this valgrind error!|. Hi! Above I have attached the valgrind error I am getting from the test below. I cant understand what it is saying is wrong. I think it may have to do with pointing to a null pointer but I just cant seem to figure it out with debugging on my own. Please let me know if you can help at all! Thank you. . . |7|0|private|Once you call erase on an iterator, that iterator is no longer valid anymore, so incrementing or decrementing it can cause memory issues. I would recommend creating a new iterator after you erase iter. ||0
l16snuw2mql7nq|iterator erase|do we move the node_ptr onto the next element after erasing? in addition, can we pass the iterator by reference so we can just increment it?|71|0|active|No you don't have to do anything to the iterator after erasing, just know that it is no longer valid after erasing because it doesn't point to an element in the list.. . We can't change the starter code function headers.||1
l16rllf3zvk26q|Final mark|Does the final grade take the highest mark in AG or the latest mark?|92|0|active|Highest||0
l16rh494kb52jt|List front() and back()|Are the functions front and back supposed to modify anything?. The reason im asking is because the compile function has the lines . . although both the front and back of the my_list are 42.. . Thanks!|66|0|active|They return the first/last element by reference, so yes, you can use them to modify the first/last element. ||0
l16rb2tbc4d3ei|Bad Access - Assignment Operator|Why is using rhs.node_ptr->datum giving me a bad access error? Is this not how we are supposed to access the datum variable of the node_ptr?. |60|0|active|It might be something wrong with your node_ptr on left hand side. Check if it is correctly initialized ||0
l16r87ufmxg3u6|Project 4 Erase|As long as there are elements in the linked list, should we be able to repeatedly call erase?|77|0|active|Yes the only requirement for erase is. . . //REQUIRES: i is a valid, dereferenceable iterator associated with this list. ||0
l16qp1hx4wb39r|How do I test the copy constructor?|Im writing test cases for the big three. How should I use the ASSERT to check that it works?|94|0|active|You can create List A with certain elements in it and then use the copy constructor to initialize List B to be the same as List A. You can then assert that List B and List A have the same elements inside them and the same size. ||0
l16qor15q3h7i9|Copy Constructor|Is the copy constructor supposed to just copy the values so both lists have the same data, or should both lists be pointing to the same exact addresses on the heap?|71|0|active|the first. You actually don't want them pointing at the same addresses because you run the risk of a double delete. . Your explicitly provided copy constructor should perform deep copy, so that any changes made to one of the lists doesn't affect the other! : )||0
l16qnnrgksnwl|List compile error|"I'm getting this error when I try to run List compile:. Severity Code Description Project File Line Suppression StateError LNK2019 unresolved external symbol ""private: __thiscall List<int>::Iterator::Iterator(struct List<int>::Node *)"" (??0Iterator@?$List@H@@AAE@PAUNode@1@@Z) referenced in function ""private: void __thiscall List<int>::copy_all(class List<int> const &)"" (?copy_all@?$List@H@@AAEXABV1@@Z) p4 C:\Users\cpear\Documents\EECS280\p4\List_compile_check.obj 1 . . I'm not sure what this means. Any help would be appreciated.. . Thanks!"|66|0|active|Maybe this post can help: https://stackoverflow.com/questions/9928238/unresolved-external-symbol-in-object-files. This error may be due to having a function declaration but never writing out its implementation.. . Looking at the error more closely, it appears the issue is with the Iterator custom constructor. It is found in the Iterator class under private and looks something like this:. . Iterator(Node *p) . Make sure you have some sort of implementation for it.. . ||0
l16qnjzcvpu6qx|Rapid Fire OH|. Hey everyone!!. . Since P4 is due today, we are offering some Rapid Fire OH! If you have any quick questions and want to avoid waiting on the queue to have them answered, feel free to stop by. This will be facilitated via. google meet - be sure to join the “rapid fire” queue here & the google meet link here, and you'll have 2 min to have your questions answered!. . . As of right now, the queue will be open 2-3PM & 5-6PM and times will be updated here accordingly.|90|0|active|||0
l16qm3pfnyx2cc|End() and operators|Since the operators require that the current element is deference-able, does that mean we should not include tests with them and end() since end points to one past the last element?|93|0|active|That is correct, do not include tests that increment, decrement, or dereference an end iterator. ||0
l16qguwxcms6cz|Student List Tests Have 0/21... No Idea Why|"Everything is compiling fine, so this doesn't make sense. Any ideas? It has always had a 0/21 and nothing we do to fix it works.. . Please if anyone has ideas! I assumed that it was problems with my list.h functions, but we have fixed all of them, everything seems to compile well and pass on caen and on my computer, and I am completely out of ideas.. . The error just says ""Exit status: 2 No tests run"""|79|0|active|Based on your latest AG submission, it looks like you resolved your issue! Marking as resolved.||1
l16qe92msj479z|Iterator operators (&#43;&#43;, --) going beyond the list|"Do our increment and decrement operator overloads for list have to prevent iterators from going ""past the end"" or ""before the beginning? . . Meaning if i did . . Iterator it = list.begin(). --it;. or . . Iterator it = list.end(). ++it;. . would i have to account for that and have the iterator not move?  or is it the user's responsibility to manage the iterators?"|84|3|active|```. Iterator it = list.begin(). --it;. ```. This is fine since `it.note_ptr` is a valid pointer.. . ```. Iterator it = list.end(). ++it;. ```. This should not be allowed since `list.end()` is already past the end.||0
l16qcufolp72t4|Iterator Assertion Error|When I try running List_compile_check, it seems that the assertion statement assert(i.node_ptr); is not working suddenly, though it was working fine last night and this morning. Does anyone have an idea as to why it's happening?|93|0|active|see followups||1
l16pk0ba3c52r4|Iterator Type Error|Why am I getting this following error? Isn't iterator a pointer?. |71|0|active|Iterator is not a pointer, it is a class which includes a member variable that is a pointer, so you would use the dot operator to access members of the iterator. If you had a pointer of type iterator, you could use the arrow syntax.||1
l16pg4tverz1ud|What does insert do when the list is empty?|If the list is empty, should the code just ignore the iterator that is passed in? As in, for my insert function in the case that the list is empty just take the datum passed in and run something like push_back(datum), ignoring the iterator passed in?. Bit confused about what the RME specifies.|104|0|active|If the list is empty, then yes you can just push the element into the list. You can ignore iterator in this case since it points to nullptr.||1
l16pdofkwo17mg|Should we be able to increment an Iterator in a List of size 1?|Suppose we have a list of size 1:. . List<int> *test = new List<int>();. test->push_back(1);. Then, if we have. . List<int>::Iterator ptr = test->begin();. should we be able to increment ptr using ++?. . Currently, my code allows for ++ptr, but not *(++ptr);. . ++ptr; //compiles without errors. . . ++(ptr); //fails assertion in * operator. . Is it fine to increment ptr at the end of a list so long as it cannot be dereferenced?|81|0|active|I think you can increment an iterator that is pointing to the last element. When you do that, the iterator will now hold the nullptr, so you wouldn't be able to dereference it, so you are correct I believe.||0
l16p30ppiuk627|Change datum via dereference iterator|Should we be able to change datum in list by dereferencing an iterator and setting that equal to a different value:. For example: if i is an iterator to the first item in a list: . *i = 3; . . should the first element of the list now be 3?. |68|0|active|Yep! Since the iterator's node pointer will be pointing to the same thing as `first` (unless you delete said element or insert another element into the front) then modifying the node the iterator points to will modify it in the list.||0
l16ol9dfuod8f|Failing List Private Tests compile check and List Private Tests compile check|We have no clue what is going wrong, as we are pretty sure we are respecting the interface. We created a dummy class to check to make sure we are respecting the templating interface for the List.h file but everything passes. How could we go about solving this problem? |129|0|active|I would take another look at your operator* function. When you dereference an Iterator, the return value should be the datum at that position, not the Node pointer. Remember that Node pointers are internal to the LinkedList and should not be visible to outside functions. ||1
l16oagsptr92k5|Tests work on partner&#39;s computer, not mine|I have an M1 chip while my partner doesn't, and we have been using her computer to write all of our code. Our code for some reason works on her computer but not on mine. When I try to run the compile check on my computer, I get this error:. . List_compile_check.exe(97109,0x1004cfd40) malloc: *** error for object 0x13e6067f0: pointer being freed was not allocatedList_compile_check.exe(97109,0x1004cfd40) malloc: *** set a breakpoint in malloc_error_break to debugzsh: abort      ./List_compile_check.exe. . I was wondering what was going wrong on my end. |88|0|active|I would recommend running your code on CAEN to remove all ambiguity (the behaviour on CAEN should be identical to the behaviour on the AG).. . As for the compile check error, this is likely due to a double delete or a bad delete. Make sure you are only using new/delete to create Nodes and that you are not deleting a pointer if it points to null. It is tricky to diagnose memory issues like this on Piazza, I would recommend going to office hours to get the issue resolved. ||0
l16o9690wok3ex|I keep getting false positive warning for my erase()|I had a list with numbers 5,4,3 inside of it.. . On my test case, I made iterator i pointing to the list.end() and used erase function to get rid of i.. . Since 3 was at the end of the function, shouldn't the list be just 5 and 4 now?. . I made iterator o pointing to the list.begin(), incremented it, and had it assert equal to 4, but it's apparently saying that that following test case has a false positive. . . |124|0|active|"Recall that `list.end()` points to ""one past the end,"" which means it would be pointing to the next ""node"" after `last`, which should be `nullptr`. That means trying to do `erase()` on the `end()` iterator would violate the REQURIES clause of the function, since it needs to be a valid iterator with some datum. My guess is you are having `end()` contain a pointer to `last` rather than one past the end. (since trying to dereference `nullptr` does not work)"||0
l16nri3tkkx3ht|Clarification on Iterator Insert|I've been looking through piazza, but I'm getting a bit confused due to the responses so I'd just like some clarification. To my understanding, we are supposed to be able to insert a node into an empty list through Iterator.insert() even if node_ptr is a nullptr and are we are supposed to be able to insert a node onto the back of the list. Is this correct?|75|0|active|Yes||0
l16nl11lkuq7c1|Error Message - can anyone help debug||49|0|active|Could you try debugging? There are some many errors (possibly caused by just one though) that it is hard for me to know what's actually wrong. I'm wondering if you are using Iterator when it should be T or list perhaps? Are you sure it is just one error?||0
l16n3ngqe5v58h|Iterator Assignment Operator|Is the iterator assignment operator we implemented (assuming we did) the same one being used in list functions such as copy_all, pop_back, and pop_front? |77|0|active|You can use it in those functions but I don't think you have too. ||0
l16mridcrjm6fc|Help with pop_front|![Screen_Shot_2022-03-25_at_12.19.57_PM.png](/redirect/s3?bucket=uploads&prefix=paste%2Fk02pwzbz1h36uf%2F2e09cfa3701ef2368f60b14f6acf8f18912ab805aea9ba24d58179b24ba50347%2FScreen_Shot_2022-03-25_at_12.19.57_PM.png). . This is my pop_fromt function, when I test I keep getting a bad access on the line first->prev = nullptr. and i can't figure out why. Any help is appreciated, thanks!|7|0|private|It is possible that first->next is a null pointer. Make sure you have set the `next` and `prev` fields for the new nodes properly in the push functions.||0
l16m1n2ypi81x2|pop_back error|when i call delete last on my pop_back function it shows the error :. 4(40518,0x1000cfd40) malloc: *** error for object 0x100634d10: pointer being freed was not allocated. p4(40518,0x1000cfd40) malloc: *** set a breakpoint in malloc_error_break to debug|82|0|active|double delete?||1
l16ln8xci4w4o5|Question about == operators|"If I have two empty lists, L1 and L2 and I have two iterators point to the beginning of L1 and L2 separately. Both iterators should have node_ptr points to null. Then I compare the two iterators using the overloaded operator ""=="". Should I get Equal or Unequal?"|95|0|active|If two lists are same type, then yes||1
l16ln8ck7sh6wn|I.node_ptr confusion|I used i’s node_ptr to implement insert and I was told that it should be pointing to the specified position where we want to insert a new node. This makes sense, and I was also told I can use node_ptr’s next and prev variables in the function which I tried and i it gave me no errors when I wrote it, but as soon as I ran the compile check it gave me a seg fault assigning node_ptr-nextWhy did this happen?|102|0|active|Are you considering what happens if `node_ptr` happens to be the same as the `last` node? That would mean `node_ptr->next` is the same as `last->next`, which can be `nullptr`. Consider the different cases when we are performing an `insert`, and what we need to do differently. We can't really help without more context, so feel free to come to OH if you want more assistance!||0
l16li3ldi3r125|Return by reference and iterator to last value in a list|What does the return by reference for the back and front do?. . In our test cases were trying to set an iterator to the last element in a list but we're not quite sure why list.back wouldn't work? Any suggestions on why that doesn't work and what the possible problem would be?|61|0|active|"list.end() won't give you the last element because list.end() is supposed to return ""an Iterator pointing 'past the end'"". Since ""past the end"" isn't the end, you can't access the last element using list.end(). Return by reference just means your returning the object directly instead of some copy of it."||0
l16lb3ne15s3aq|private variables compile error|. . . What exactly do these errors involving the last and sizes variables mean? I assume that it is a problem with my constructors for list, but I can't see why there would be a problem. The only possibility I could think of was that I was supposed to implement them below the classes, but I don't understand why this would be a problem. I've included images of my constructors and copy function for you to see. Any ideas on what the problem is and how I can go about fixing it?|7|0|private|Marking as resolved based on follow-up response.||1
l16l971a3rndq|Autograder Warnings|Hi, we are not quite sure what exactly these warnings mean. They didn't appear on our last submit. Any help would be greatly appreciated. . . |64|0|active|The autograder is complaining about the order in which you instantiate your variables. You'll have to make sure everything is instantiated properly so as to not get this error. Your assert(!nullptr) error is telling you that it doesn't understand how to convert nullptr into a boolean so ! can flip the value from true to false or false to true. I'd also like to point out that, even if this did work, it wouldn't make much sense to have it because assert(!nullptr) would always be true.||0
l16l6hspy7n6xy|Unititialized struct node variables - P4|In the private section of class list, we have to create a struct node, and create two Node* variables prev and next: Node* prev; and Node* next; However, I keep on getting warnings that those nodes are uninitialized. I even set them to nullptr, but it still shows up as uninitialized. How do you remove this error, as I'm unsure on how to initialize a node without using the new operator or setting it equal to something else that's undeclared in that section as well, such as First or last.|62|1|active|did you initialize them in every constructor that you have? What is the error exactly?||1
l16kwisybg16hn|test.01|"Is it normal to have ""Files test01.out and test01.out.correct differ"" when I run make test on terminal?"|51|1|active|These tests are used for the API portion, so if you have not implemented the class yet, (which no need to, since that portion is entirely optional) it is ok to get that. Those files are not used for any part of `List.h`.||0
l16kjadcbiavt|Valgrind works, yet does not compile on the AG|Hi there,My code is working both in my IDE and on Valgrind (it is up to date, everything runs smoothly, no errors thrown whatsoever) but when I submit to the autograder, there's an error compiling list.h, and my Test suite doesn't even compile. So far, I can't figure out what the heck is wrong and I only have a few submits left. Please help!. . Here it can be seen passing in Valgrind.. . Yet here, it fails a whole bunch and I get a 19/42.. . The student list tests compile and run just as they're supposed to, but valgrind reports the error set. . ==90== 168 bytes in 7 blocks are definitely lost in loss record 1 of 3==90==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==90==    by 0x40866E: List<int>::pop_front() (List.h:94)==90==    by 0x408B23: List<int>::erase(List<int>::Iterator) (List.h:314)==90==    by 0x405A09: eraser_beginning() (List_tests.cpp:305)==90==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==90==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==90==    by 0x405F5B: main (List_tests.cpp:349)==90== ==90== 1,776 bytes in 74 blocks are definitely lost in loss record 2 of 3==90==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==90==    by 0x408758: List<int>::pop_back() (List.h:116)==90==    by 0x408830: List<int>::clear() (List.h:138)==90==    by 0x4083F3: List<int>::~List() (List.h:168)==90==    by 0x403BB8: big_size() (List_tests.cpp:31)==90==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==90==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==90==    by 0x405F5B: main (List_tests.cpp:349)==90== . . If everything works alright now, how can I fix the error without having to submit again? How do I even know this is one error and not many?. |159|0|active|Is autograder showing a valgrind error? If valgrind in autograder is showing errors while valgrind in your terminal is not showing errors, you can run a more detailed check like so:. Valgrind output to a txt file. . valgrind --leak-check=full --show-leak-kinds=all --verbose --log-file=valgrind-out.txt ./List_tests.exe. Or valgrind output to your terminal. . valgrind --leak-check=full --show-leak-kinds=all --verbose ./List_tests.exe||1
l16jy3r420m26n|List operator== error|I can't seem to be able to figure out what is causing the issue in my List operator== and its causing an error on my IDE as well as on the autorgrader and I nor others I've asked seem to know what's causing the issue.. . My uniqname is nitinv.. . On the autograder it states: . In file included from List_public_test.cpp:3:0:. 2	List.h:34:24: error: expected primary-expression before 'const'. 3	     List & opperator= (const List &other) {. 4	                        ^. 5	List.h:34:24: error: expected ')' before 'const'. . On my IDE it states: . List & opperator= (const List &other) {                           Error: expected ')'.         if(this == &other) {                                                         Expected expression.             return *this;.         }. . I would appreciate some help! Thanks!|8|0|private|||1
l16jwcea7744vm|Testing iterators|How are we supposed to test our iterator class if the non-default constructor is private? We set list as a friend class of iterator but do not understand how we should be accessing the iterator to make assert statements.|152|0|active|You will need to utilize the public member functions associated with iterators since those are the only functions that are exposed to the user within the testing suite. So I would suggest using the iterator::begin() function to evaluate behaviour at different areas. Unfortunately you won't be able to test the parts of the iterator class unless it's through the public functions.||1
l16jpqi8ijn4j0|false positive and valgrind error|I had a false positive error, as well as a valgrind error. I wanted to know if anyone could help me figure it out? . Thank you! (I thought my things attached guess they didn't sorry!). Screen_Shot_2022-03-25_at_11.27.08_AM.png. . |75|0|active|We can't figure it out if you're not giving us any information in this post||1
l16jhed6x0727j|Unused Variable Victim error - p4|I've been getting this error after running valgrind that says that the variable Node* victim is unused, since I only set it equal to first in pop front and then delete it at the end of pop front. Is there a way to fix this, as I've taken this part of the code from the lectures, and they didn't explain anything about how this would lead to an unused variable. Just to clarify, the statement Node* victim = first was what I took from the lecture and lecture slides in order to prevent memory leaks, but it seems that including this still doesn't help me with that.|73|1|active|"We need some more context to help with this - it should be the case that if you assign a variable and then delete it, that counts as a ""use"". We pretty much need to see the exact error message and corresponding code in order to figure out why this might be occuring"||0
l16hp5wu1oj33h|Testing program|If we get 42/42 on the autograder, is there anything we can do (other than create more unit test cases) to make sure we will pass the private tests? For example in Project 3 we could play the game and see if everything was working|135|0|active|I would say creating unit test cases is probably the best way to make sure you have accounted for all edge cases. ||0
l16h303kfjqw9|Test case throwing malloc (RESOLVED)|"I'm having an error where in my test push/pop front it jump immediately from:. . to:. . in ""0_dyld_start"" immediately when I step over.  What does this mean???. . . I'm able to step through past it but it brings me immediately to pop_front's:. . and this:. . this is my list:. . dont know if thats relevant. . thanks. . "|89|0|active|"issue totally resolved, I had a issue with recursive direction of ""next"" when popping last."||0
l16534fggld1k2|Can&#39;t pass the public test, although passed the compilation test|Why may this be the case? The error is caused by one line Screen_Shot_2022-03-25_at_4.05.23_AM.png|110|0|active|Are you potentially allocating something in your default constructor that isn't being deallocated in your destructor? Keep in mind that for the default constructor, the List will be empty and its `first` and `last` pointers should not point to anything meaningful.||0
l163wa5igxdle|Why is the non-default Iterator constructor private?|As the title reads.|73|0|active|Because Node pointers and Nodes are also private, so even if the constructor were public, you still can't use it outside the class||0
l163mm10rre5fb|Cannot figure out erase() bug|Trying to test erase. Pushed 10 ints into a List and removed one using erase. It removes the correct element, but i.node_ptr points to garbage when it returns (Iterator shouldn't be invalidated either because the list is big enough that something else takes its place).. . When debugging it, i.node_ptr points to the correct element at the end of the erase() function, but when it gets back to main, it switches to junk memory. I tried not deleting p, and that works, and Valgrind passes with no errors, but allocates more than it frees which is a problem. It doesn't make sense that deleting p messes up i.node_ptr because they're not pointing to the same thing anymore, and i.node_ptr is fine until it returns to main.. . I have tried every solution imaginable to get i.node_ptr to keep the correct values when returning to the test case, but it will not work. I drew a diagram of how the code should (and does) work, but it doesn't keep its values when exiting the erase() function. My most recent AG submission has all of this code if an instructor wants to look at it.. . . . |223|0|active|TL;DR: **`erase(it)` is allowed to invalidate `it`.**. . It is impossible for `erase` to make the Iterator it receives point to something else. In the signature of `erase`, notice that it receives `(Iterator i)`. `i` is not a reference or a pointer, so passing by value here suggests that `i` is a copy of the iterator passed to `erase`---conceptually, `i` can be thought of as a copy of a pointer---both the original and the copy point to the same location. `erase` is supposed to delete the Node that `i` points to. Since `i` is passed by value, `i` is a local variable of `erase`, so all changes to `i` in `erase` are thrown away after `erase` returns. As we can see, `erase` has no way of changing where the original iterator points to---it can only operate on a copy of that iterator. Since `erase` deletes the Node that points to, the original iterator has to get invalidated by `erase`.||1
l163i3wgv3e6zp|Autograder Testing Confusion|"I have written a test case that is a valid mutation testing suite. This test case passes when under the ""run"" part of ""Student List tests on student List"", but fails when under the ""Valgrind"" part of ""Student List tests on student List"". Does that mean that this test case runs correctly but has a valgrind error, or is autograder not able to clearly distinguish the error in my code?"|86|0|active|The test runs correctly but has a valgrind error.||0
l16221begws5lx|for loop Error in erase() function|"In my erase function, I traverse through the lists with list traversal (for(Node *p = first; p; p = p->next)). . . When I finished my code, I tested out the erase function, but it gives me an error on the line of the for loop: ""for(Node *p = first; p; p = p->next)"". Is there a reason for this or a way to get around this problem?"|109|1|active|As per the above, trying to deallocate/`delete` the current pointer will render it useless until some reassignment/reallocation, so trying to increment to the next pointer after deleting will not work. You could potentially consider another method to delete nodes, possibly by leveraging functions you already implemented in `List.h`!||1
l161zhqnjej595|Overloading iterator == operator|When we overload the == operator, what exactly are we looking for? Are we looking to see if the datum in each node is the same?|74|0|active|the pointer should be the same||1
l161jqyoeyc67m|Operator&#43;&#43; and --|Hello,. . For the ++ and -- operators, we are returning the copied iterator instead of directly returning *this. However, we are getting this kind of error as shown below:. . . Thanks in advance.|65|0|active|You’re returning a temporary variable from the call stack. The student answer on the post talks a little about trying to return a reference to a variable you made inside a function.@4931||0
l160cdjimxf3l4|Do we lose points for false positives?|On the autograder, do we lose points for having tests with false positives?|91|0|active|No, but they almost always point out some difference in behavior between your submission and the staff solution (assuming you pass your own tests). Because of this, false positives and failing private tests are likely to be highly correlated.||0
l15zrho4p06sg|Weird Valgrind Error on List_tests.exe|"We're failing ""Student List tests on student List"" on the Autograder, even though we've exposed 20/21 bugs. I've looked at other Piazza posts with similar Valgrind errors but I'm still confused about where the error is coming from.. . Could someone please look at my code and help me understand where the error is coming from and how to approach fixing it? I know the issue is in my last test case, but I'm still lost.. . "|5|0|private|The valgrind error of `Invalid read of size 8` corresponds to accessing bad memory, or something that is not contained within the memory of your data structure. (probably trying to access data from a `nullptr` or something that was already freed) It seems that this happens when running `clear()`, specifically with your `pop_front()` function. For Valgrind errors, make sure to read what the error is first, then use the callback trace to easily locate where the error occurred. You might also want to run through the test where this occurs (also in the callback trace) to check the flow of actions within the test.||0
l15z141ba0o3pb|Does deleting a pointer to a struct delete the struct itself?|"For pop_front, I am trying to follow a similar example to what was shown in lecture. However, I am confused as to why the ""victim"" node ptr was deleted. Does setting the victim equal to the pointer to the node you want to delete, and then deleting the victim, effectively delete that node?. "|68|0|active|Yes. The delete keyword will delete whatever dynamic mem object (in the heap) the pointer is pointing to. The pointer itself doesn't need to be deleted because it lives on the stack and will go out of scope eventually.||0
l15ywctl9i23yh|end( )|Should insert() work when the iterator is end(), the nullptr? Is it possible for insert to do the same thing as push_back() ?|133|0|active|Yes, that's the right idea. If the iterator is end(), it should insert it at the end of the list||0
l15yw5tjozn3ju|First wasnt declared in scope error.|. I keep getting this error telling me it wasn't declared in scope even though its part of the class declaration and initialized in the constructor. I know im missing something but I just cant remember what.. . This is all I have for empty, not sure why it isnt working. It should be able to access the first node from the private section of List right?|59|0|active|Notice that the implementation you provided here is above the declaration of `first` in the private section. When the compiler reads your code from top to bottom, it doesn't know about the existence of `first` yet when it reads this implementation. One way to resolve this is to separate function declarations from their implementations by adding top-level implementation stubs after the end of the class declaration for List. Another way is to move these function blocks to the public section after the private section in List.||0
l15xtjbsx4g3at|Templeting Test Compile Check Fail|After looking at question @4560, I am still getting compiler errors in autograder for the List Private Templeting Test Compile Check. I don't believe I accidently used any operators for datums in my List.h, so I am still unsure as to why I am getting an error. Could something else be causing this test to fail?|69|0|active|I also used no visable operators on datum but had the compile check fail.  The way I fixed this was by creating another class with multiple different data types and no functions or operators.  Then you can use that class in tests, and you will have compiling errors if somethng is wrong.  At that point your compiler should tell you what line caused the error.||0
l15xsgsbeny1rx|What causes memory leaks|All of my code behaves exactly as expected, I only have to take care of a bunch of memory leaks all over the place in many functions it seems.. . I suspect I'm not using the delete keyword in the right places. Could I get a general explanation of the kinds of instances where we would need to use delete on something?|108|0|active|As a general rule, any chunk of memory you borrow from the system via `new` should be `delete`d when you are done with it. In my opinion, an effective way to think of allocating and freeing memory is to apply the concept of _ownership_. In this project, your List is considered to _own_ all its Nodes, which occupy chunks of dynamic memory. When you remove a Node from your List, your List is meant to lose access to that Node (when popping, erasing, clearing, etc.), so because the List owns that Node, it is the responsibility of the List to release the memory that Node occupies back to the system.. . This also applies when a List goes out of scope, at which point the List should release all the dynamic memory it owns. Make sure your List destructor reflects this.||1
l15xj31d1uuqr|Aborted (core dumped)|Screen_Shot_2022-03-25_at_12.34.05_AM.png. Screen_Shot_2022-03-25_at_12.33.11_AM.png. Why am I repeatedly getting this error?. |50|0|active|It looks like there is some issue with your Iterator++ implementation. Double check this implementation, and try stepping through your erase_1 test case to see if anything looks out of the ordinary. Also, please update your piazza name per @6 to include your uniqname.||0
l15xavwc6p56nr|Valgrind memory error|Could someone please look at my code and let me know why we are getting these Valgrind errors?. |68|0|active|For the invalid read, take a look at @4783 in the follow-ups for how to disseminate that issue. . . For the second issue, took at @4912 for an example of how to handle lost blocks.||0
l15wv7cq4xg5v8|Helper function for list comparison in List_tests. cpp|Hi there,. . As suggested in another post, I attempted to write a helper function to compare two lists, which looks like this. I do not know why I am getting this error or how to fix it. It would be greatly appreciated if anyone could help me out!. . |9|0|private|I am not exactly sure why this error is popping up. I would recommend just using the auto keyword within the for loop instead of declaring the type outside the for loop. Let us know if that works.||0
l15wl8935ge35x|Iterator insert() confusion|"I understand how to handle this when there are 0, 1, or 2 elements. However, I'm confused on how to insert a node into a list with any more elements than that. Here's my understanding of how insert() works below:. . . The problem is I don't understand how I can insert something in the middle without overwriting another node. For example, if I try to copy i.node_ptr into i.node_ptr->next, to move it over and make a spot for the new element, it overwrites a value. I know there should maybe be ""space in between"" since it's not contiguous, but they're all still connected in a way and I'm just confused on how to insert something in the middle without overwriting something in the process.. . Do I have to do something like setting i.node_ptr to a temporary first, using push_front(), and then resetting the first back to the first element?"|140|0|active|Let's call our new node n,. 1. set n's next pointer equal to whatever the iterator is originally pointing to, since we know n should be right before it. 2. set n's prev pointer equal to whatever the iterators prev pointer is, since technically whatever was before the iterator should now be before n. 3. we need to fix the prev and next pointers for the node before n and the node after n..      - so now we want to say: whatever is before n (n->prev), its next pointer should be equal to n.      - do something similar for the node after n. . ||0
l15waftg5xj5ec|invalid write of size 8 with first-&gt; prev||93|0|active|Looks like you have an issue in your pop_front() function, a few things:. . 1. I don't think it's necessary to consider the case if there are 2 nodes in the list, just checking if it is 1 or >1 is sufficient.. . 2. If there is only 1 node in the list and you delete it, first and last should both be nullptr. . 3. be careful you don't do a double delete||0
l15vydeijdi1ne|List Private Templating Test|Do these private tests just make sure your code works for different templates (ex. int, double, string, etc.) or am I getting something wrong?|115|0|active|You should assume it will test different types||1
l15vvequ4qy32s|test copy_all|"Trying to test cop_all and am getting this error ""use of undeclared identifier 'copy_all"" how should I be calling it?"|109|0|active|copy_all is private and you should not be testing it directly in list_tests||1
l15vt20xcnw1a4|Destructor and Copy ctor|Is it possible that my destructor is not working on my copy constructor lists because of issues within my copy constructor? The destructor works on my other lists where I just use push back and push front.|90|0|active|It's possible but based on your last autograder submit I don't really see an issue with your copy constructor unless there's still something wrong with push_back()||0
l15vssd9sd11lt|Overload operator issue|"""List_tests.cpp:167:11: error: explicitly assigning value of variable of type 'List<int>' to itself [-Werror,-Wself-assign-overloaded]    list1 = list1;    ~~~~~ ^ ~~~~~1 error generated."". . We are getting this error, however we accounted for this by checking in the overload assignment operator to see if the two were equal but for some reason it is not working. What else could possibly be causing this error?"|88|0|active|Your operator= looks fine based on your last autograder submit, try recompiling your code or running Valgrind||2
l15vggevp6k10l|Autograder Issue|For the past two submits, the autograder is telling me that I submitted no test cases. I submitted both List.h and List_tests.cpp, neither of which are empty. The weird part is that, on a March 20th submission, it worked and was able to test the test cases I had made up until that point. Today however, it's saying none were submitted and I have no idea how to fix it. Any help would be much appreciated.. . Edit: The test cases work on my own system just fine, but they still don't work on the autograder.. . |177|0|active|We have not written an operator== for our list class. You cannot compare you lists with == in your tests. Try to find another way to ensure all elements are the same between lists.||1
l15v6frbhfq1p7|Bad access|. When I run my compile check  I get this bad access error but I don't know why. I asked an IA today and he said to see where it's going wrong in compile check as it might be from another function but it's only from pop_back(). I can't see where I'm going wrong as accessing last->prev is acceptable right?|6|0|private|Yes, accessing last->prev is the right way to go. I don't really see an issue here. Run your debugger on the test case and figure out on which line of the test case it threw an error, chances are one of the functions you called in the test case is causing this.||0
l15uza6pxjb79n|List_tests Error on Autograder|When my partner and I submitted test cases for List_tests, this error popped up. Does anyone have a clue as to why this is happening?|82|0|active|You are comparing two objects of different types in your assert_equal(). It says you are comparing an int with an Iterator||0
l15ur0y6xe21kp|Debugger suddenly stopped working|My debugger was working perfectly fine but I just went to run another debug on List_compile_check.cpp and I got this error:. . and my laptop crashes promptly after every time I try to run it now. I didn't change anything, so what happened?|55|0|active|"Is the editor in WSL mode when you try to start debugging? Check the bottom-left corner. If the editor is in WSL mode, then some text like ""WSL: Ubuntu"" should show up there. To get into WSL mode, press F1, search the action ""reopen in WSL"", and press Enter. Feel free to visit us in office hours if this doesn't resolve it!"||0
l15uq59fxt02m8|Valgrind error|Hey,. . I'm getting a valgrind error in my push_back function in the following line:. . . . I understand that I'm getting this because I've created a new node, which I haven't deleted. However, how do I delete this node? I can't delete it at the end of the function, since the whole purpose of the function is the push a new node at the back of the linked list.. Moreover, I don't even have a main function, where I can delete these nodes. So, how do I make sure that they are deleted by the end of the program? Where do I place this code?. . |112|0|active|The students' answer lists most of the functions where the List should (directly or indirectly) call `delete` with Nodes to free their memory. Recall that whenever a List goes out of scope (e.g. at the end of a function that has a List local variable), its destructor gets called. Because the List is going out of scope, your program won't be able to refer to it afterward, so all the memory owned by the List should get freed in the destructor.. ||1
l15u5gshks16gq|Clarification on erase RME|. . So basically the requires says that i is a valid, dereferencable iterator associated with this list.. . I did my implementation only asserting that it is not holding a nullptr, is this okay or do I need to verify that it is actually a ptr to a node in the linked list?. . (basically, is it guaranteed to be inside the list as per testing in the private cases, as its a requires clause?)|140|0|active|Yes, it is guaranteed it will be inside the list||0
l15u32midbh4h4|Initialize Node *first and Node *last|The comments next to Node *first and Node *last say. // points to first (last) Node in list, or nullptr if list is empty, . do we need to initialize those when we declare them or is just initializing them to nullptr in the constructor fine?. . Thanks!|72|0|active|Initializing them in your constructors is fine||0
l15u04jgm8q4z9|Problem with pop_back|When we try testing pop_back with a list of 3 objects, we get an error:. malloc: *** error for object 0x7ff75e4063d0: pointer being freed was not allocatedList_tests.exe(98097,0x1082bee00) malloc: *** set a breakpoint in malloc_error_break to debug. . When we take out 'delete last', the function doesn't throw this error. We were confused about why this might have been happening. We were trying to mimic what was done in pop_front, where we 'delete first' and the same error isn't thrown. Are we not supposed to delete last? Or are we getting this error because we set last to the wrong thing?|111|1|active|Yes you should delete last, but you also need to:. 1. save the node that is second to last. 2. delete last. 3. reset last to be the second to last node that you saved. 4. make sure last->next is set to nullptr||1
l15tvkbulaa3z6|test end()|How do we test for end()? |127|0|active|You should combine it with insert()||1
l15trmx2qri7o3|SIGABRT error in pop_front|Screen_Shot_2022-03-24_at_10.46.56_PM.png. . After I added tests from the compile check into our List_tests I got this error. However, our code passes the compile check normally when run from that file. What could this mean?|64|1|active|"""Pointer being freed was not allocated"" sounds like a bad delete. Try checking for places in your code/test that may be deleting a non-heap address. (valgrind can be a helpful tool for this)"||1
l15tnxmbaw7232|valgrind leak help|We've been getting this error in valgrind, but have no idea what this means. For reference, line 651 in our List_tests.cpp is the last line (TEST_MAIN()). Any ideas?. |75|0|active|You are potentially not deleting all the nodes that you need to delete. I would double check your destructors and pop functions.||0
l15tg27srn33ez|List Compile Check error|Can anyone shed some light on what might be causing this issue?. . List public test runs fine and my test cases that I wrote are running with no errors thus far in my IDE. . . List private test case compile check is giving an error as well.. . . . |91|0|active|Adding onto the student's answer. Specifically check the return type of your operator*||0
l15tbd2ld9t51j|no such file or directory autograder|I submitted my code to the autograder but in the public tests section my error output was . 1bash: ./List_public_test.exe: No such file or directory. . How do I fix this? I think the last time this question was asked it was because of returning from a constructor but I don't think I've done that in my code.|69|0|active|you shouldn't have i++ in your tests, change it to ++i||0
l15t2zt7y2155y|last not initialized|"I found out that, strangely, my constructor is not initializing ""last"" even though I initialized it just like first and first worked. I wrote List<int> copy = list in test, and when I step on, not yet pass, it looked like this:. . What might went wrong? And I'm wondering what's the difference between. List<int> copy = list;. and. List<int> copy;. copy = list;. The first one is not working while the second one is fine (List<int> copy successfully initializes first and last)"|78|0|active|That's strange, double-check your constructors is working, the initializer list should be something like: :first(nullptr), last(nullptr){}||1
l15srlgtfgy4td|Question|Hi, . . I have a question: I know that I haven't implemented this function yet, because I know that we need to do something with the nodes... and that is we need to delete the lines, in order to connect the new lines, for the new node, right? and I'm not able to convert it into the code.... . |8|0|private|You're very close, if the iterator i == end() or begin(), then you can push_front() and push_back(), just make sure you pass the datum in as a parameter. For connecting n's prev and next pointers, that looks fine so far, just don't forget to fix the next and prev pointers for the nodes that are next to n.. ||1
l15smii5jlc56f|Duplicate symbols for architecture|. . Good evening, everyone. My code for List.h gets a full mark on AG, but it keeps getting this error when I run on XCode. May I know what it means and how to fix it? Thanks in advance!. |57|0|active|Double check your compile sources, what do you include in the build?||0
l15skhjj9ra2fi|Confusion on deleting/clearing node objects|"If in my pop_back() function, for instance, if I did something such as:. . first = last. And then did:. . delete last. What happens to the first and last object? If they point to the same object, then they both just point to nothing after running ""delete last"", right? I'm a bit confused, because if after I exit the scope of the pop_back() function, and then call front() or back(), it actually shows that they both still point to an object, and return the value of that object. . . What could I be doing wrong in this case?. . Edit: To clarify, front() and back() do the same thing while still in the scope of the pop_back() function.. Edit 2: In this example the list is of length 1 and pop_back() results in it being empty. Thus I would think front() and back() point to nothing"|88|0|active|did you reconnect the nodes after that?. ||1
l15sjss8vky3ev|Test cases comparing nullptr|I get an error whenever I assert something equal to nullptr, what can I use instead for my test cases.|130|0|active|Yes you should not be doing comparisons with nullptr.. . I guess it depends on what you're testing. What were you trying to accomplish in that test case?||1
l15saou7so76rf|Valgrind Error p4|Hi I have been getting these errors in Valgrind for students list tests in autograder - What do I need to fix? Thanks!!. . ==92== Invalid read of size 42==92== at 0x408848: bool safe_equals_helper<int, int>(int const&, int const&) (unit_test_framework.h:293)3==92== by 0x407E0A: safe_equals<int, int&, void>::equals(int const&, int&) (unit_test_framework.h:323)4==92== by 0x407206: void assert_equal<int, int&>(int&&, int&, int, char const*) (unit_test_framework.h:333)5==92== by 0x404AFA: UuAnOpp() (List_tests.cpp:225)6==92== by 0x4021C0: TestCase::run(bool) (unit_test_framework.h:420)7==92== by 0x4028EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)8==92== by 0x404B92: main (List_tests.cpp:262)9==92== Address 0x5ab8810 is 16 bytes inside a block of size 24 free'd10==92== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)11==92== by 0x406774: List<int>::pop_front() (List.h:108)12==92== by 0x404A92: UuAnOpp() (List_tests.cpp:222)13==92== by 0x4021C0: TestCase::run(bool) (unit_test_framework.h:420)14==92== by 0x4028EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)15==92== by 0x404B92: main (List_tests.cpp:262)16==92== Block was alloc'd at17==92== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)18==92== by 0x406671: List<int>::push_front(int const&) (List.h:53)19==92== by 0x404A12: UuAnOpp() (List_tests.cpp:217)20==92== by 0x4021C0: TestCase::run(bool) (unit_test_framework.h:420)21==92== by 0x4028EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)22==92== by 0x404B92: main (List_tests.cpp:262)23==92==24==92== Invalid read of size 825==92== at 0x406A06: List<int>::Iterator::operator--() (List.h:223)26==92== by 0x4048EE: urop() (List_tests.cpp:207)27==92== by 0x4021C0: TestCase::run(bool) (unit_test_framework.h:420)28==92== by 0x4028EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)29==92== by 0x404B92: main (List_tests.cpp:262)30==92== Address 0x5ab9dd8 is 8 bytes inside a block of size 24 free'd31==92== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)32==92== by 0x406616: List<int>::pop_back() (List.h:126)33==92== by 0x4048E2: urop() (List_tests.cpp:206)34==92== by 0x4021C0: TestCase::run(bool) (unit_test_framework.h:420)35==92== by 0x4028EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)36==92== by 0x404B92: main (List_tests.cpp:262)37==92== Block was alloc'd at38==92== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)39==92== by 0x4064F1: List<int>::push_back(int const&) (List.h:86)40==92== by 0x404862: urop() (List_tests.cpp:201)41==92== by 0x4021C0: TestCase::run(bool) (unit_test_framework.h:420)42==92== by 0x4028EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)43==92== by 0x404B92: main (List_tests.cpp:262)44==92==45==92== 96 bytes in 4 blocks are definitely lost in loss record 1 of 246==92== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)47==92== by 0x4065CA: List<int>::pop_back() (List.h:119)48==92== by 0x403C15: test_12345() (List_tests.cpp:37)49==92== by 0x4021C0: TestCase::run(bool) (unit_test_framework.h:420)50==92== by 0x4028EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)51==92== by 0x404B92: main (List_tests.cpp:262)52==92==|160|0|active|Do these posts help? @4926||1
l15s9fummom6u9|Public_test|What is needed for public test again? . |68|0|active|It's only that one test given in the starter code. You'll see it just requires you to initialize an empty list.||0
l15s4re3dyt641|erase and iterator|if the iterator points to an element in a list, and you call erase to delete that element, what does the iterator now point to? should we make it a null pointer, or should it point to the next element in the list if there is one? |156|3|active|We don't know what the iterator would point to, and you don't need to worry about it in your implementation. In your test cases though if you use an iterator to erase something just reset it to begin() to avoid undefined behavior.||0
l15rzgwlx9l5cd|P4 Error message|Hello,. I'm getting this error message and I'm not sure what it is referring to?. . Thank you. . . |7|0|private|It means you are trying to dereference a nullptr. If you look at the state of remove, it's next pointer is null. So when you try to get the prev of remove->next you are making an attempt to dereference a nullptr which is not allowed.||0
l15rrkt582234k|Stringstream Error?|. . Are we allowed to use string stream to test List.h and are we allowed the #include <string> and #include <sstream>? . We did and submitted, but Autograder said that none of our tests were submitted. |59|0|active|Looks like you guys ended of fixing the issue. If you can, please update with the solution so others may see this if they have the same issue.||1
l15rqkwv73p6xm|Massive issue finding tests.|Stuck at a plataeu of 15/21. Ideas? I have tested the operators! I have tested compile test! I have tested copy and assignment.|177|0|active|Just to clarify the students answer. 1/2 means 1 or 2||0
l15rfbtiuvk2w9|Help with Valgrind Error on List_compile_check|There seems to be more allocs than frees, but I'm not quite sure where to go from there.. |62|0|active|The problem is in your push_back function, if the list is empty, maybe try setting first and last's prev and next pointers equal to nullptr||0
l15rf4q6m544vo|not getting undefined behavior when dereferencing the erased iterator|"Could anyone run the test code from the lecture and see if get the same result? I was using most of the codes directly from the lecture and pretty sure that I deleted the node when erase and pop. My code mostly are from the lecture and I'm not getting undefined behavior.. . #include <iostream>. #include ""List.h"". . int main(){. List<int>list;. list.push_back(1);. list.push_back(2);. . List<int>::Iterator it = list.begin();. List<int>::Iterator it2 = list.begin();. . std::cout << *it << std::endl;. std::cout << *it2 << std::endl;. . list.erase(it);. . std::cout << *it << std::endl;. std::cout << *it2 << std::endl;. . }. "|116|0|active|"Undefined behavior does not mean it will always print the wrong value. It means that you cannot make any guarantees about what the value will be. This often happens because when data is ""deleted"" it is often just released. The underlying memory is not necessarily overwritten right away."||0
l15rbxwil8n7gb|understanding command line output|sorry, nvm|8|0|private|resolved||0
l15r5m7bezu1vh|Assertion !empty fails|For whatever reason my assertion at the beginning of some of my test cases is failing even though in the case i just create a new list so nothing should be in it and my empty function implementation is straight from lecture. Why is this happening?|93|2|active|Could be caused by some variables not being initialized. Is your size being set properly and your first and last pointers being set as well?||1
l15qr6nrth92qc|T&amp; front() function|Hi, I keep running into this error when I run my code, even tho all my tests are passing. i'm just confused because there is no such error for the T & back() function, and it's the exact same code just with a slight alteration in the return statement to fit the function. Please let me know what I can do !|9|1|private|Your issue might be in your test. How are you calling front() in test_pop_front?||1
l15qr4kbi2v2j2|Valgrind Error: operator new(unasigned long)|![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkswkxlvz8t52ut%2Fad5aa14a2da97ecc1093320ae49d77f48ede6863a285574cc89e99edcc4675f6%2Fimage.png). I'm not sure what this means or how to interpret this...|73|1|active|The first line implies you have some kind of memory loss. It looks like you use the new operator in the erase function. Make sure you call delete for every new keyword.||1
l15qprh6vty4re|First, last initialized as nullptrs|We are initializing first and last as nullptrs. Because of this, we create new Node*s and set their datums equal to the given datum and set first, last equal to these new Node pointers. We are deleting the pointers at the end of the function.. . Is there a way to not have to do this and just initialize first and last's datum values to the given value without creating new pointers and assigning them? We currently have a lot of Valgrind errors and I am trying to rule everything out.|60|0|active|If you are creating a new node in a function, you likely shouldn't be deleting anything in that same function at the end. I imagine you've probably created a node like `Node * newNode = new Node()`, then deleted the newNode pointer at the end. You should be careful though because even though newNode is a temporary pointer you're using to store the new node's address, deleting it means you're deleting the Node you've just created (and attached to the list when setting first/last to that node). That's possibly why you're getting valgrind errors, because your first/last pointers would end up as dangling pointers (not pointing to a valid node in memory)||0
l15qcb2fgm4549|False Positive Error|. I'm getting a false positive error on this test case, but I can't deduce where it stems from.. . P.S. I wasn't sure if posting this would be an honor code violation, so I posted it to Instructors only.|7|0|private|end() gies you a iterator one past the end (not the end) which is a nullptr. Therefore when you try to compare it1 and it2, you are comparing a node at the end and a node one past the end.||1
l15q5oxjb47g|Valgrind Errors|I have a lot of Valgrind errors. Can someone please help me interpret what these mean?. . |58|0|active|"""Invalid read of size 4"" means you are accessing some memory your shouldn't be, and line 6 is describing that memory: ""Address 0x... inside a block of size 24 free'd"", the memory you are accessing was deleted. In other words, you have a dangling pointer somewhere in your code."||0
l15pw7kbxp114|Memory leak causing undefined behavior?|When I run our test cases, sometimes the tests pass, and other times, they don't. I never change the code; I just run through the debugger. The tests fail at various places and point back to some nullptr. Is this because of a memory leak? Could a memory leak be causing this behavior? How do I fix this?|72|0|active|I think it's certainly possible that something is causing undefined behavior. Maybe run the code through valgrind?||0
l15pv2ownv73e8|0.01 != 0.01|![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkswkxlvz8t52ut%2F7ccb3ac61baec4bec871b371586f41bb6d7f65ac587ba28b377d68cdc97a551b%2Fimage.png). How does 0.01 not equal to 0.01?|64|0|active|I got the same issue earlier. I believe it's because the way floats and doubles work, it might lead some obscure 0.000000000000000000003 somewhere down the line so it's not *exactly* equal, even though it should be. I'd recommend you use the ASSERT_ALMOST_EQUAL(first, second, precision); to circumvent this. I hope that helps.||0
l15pq403av9427|Valgrind Error on student lists test on student list|Screen_Shot_2022-03-24_at_8.51.39_PM.png. How do I get rid of this error?|101|0|active|. . I'd recommend taking a look at @4912, @4836, @4835. All of them are variations on the valgrind error you're getting.. . . ||1
l15po6munfy4wy|template format|for function Iterator& operator--() , . can I use the following code to define it outside the class?. . template<typename T>. typename List<T>::Iterator & List<T>::Iterator::operator--() {. ///. ). Or there is another way to do it?. . And also I am confused how to do the following  Iterator contructor?. template<typename T>. typename List<T>::Iterator::Iterator():node_ptr(nullptr){};|75|0|active|You should define your functions inside the class, operator()-- should already be done for you.. . When you define the constructor in the class its just gonna be Iterator():node_ptr(nullptr){}||0
l15p8on195v7jq|Confusion w/ Iterators|How can I use my iterator, from using .begin(), to not only move onto different values, but also check if datums are equal?|77|0|active|You should have an overloaded == operator in your code in the Iterator class. As for the first question, just do ++i ||0
l15p6o1q4b93o9|problems happen on functions that are not revelent|"I just finish testing iterator and find no mistake. However, after testing before the ""}""  of this test function, I faced bug that told me I have mistake on pop_front, clear, ~list and run bool and it ended up without finishing the test. Can anyone tell me where I am wrong? Thank you!"|87|1|active|When a object goes out of scope (like at the end of a testing function) its destructor will be called. From your message it looks like the issue might be in pop_front() function when it is called from clear().||0
l15ok8upeql18x|dereferencing an erased iterator still gives the value|"So I've tried to dereference an erased iterator and it still gives the value that the iterator originally points to. I've tried the similar case on lobster and got the similar result. Is this also considered as ""undefined behavior"" ? I'm very sure that I've deleted i.node_ptr for the project."|120|0|active|As the student answer stated, you would get undefined behavior. ||1
l15nofh4z7335t|Error message in XCode|"I'm currently trying to run the compile check for List, but everytime I run it my XCode freezes up and after about 30 seconds or so, this error comes up on my terminal saying ""Xcode has killed the LLDB RPC server to allow the debugger to detach from your process. You may need to manually terminate your process."" I don't have any breakpoints set and I've tried exiting then entering again. Does anyone know what the cause of this is and/or how I could fix it? . Screen_Shot_2022-03-24_at_7.54.12_PM.png"|58|0|active|I would try to force quit Xcode: https://support.apple.com/en-us/HT201276 . ||0
l15no47zqda1zk|Using -- on end iterator|The -- starter code requires that the iterator being decremented is dereferenceable. Does this mean that we can't use -- on an iterator pointing to the end of a list because its node_ptr is nullptr?|118|0|active|If you mean using the .end() function to assign the iterator, you are right that you can't then use -- to move it back to the last point in the list because .end() just returns an iterator that is past the end, not necessarily 1 past the end of the list so yo.. . If you set the iterator using .begin() and then increment it to the last position in the list, from there you can use -- to go back.||0
l15no1b42x3ly|Erase() the last iterator|I am confused about what element would be erased if you use the iterator for last. For example.... . list contains ( 3 2 1). . and you run this code.... . .     List<int>::Iterator it = list.end();. .     list.erase(it);. . . What would list contain?|140|1|active|end() points to one past the end so calling erase() on end doesn't actually delete anything from the function. Instead, if you want to delete the last position you should set the iterator = list.begin() and then use the ++ operator as many times as necessary to get to the end.||0
l15nm5guv0f2ud|.end() and erase|Is it possible to implement a .erase() test case using a .end() iterator if .end() just points to a nullptr that's outside the list?|140|1|active|Per the requires clause (i is a valid, dereferenceable iterator associated with this list), you would not be able to. end() returns an iterator one past the end of the list which means you cannot dereference it||0
l15ndnz9kq471|question on--iterator.end()|Should --iterator.end() supposed to be working?|48|0|active|No, it should not work since list.end() should return a nullptr. The given implementation for -- checks to make sure that you don't pass a nullptr.||0
l15n9n814a7i1|Do TEST&#39;s count as functions|And should they be less than 40 lines if so to avoid failing long line style checks.|76|0|active|I'm pretty sure test cases are supposed to be less than 40 lines long.. . Regardless, your test cases should be pretty short and only test one behavior each. This makes it easier to find specific bugs.||0
l15n7u1h94e46b|segmentation fault in pop_front||4|0|private|I asked many classmates about this problem I met, and they all said the code looks good and had no idea what's going on... It seems like the code fails at the line I set first->prev to nullptr, but that's really weird||0
l15n56yhfhf2f5|Testing default constructor|I want to test the default constructor by making an empty list and doing ASSERT_EQUAL(list.front(), nullptr) but it says that I cannot use comparison operators against nullptrs. Is there any other way to check whether the first element of a list is nullptr?|155|0|active|There's other member functions of lists you can test in that edge case (I'm not exactly sure if I'm allowed to tell you what they are for honor code reasons with sharing test cases but it should be pretty apparent if you scroll through the list class :))||1
l15mmmzpgyc5nd|Can someone help me translate this meme of an error message???|I admit, I sometimes procrastinate a bit.. . I did my first AG submit today and got 6/42 and a host of errors and warnings. Can someone help me translate these/figure out what isn't allowed and whatnot? I know at least one error was that I incorrectly initialized a Node struct with parentheses instead of curly braces. What does this other stuff mean?This compiles fine in my IDE btw.. . In file included from List_compile_check.cpp:3:0:List.h: In instantiation of 'T& List<T>::front() [with T = int]':List_compile_check.cpp:26:19:   required from hereList.h:152:11: warning: reference to local variable 'star_this' returned [-Wreturn-local-addr]         T star_this;           ^List.h: In instantiation of 'T& List<T>::back() [with T = int]':List_compile_check.cpp:27:18:   required from hereList.h:160:11: warning: reference to local variable 'star_this' returned [-Wreturn-local-addr]         T star_this;           ^List.h: In instantiation of 'List<T>& List<T>::operator=(const List<T>&) [with T = int]':List_compile_check.cpp:33:11:   required from hereList.h:120:14: error: lvalue required as left operand of assignment         this = new List;              ^List.h: In instantiation of 'void List<T>::insert(List<T>::Iterator, const T&) [with T = int]':List_compile_check.cpp:36:28:   required from hereList.h:341:50: error: new initializer expression list treated as compound expression [-fpermissive]         Node* new_node = new Node(0x0, 0x0, datum);                                                  ^List.h:341:50: warning: left operand of comma operator has no effect [-Wunused-value]List.h:341:50: warning: right operand of comma operator has no effect [-Wunused-value]List.h:341:50: error: no matching function for call to 'List<int>::Node::Node(const int&)'List.h:21:12: note: candidate: List<int>::Node::Node()     struct Node {            ^List.h:21:12: note:   candidate expects 0 arguments, 1 providedList.h:21:12: note: candidate: constexpr List<int>::Node::Node(const List<int>::Node&)List.h:21:12: note:   no known conversion for argument 1 from 'const int' to 'const List<int>::Node&'List.h:21:12: note: candidate: constexpr List<int>::Node::Node(List<int>::Node&&)List.h:21:12: note:   no known conversion for argument 1 from 'const int' to 'List<int>::Node&&'List.h:342:22: error: no matching function for call to 'List<int>::connect_nodes(List<int>::Node*&, List<int>::Node*)'         connect_nodes(new_node, *i);                      ^List.h:98:10: note: candidate: void List<T>::connect_nodes(List<T>::Node&, List<T>::Node&) [with T = int]     void connect_nodes(Node &left_node, Node &right_node) {          ^List.h:98:10: note:   no known conversion for argument 1 from 'List<int>::Node*' to 'List<int>::Node&'List.h: In instantiation of 'void List<T>::copy_all(const List<T>&) [with T = int]':List.h:127:17:   required from 'List<T>::List(const List<T>&) [with T = int]'List_compile_check.cpp:32:28:   required from hereList.h:33:19: error: ISO C++ forbids comparison between pointer and integer [-fpermissive]         if(&other == empty()) {                   ^List.h:57:30: error: no matching function for call to 'List<int>::connect_nodes(List<int>::Node*&, List<int>::Node*&)'                 connect_nodes(last_node_copied, node);                              ^List.h:98:10: note: candidate: void List<T>::connect_nodes(List<T>::Node&, List<T>::Node&) [with T = int]     void connect_nodes(Node &left_node, Node &right_node) {          ^List.h:98:10: note:   no known conversion for argument 1 from 'List<int>::Node*' to 'List<int>::Node&'|220|0|active|"It definitely looks intimidating, but if you read each part I'm sure it'll be easier to understand. The first error says ""reference to local variable"", which means that you're trying to return a variable that only exists in the function (i.e. you made the variable in the function). This is problematic because the variable should disappear after the function, so that means that the reference to that variable might be invalid if it's destructed once the function is completed (this is a problem because of undefined behavior, I'd recommend looking at @4940, which has a question regarding deleting something and why it still works. I believe this is essentially what happens on your end and that you happen to get lucky so these errors aren't thrown). This appears to be the same error for a few of the functions you wrote so just make sure that you aren't returning a reference to a local variable. If you look at the ""List.h:152:11"" part, you can see where the error is located in your code (in that particular case, row 152 col 11).. . For your 2nd unique error, ""lvalue required as left operand"", it's complaining about this = new List(). If you want to make your list empty, I would recommend calling the clear() function instead of what you have written. I'm sure that you'll be able to figure everything out once you take a more thorough look. Hopefully what I said earlier helps. If not and you're finding it difficult to diagnose all of your errors I'd recommend going to office hours.. . "||0
l15mmirw2t711s|Forward and Backward in Project 4|"In lecture, when we made the singly listed list, we had ""next"" point away from the ""first"" element and towards the ""last"" element. However, in my project four, I consider the ""first"" element to be the ""front"" and the ""last"" to be the ""back"". As such, ""previous"" points towards the last and ""next"" points towards the first. As long as I'm consistent about this inside my code will this be alright or will I need to flip everything?"|74|0|active|I believe in our implementation first→prev and last→next should both all point to nullptr||0
l15lu8k4hiw6d1|Valgrind Error|I am able to compile and run List_tests.cpp, and all my test cases pass. I'm not sure why I am getting this error under both run and valgrind. I triple checked that I used clear() on each list after using it.. . |126|0|active|It is very likely that you forgot to initialize the `next` and `prev` fields for the new nodes that are created in the two push functions. Another reason could be you forgot to initialize the private variables in the class constructors.||1
l15kw8k4acq5v0|Office Hours Issue|I was on the office hours queue and I was popped off without notification. I am also not able to get back on the queue because it says I am already on it. I was wondering if there is anyway to get around this issue. My unique name  is vidongre |66|0|active|Sorry you were not able to be helped on time, keep in mind that when you are near the top of the queue we expect students to be ready and in their meeting since we don't give notifications before we pop students.||0
l15ktm7caxb5v4|Iterator in middle|I am trying to test my Iterator insert/erase functions and I am just wondering how can I access middle elements of my list.. . Right now I am doing list.begin() and list.end() but I want to try and insert/erase elements in the middle of the list. . . Update: Resolved.. |7|0|private|Resolved||0
l15kp0s5sg27cq|VALGRIND ON STUDENT LIST||128|1|active|I'd recommend taking a look at @4912, @4836, @4835. All of them are variations on the valgrind error you're getting.||0
l15kkldnlupxe|question about iterator|what happens if you have an iterator that points to an element but then you clear the list|106|0|active|The iterator would be invalidated. If you use it again, you can get undefined behavior.||1
l15kcdkhq176w2|How to Traverse through other for copy_all()|I've tried setting a for loop and traversing through other with an iterator, however I keep getting an error when trying this. Could anyone help please?. . |102|0|active|The students' answer is true, but without knowing your exact error we can't identify a guaranteed fix. If the student answer didn't fix this, please share the error message with us.||0
l15kc3llem15z9|Print function|Do we have to make a print function for the list.|61|0|active|I don't think so||0
l15k61tfsr4378|0/21 on Student List Tests|Hello! I've been having this problem all day now and I'm not able to solve it. My tests compile fine on CAEN and there are no memory leaks and no issues with Valgrind, but I keep getting an exit status 2 on my tests without any response as to how to fix it.. I wasted a lot of submissions trying to fix it, and so far I've tried minimizing the amount of test cases (It's well under 5 seconds regardless), and making sure all the private functions stay private, and I'm not creating any public members besides parts of the Big 3. I was wondering if someone can take a look at my latest AG submission and pinpoint the problem? I'm totally out of ideas. Best, Milly|11|0|private|It looks like you were able to fix this issue based on your latest AG submission, feel free to post a followup if this was not the case.||0
l15juqho2cy6nn|false positive project 4|. I want to ask why this test case reports false positive. Thank you!|8|0|private|You shouldn't call the destructor manually. This will cause your destructor to run once when you call it manually and another time once the list goes out of scope (ie when the test function ends). This will result in a double delete which may cause issues in the AG||0
l15jup16kkk2al|Compile Check Errors|"Im not sure what is wrong with this. I am running the compile check but it doesn't run and says that ""iter"" is an int but 5 lines previous it worked as a pointer so I am not sure what is going wrong.. . . . "|67|0|active|It looks like you're dereferencing an int. I'm guessing this is occuring in your overloading of the derefernce operator because List.h won't compile until all of the operator overloads are implemented. I can't say for sure, but I'd check what your trying to return and how you're returning it in your implementation of the dereference operator. This operator should return the datum of the node that the iterator points to.||1
l15jqh05z4u1av|Can&#39;t fix Valgrind error|After fixing this Valgrind error for multiple functions, I'm still getting it on one with a certain test case but can't figure out why despite debugging. (I looked at @4706 to fix my previous errors). I've attached my test case, error, and push_back() functions for reference. Thank you.. . Screen_Shot_2022-03-24_at_6.07.23_PM.png. Screen_Shot_2022-03-24_at_6.05.28_PM.png. Screen_Shot_2022-03-24_at_6.05.10_PM.png|11|0|private|This error usually means that you have a memory leak somewhere (created new memory and didn't delete it). @4912 might be helpful for this||0
l15janwqmwk4f|Question|Hi,. . I have a question: Why am I getting this error? I'm trynna figure this out, I do not know where this error is at, I think that It is either in the Erase or Insert function, but I don't know what is it. . |8|0|private|Check on line 137 of list_tests.cpp. Keep in mind that you can’t assert equal between something and a nullptr.||0
l15j2tef4es3sx|List Compile Check|For some reason, when I run the List_compile_check command via my command line, it provides an error, but it seems to work fine on the Autograder... any reason why this might be happening and/or will it be problematic?|54|0|private|What's the error||2
l15iy9j4dry2at|Iterator destructor, copy, and assignment constructor|I am a bit confused as to how to go about doing these. Specifically, I am not sure how an iterator destructor would work|148|0|active|For iterator, you don't have to customize the big three. The default one will work just fine.||1
l15iegxkone115|Nested List|Do we have to test a list nested in a list?. . Thanks|72|1|active|I don't think so. I didn't test that and got all of the points for test cases.||0
l15i0ao9qp54le|Leaking Memory|On autograder my Student List Tests is failing valgrind and passing everything else, It says bytes are lost and I am pretty sure everything is getting deleted. I even went to office hours and we thought we fixed it. I'm not sure what I'm doing wrong.Screen_Shot_2022-03-24_at_5.17.47_PM.png|205|0|active|"Inside your insert function, it seems you are always creating a new node. However, in some cases, you call push_back/push_front right afterwards. These push functions will also create a new node. So the new node you created in insert is ""lost"" by the ones you create in the push functions instead. Does this help?"||2
l15hzay6d9giu|Where do we implement functions?|I'm a bit confused on where we need to implement some of these functions. For example, previously I had all of my list constructors/destructors/copy constructor/assignment operator implemented at the very bottom, with  template<typename T> in front of each of them, until my compiler didn't like what I was doing with the overloaded assignment operator, so I moved it back up front to where they were declared in the public implementations of List and it worked with my compiler.. . So I guess my question is why does it require template<typename T> in front of certain areas and not others? Does it make a difference? Should I be implementing functions such as copy_all() at the bottom with a template<typename T> in front of it or will it work if I implement it where it is declared?|177|0|active|1) According to the spec, you can implement functions wherever you see fit. However, to your question, there is a nuance about using template<typename T>. You must use it if you implement functions for List outside of the class declaration (as it seems you are trying to do here), but not if you are implementing functions inside of the class declaration. It definitely makes a difference.. . With that in mind, if you implement copy_all(), where you choose to implement the function (write the body of the function) will affect whether or not you put template<typename T>. If you choose to implement copy_all() in the declaration, you don't need to use template<typename T>, otherwise, you do need to use it.. . ASIDE: While these are valid concerns, it seems you are having another issue with your function definition. There is no return type! Through List<T>::, you are showing which class the function comes from, but not necessarily what type the function returns. Think about what you are trying to return when assigning an operator (i.e. bool, List, a reference to a list, etc). You've got this!||0
l15hdobsra35aw|Valgrind Error Help|I am not very sure how to analyze the Valgrind errors from autograder. What I see here is a potential problem of push_back function on line 65, but to my understanding, push back should not delete any nodes, so why should that cause a problem?. Thank you!. . |194|0|active|This is actually a common misconception when identifying valgrind errors, that you should take valgrind literally. The problem is not in your push_back function, the error message just means that you are creating a new node in your push_back function, and that node was not deleted by the end of your program. Same with copy all and operator=, in these functions you are creating new nodes, and those new nodes were not destroyed||1
l15hb7chr1gou|Error|Cannot refer to type member 'Node' in 'List<int>::Node' with '->'|57|1|active|Because Node is a private member of List class, you can't access it outside List class's definition.||0
l15h67lbwyv2e4|Iterator first/last|When and how am I supposed to set my first and last values for iterator?  They will be the same as list yes?  can I simply use the list object first/last nodes when going about constructing an iterator?|134|0|active|"Yes, you could just use first and last to construct iterators (the private non-default constructor in the iterator class). But note that the ""end()"" function returns an iterator that is ""past the end"", so the iterator for end() should contain a ""nullptr"" rather than ""last"""||1
l15h66lh2eu18v|Creating a Node pointer in List_tests.cpp|. I'm trying to create a Node pointer in the test file, but I can't figure out the right notation. I keep getting different errors.|63|0|active|The students' answer is correct---you should not refer to `Node` in your tests. If you wanted to do this somewhere inside List, though, you would express the type of the variable as `List::Node *`.||0
l15h2rdg72n8z|Compile check correct output and values|Hi,. . I was hoping someone could confirm what the correct values of b are in the compile check.  I've commented what I think the values should be for b.. .     bool b = iter == iter2; // b is true.     b = iter3 == my_list.end(); // b is true.     b = my_list.end() == iter3; // b is true.     my_list.push_front(42);.     my_list.push_back(42);.     iter = my_list.begin();.     b = iter != iter2; // b is true.     b = iter3 != my_list.end(); // b is false - because they are both pointing at null?.     b = my_list.end() != iter3; // b is false - because they are both pointing at null?|83|0|active|Your values of b are correct - though to be more precise on your last two statements both `iter` and `my_list.end()` are iterators that point to one position past the end (which in our implementation is an iterator that holds a node_ptr which is null)||0
l15h2ogf4d21hh|Nobody joining during check in appointment|I'd like to start off by saying thank you guys so much for offering check-in appointments! The support you guys offer for this class is incredible. Unfortunately, I scheduled one nobody has joined. Are you guys not doing them anymore? |7|0|private|Marking resolved!||1
l15h1ifyih9vd|Valgrind reports 0 errors, but more allocs than frees in pop_front()|"All of my tests pass and Valgrind reports 0 errors, but says I allocate more memory than I free when I use pop_front().. . I have stepped through every step multiple times in the debugger and am 100% confident that I use a ""delete"" for every ""new"" I use. Valgrind is fine when I pop_front() on one element, but not two (or more).. . When I push_front() two elements, a ""new"" is used for each of those. Then, in my pop_front() function, one is deleted (the first one). Finally, when the test case is done, the destructor is called, which calls clear(), which calls pop_front() until the list is empty. It is only run once because there is only one element and it is deleted, then the program ends and Valgrind reports no errors, but more allocs than frees.. . I cannot figure out why.. . . . When run with --leak-check=full:. "|140|0|active|Resolved in Followups||2
l15gohqsgtnot|valgrind error in my insert()|In the debugger, I can see that my list and iterator are behaving in the way I want them to, but when I run my program in valgrind, there is some sort of memory leak coming from insert().. . I use:. . Node* p = new Node;. . But because I want that node to remain in the list, I don't delete p in insert(). Is there some other way that I should be using my insert function because I do not see why I would delete that node that I just made.|132|0|active|You are right that you shouldn't delete the node in insert(), but you want to make sure you have properly deleted the node in the pop functions, erase() function, the clear() function, and any other places where you think you need to clean up the memory.||0
l15gno6ddtx47d|getting this error when trying to make List_tests, am able to compile fine on xCode|. For some reason, the CAEN compiler seems to think we're not using temp_ptr, when it is in fact used two lines later. Any clue why this might be? Also, the while condition is always true at least on the first loop, so temp_ptr is always used once instantiated.|56|0|active|"I'm not really sure that counts as ""using"" temp_ptr since it looks like you are just assigning a pointet to it? In assignment does not indicate you are using the variable"||1
l15gkeg3g5v2m5|Copy Constructor|I'm getting memory errors on valgrind when I use my copy constructor but not with anything else. It traces the error back to push_back, but I don't get any errors with push_back in other contexts, only when I use the copy constructor. Does anyone know why this could be?|22|0|private|Can you be specific about what memory errors you are getting?||2
l15geapmv636cd|Address Sanitizer Error in destructor|Every time I added the destructor, the AddressSanitizer error will happen. What does it mean exactly? But when I deleted my destructor, my test case can run. What is the problem here?  |79|0|active|"This looks like a double delete error, make sure your destructor is calling delete as many times as there are nodes and no more. . Edit: Now that I think about it ""heap-use-after-free"" probably means you're trying to access a node after it's been deleted, so I think you should check for that "||0
l15gaweu2o057f|Iterator insert() questions|For the insert() function in iterator, if temp is a nullptr, how do you know whether you should push_back() or push_front()? Right now we have it so if temp->next is a nullptr, we push_back(), but what if both temp->next and temp->prev are both nullptr?|9|0|private|I would think about it this way:. . There are 3 options:. . 1. You want to insert in the front of the list (iterator here should be equal to begin()) or the list is empty:.         - use push_front() here. . 2. You want to insert at the very end of the list (iterator here should be equal to end()):.         - use push_back() here. . 3. You want to insert somewhere in the middle of the list:.        - make a new node and reconnect its next and prev pointers accordingly, as well as the next and prev pointers of the adjacent nodes.. ||0
l15g11xh2at1um|Self-assignment compiler error|"When I try to assign a list to itself in my test cases, the compiler gives ""error: explicitly assigning value of variable of type 'List<int>' to itself"". The assignment operator works when assigning one list to a different one, so why is it not a valid operation here?"|135|0|active|because the assignment operator is supposed to clear out the list that is being assigned to, so if you assign a list to itself the assignment operator will clear that list then try to copy its contents, which would no longer exist||1
l15g05f87nw64t|Question on iterator|If we make iterators pointing to every item in list, and erase all of them, does that mean that the list is empty?|93|0|active|Yeah that makes sense to me||0
l15flcp9gkk7kq|how to check if iterator is nullptr? do you have to derefenrece?||139|0|active|you can assert that it is equal to an end() iterator||1
l15fjfo9v2ira|Question on iterator|if we do ++iterator on an iterator that is pointing to the last element of the list, then is it now going to be poitning to a nullptr?|53|0|active|The next pointer of the last node points to nullptr, so that makes sense to me||0
l15fbm8y3kq1gl|In instantiation of member function &#39;List::operator=&#39; requested here Error|What does this error mean? We keep getting it and can't run our tests.. . In instantiation of member function 'List<int>::operator=' requested here|56|0|active|Seems resolved in your latest autograder submissions. Please provide at least the first few lines of the errors you get in future posts about error interpretation. Generally, these few lines should contain the string `error: ` and point you to a spot in your source code (like `List.h:50:17`).||0
l15ex9xhfbn60f|should last and first point to each other for a 1-element list?|Should last→prev be first and first→next be last and their datum be identical if num_elements == 1?|52|0|active|If you only have one element, it is both the first and last element and all of their information would be the same.Also, if you only have one element, the next and prev are nullptr because there’s only one element in the list, so there’s nothing before or after it.||0
l15esbvxpvw6h7|Rewiring my forloop|"Shouldn't this:. . act as a for loop ranging from first until !new_node_ptr (ie nullptr)?  In this case the loop gets to a point then has this issue:. . . which is because new_node_ptr-> = nullptr, how should I rework my loop to avoid this?. . The issue persists when I use both the private variable ""node_ptr"" or the Node * i declare in the loop (new_node_ptr) to delete the node . ie, iv tried both delete(i.node_ptr) and delete(new_node_ptr), the error persists . . . Update: in my list I was using i.first, which provided an address which was totally random,  instead I should ahve been using the iteration begin() function, thought when I try this:  it states that:  which is really odd because there certainly is and it is implemented fully. . . thanks"|81|0|active|After you delete new_node_ptr, you can no longer dereference it. The memory it once pointed to is gone. Reduced to atoms. So new_node_ptr->next exhibits undefined behavior.||1
l15eqwcnd3g15x|Could I not have enough memory space allocated for my list?|"I'm testing insert() and getting a really strange error. When i decrement node_ptr, instead of going to prev, it points to some totally random memory address and datum that i have never seen before (as in it's not anywhere in my list or elsewhere listed in my debugger). Address sanitizer flags the error as ""libc++abi: terminating with uncaught exception of type std::out_of_range: map::at:  key not found,"" and according to some stack overflow posts I found about this error, this could mean that the object passed in did not have enough memory allocated to grow like it's being told to. Could this mean that there wasn't enough memory allocated to add a new node? Seems strange to me but idk because I can't figure out what else it could be."|143|0|active|You're decrementing node_ptr? That doesn't sound right. Nodes aren't stored in contiguous memory, so there's no saying what resides in memory immediately before some node.||1
l15epu0vubu4vi|Iterator Erase|In this function, I'm confused on whether we have to walk the Iterator that's passed in to the position of the node that we want to erase. If so, are we supposed to try and access node_ptr, a private variable to accomplish this task? Would traversal by pointer or traversal by iterator be the best way to get the node we want to erase?. . |105|0|active|You shouldn't need to traverse the list to access the Node that you want to erase. Accessing the private node_ptr variable of the Iterator is a reasonable way to get the node_ptr that you want to erase. ||0
l15ei805u1l7h5|empty function not working|In the public test, a new empty list is created and there is an assert statement asserting that the list is empty. But for some reason, the test case is failing and returning false that the list isn't empty. Why is this happening?|61|0|active|There is probably a bug in your empty() or size() function. This will vary a lot depending on how you implemented empty()/size(), however, so I would recommend going to office hours to have an IA look at your code. It will be much easier to debug if we can see your code. ||0
l15ef6nque05a8|EXC_BAD_ACCESS in pop_back and pop_front|I am having an issue with my pop_back and pop_front functions. After changing first to point at the second element in the list or setting last to point at the second to last element in the list, I am trying to set first->prev or last->next equal to the nullptr and am getting an error, but it does not happen every time I call these functions, only some times, specifically through the use of my clear function as well. I am not sure what this error means or what I am doing wrong.|89|0|active|EXC_BAD_ACCESS means that your code is probably trying to dereference a nullptr. When you change first to point to the second element of the list, and then try setting the value of first->prev, there is an implicit assumption that the second element of the list is not nullptr. Can you think of an edge case where this assumption is not true? As a hint, try tracing through the function when clear() is called on a list with at most 2 elements. ||1
l15ebjq2i6l73o|erase method and insert method question!!|For the erase method, If you have an iterator that goes beyond the last element of list, should we erase the last element of list? . . Similarly, for the insert method, if you have an iterator that goes beyond the last element of the list, should we add it to the end of the list? |129|0|active|"In the requires clause of erase, it says that the iterator must be ""dereferencable"". Since you can't dereference nullptr's, I don't think erase() works with end iterators.. . However, for insert(), nullptr's are a valid input, so that function can add to the end of the list when it receives an end iterator "||0
l15e2t9oq6z40h|When doing operator = getting error? how to approach?|Invalid use of 'this' outside of a non-static member function. . Use of class template 'List<T>::List' requires template arguments|55|0|active|Resolved||1
l15dsojxntr5i2|Deletion question|In the case of erase(), once found, the node must be erased, and therefore deleted, but I am confused, do we only call delete on the victim pointer?  or do we have to dereference the victim pointer when we delete to correctly delete the node at that location?. . thanks|87|0|active|You always need to pass a pointer to `delete`, so if you're trying to free a `Node`, using `delete` with a pointer-to-Node (`Node*`), like `victim`, would suffice. (like `delete victim`, not `delete *victim`).||1
l15dinrh3y97l0|Test cases using assert function with nullptr?|Is there a way to compare an iterator with a nullptr?. I tried using ASSERT_EQUAL(iterator, nullptr). and ASSERT_TRUE(iterator.operator==(nullptr)). but it does not let me compare them.|139|0|active|Nope, there's a type mismatch here. But the iterator must be an iterator into some list, right? And you can compare against a past-the-end iterator into that list, if that's what you want.. . Edit: iterator is an object of the Iterator class, nullptr is a pointer to null, they are of different types, so if you use assert equal like that, that's kind of like comparing a string to an int. Like the answer above, if you want to compare your iterator with an iterator containing nullptr, you should use list.end() or the default iterator||1
l15dh3unvmp2aq|&#43;&#43;operator errors|when i run this test case, i get this error:. Assertion failed: (node_ptr), function operator++, file ./List.h, line 233.. Abort trap: 6. . to my understanding, this means that i am trying to use the ++ operator on an iterator pointing to the nullptr? but i don't see where that would be happening. . . . my operator implementation for reference:. . |6|0|private|Have you tried running this test case with the debugger? Which line in the test function will give you this error?||0
l15d5baz3af5ux|compile check operator errors|I am getting these errors in my List_compile_check, and I am not sure how to debug this. |78|2|active|Maybe check if you have implemented all the necessary operator functions in your iterator class?||1
l15cg30y3tl2w5|Deleting nodes|I am confused on how this piece of code from lecture does not result in a memory leak. Don't we also need to delete the original first node as well? How does deleting victim delete what first is pointing to, to me all it seems to do is sever its connections. . . |75|0|active|victim points to the original first node, so deleting it means you are deleting that node. Victim isn't set by reference so it doesn't follow first wherever it goes, it just takes the value it's assigned to and holds on to it until it's explicitly set to something else||1
l15c28tjdo4693|Insert Function Confusion|So I’m trying to implement the insert function based off the RMEs which read to insert datum before the element at the specified position - my issue is I’m confused as to where the specified position is? Is it in datum? Is it in iterator I? Is it implied somewhere else? I’d just like some clarification on that if someone could explain in please |106|1|active|By specified location it means the node that the inputted iterator points to, so you would insert a node that contains the datum before the node the iterator points at||1
l15c1c5wg2omz|Accessing the node before iterator&#39;s node_ptr|Hi, I am trying to access the node before the iterator's node, in order to access that node's 'next' node and change that to point to the address of my new node for the Iterator insert function.. . Here is what I have right now:. i.node_ptr->prev->next = p;. . Valgrind is giving me invalid write size of 8, and Address 0x0 is not stack'd, malloc'd, or (recently) free'd. I was wondering if this is an issue of my double arrows?|120|0|active|"This is an issue of double arrows. The error ""Address 0x0 is not stack'd, malloc'd, or (recently) free'd"" usually means that your code is trying to dereference a nullptr. When you use double arrow (e.g. i.node_ptr->prev->next), think about what would happen if i.node_ptr was the first element in the list, i.e., if i.node_ptr->prev was nullptr. Could this lead to dereferencing a nullptr and how would you account for such a case?"||2
l15a0xuignh6ss|List Test Cases - Exit Status: 2|"Hello,. . I am currently in the process of working on Project 4 and have run into an issue that I can't seem to be sure of what is causing it. I wanted to reach out and possibly get a response before Virtual OH later today.. . For my list tests, I seem to be getting an exit status: 2 which I'm unsure what that means as I have never gotten before. Usually, I do see exit status: 1 which lets me know what is causing the issue but here I'm giving nothing along with it saying that no test cases were submitted.. . Would you be able to let me out here?. I have pasted all my code from this file below.. . Thanks,. Nitin Vadnala. . Code:. . // Project UID c1f28c309e55405daf00c565d57ff9ad. . #include ""List.h"". #include ""unit_test_framework.h"". . using namespace std;. . // Add your test cases here. . TEST(test_list_empty1) {.     List tlist;.     tlist.push_front(24);.     .     ASSERT_TRUE(!(tlist.empty()));. }. . TEST(test_list_empty2) {.     List tlist;.     int length = 7;.     .     tlist.push_back(length);.     tlist.pop_back();.     .     ASSERT_TRUE(tlist.empty());. }. . TEST(test_list_size) {.     List tlist;.     .     for (int i = 1; i < 7; ++i) {.         tlist.push_back(i);.     }.     .     ASSERT_EQUAL(tlist.front(), 1);.     ASSERT_EQUAL(tlist.back(), 7);.     ASSERT_EQUAL(tlist.size(), 7);. }. . TEST(test_list_push_front) {.     List tlist;.     tlist.push_front(24);.     ASSERT_EQUAL(tlist.front(), 24);.     .     tlist.pop_front();.     ASSERT_TRUE(tlist.empty());. }. . TEST(test_list_push_back) {.     List tlist;.     tlist.push_back(24);.     ASSERT_EQUAL(tlist.back(), 24);.     .     tlist.pop_back();.     ASSERT_TRUE(tlist.empty());. }. . TEST(test_list_clear) {.     List tlist;.     .     for (int i = 1; i < 7; ++i) {.         tlist.push_back(i);.     }.     tlist.clear();.     .     ASSERT_EQUAL(tlist.size(), 0);. }. . TEST(test_assignment_operator) {.     List tlist;.     List assign;.     .     for (int i = 1; i < 7; ++i) {.         tlist.push_back(i);.     }.     assign = tlist;.     .     ASSERT_EQUAL(tlist.front(), assign.front());.     ASSERT_EQUAL(tlist.back(), assign.back());. }. . TEST(test_assignment_ctor) {.     List tlist;.     .     for (int i = 1; i < 7; ++i) {.         tlist.push_back(i);.     }.     List assign =  List (tlist);.     .     ASSERT_EQUAL(tlist.front(), assign.front());.     ASSERT_EQUAL(tlist.back(), assign.back());. }. . TEST(test_iterator1) {.     List tlist;.     for (int i = 1; i < 4; ++i) {.         tlist.push_back(i);.     }. .     int count = 1;.     for (List::Iterator i = tlist.begin(); i != tlist.end(); ++i) {.         ASSERT_EQUAL(*i, count);.         count++;.     }. }. . TEST(test_iterator2) {.     List tlist;.     tlist.push_back(""nitin"");.     tlist.push_back(""vadnala"");. .     List::Iterator i = tlist.end();.     List::Iterator j = tlist.end();.     List::Iterator k = tlist.begin();.     List::Iterator l = tlist.begin();. .     ASSERT_TRUE(i == j);.     ASSERT_TRUE(k == l);. . }. . TEST(test_iterator3) {.     List tlist;.     List test;.     for (int i = 1; i < 4; ++i) {.         tlist.push_back(i);.         test.push_back(i + 2);.     }. .     List::Iterator i = tlist.begin();.     List::Iterator j = test.begin();. .     for (List::Iterator i = tlist.begin(); i != tlist.end(); ++i) {.         ASSERT_NOT_EQUAL(*i, *j);.         ++j;.     }. .     ASSERT_TRUE(i != j);. }. . TEST(test_iterator_begin) {.     List tlist;.     for (int i = 1; i < 4; ++i) {.         tlist.pop_back(i);.     }.     .     List::Iterator i = tlist.begin();.     List::Iterator j = tlist.begin();.     .     ASSERT_EQUAL(i, j);.     ASSERT_TRUE(i == j);. }. . TEST(test_iterator_end) {.     List tlist;.     for (int i = 1; i < 4; ++i) {.         tlist.push_back(i);.     }.     .     List::Iterator i = tlist.end();.     List::Iterator j = tlist.end();.     .     ASSERT_EQUAL(i, j);.     ASSERT_TRUE(i == j);. }. . TEST(test_iterator_erase_front) {.     List tlist;.     for (int i = 1; i < 4; ++i) {.         tlist.push_back(i);.     }.     .     List::Iterator i = tlist.begin();.     List::Iterator j = ++tlist.begin();.     tlist.erase(i);.     i = tlist.begin();.     .     ASSERT_EQUAL(*i, *j);. }. . TEST(test_iterator_erase_end) {.     List tlist;.     for (int i = 1; i < 4; ++i) {.         tlist.push_back(i);.     }.     .     List::Iterator i = tlist.end();.     List::Iterator j = --tlist.end();.     tlist.erase(i);.     i = tlist.end();.     .     ASSERT_EQUAL(*i, *j);. }. . TEST(test_iterator_erase1) {.     List tlist;.     for (int i = 1; i < 4; ++i) {.         tlist.push_back(i);.     }.     .     List::Iterator i = ++tlist.begin();.     tlist.erase(i);.     List::Iterator j = ++tlist.begin();.     .     ASSERT_NOT_EQUAL(*i, *j);. }. . TEST(test_iterator_erase2) {.     List tlist;.     for (int i = 1; i < 4; ++i) {.         tlist.push_back(i);.     }.     .     List::Iterator i = --tlist.end();.     tlist.erase(i);.     List::Iterator j = --tlist.end();.     .     ASSERT_NOT_EQUAL(*i, *j);. }. . TEST(test_iterator_insert1) {.     List tlist;.     for (int i = 1; i < 4; ++i) {.         tlist.push_back(i);.     }.     .     int hold = 2;.     List::Iterator i = tlist.begin();.     tlist.insert(i, hold);.     .     ASSERT_EQUAL(*tlist.begin(), hold);. }. . TEST(test_iterator_insert2) {.     List tlist;.     for (int i = 1; i < 4; ++i) {.         tlist.push_back(i);.     }.     .     int hold = 2;.     List::Iterator i = ++tlist.begin();.     tlist.insert(i, hold);.     i = ++tlist.begin();.     .     ASSERT_EQUAL(*i, hold);. }. . TEST(test_iterator_insert3) {.     List tlist;.     for (int i = 1; i < 4; ++i) {.         tlist.push_back(i);.     }.     .     int hold = 2;.     List::Iterator i = --tlist.end();.     tlist.insert(i, hold);.     i = --tlist.end();.     .     ASSERT_EQUAL(*i, hold);. }. . TEST_MAIN()"|7|0|private|"The way you are calling some of your functions in your tests does not match the provided List.h file. For example, on line 143 you're calling ""pop_back"" by passing in an integer, but ""pop_back"" doesn't take any arguments. Make sure you try running your tests on your own code, as that will give you better feedback than what the autograder provides."||1
l159p91hj2j5fm|List_test test cases|My partner and I have 20/21 public test cases on autograder and we have gone through every single function including operator functions in list.h, thinking about all different edge cases and we can still not get the last test. Any tips would be greatly appreciated! Thank you!|171|0|active|This question gets asked a lot and I know it can be frustrating, but no one is allowed to give advice on how to catch specific bugs. The best advice anyone can give is to go through each function and look at the requires clause and try to brainstorm every possible input you can think of.||0
l1594hakand5rf|Iterator big three test cases|Do we still need to test the big three for iterator in our test cases even if we do not implement them in our code?|162|2|active|You should create test cases that make sure that Iterators can be copied, assigned, and destroyed properly regardless of whether you implement the Big 3 for them in your code. ||0
l15947s6dpo6|Segmentation Fault and Test Case Format|Hi,. . I'm confused about the general format of test cases in List_tests.cpp. There is a segmentation fault when I run a test for push_back(), but I'm not sure that this is because my test case or push_back() function is wrong. Could you please look at my code and help me understand the error?. . Thanks. . . |5|0|private|Generally a segmentation fault can occur anywhere code is run, but in this case I think it would most likely be because of your code itself (since the test is pretty sparse anyway). The issue could be in your front(), push_back() or default list constructor. I would recommend using the debugger to walk through your code and find the exact line it is segfaulting on.||0
l158yp5auzo4fv|Resolved|Resolved|23|0|active|resolved||0
l157t6wkqo4457|Initialization Error|"I am getting this error when trying to make List_public_test.exe:. . List.h:17:10: error: expected initializer before ‘<’ token   17 | bool List<T>::empty() const {. . Why would this be happening, even though I have copied the code given in the spec for the function stubs?"|105|0|active|Looks like you have resolved this error. For the record, these function stubs must go _after_ the class declaration `class List { ... };`.||1
l157mqer757cy|Iterator == and insert|I have two questions about the iterators. The first is do we need to have == working with a nullptr? Also, if I have an iterator for an empty list, and then insert an element, is it possible to use increment my iterator to access the inserted element?|131|0|active|"""=="" should work with null pointers, yes (this is how we can have code in our ""for"" loop that checks to see if an iterator is equal to the end iterator).. . I believe the RME for increment requires that Iterators must be dereferenceable. An iterator for an empty list would not meet that criterea, so you won't be able to increment it."||0
l156wnysapx7nu|iterator insertion empty list|if you use iterator insert in an empty list and add a value, for example 4, after calling iterator insert, should the iterator now be looking at the 4 it just inserted or a null pointer past the end?|103|0|active|I don't think your insert should be moving the iterator at all, so it should still be a nullptr||0
l156sfcnjgi2n4|Question about operator&#43;&#43;|So I know that the iterator is past-the-end, so how should I implement operator ++, as it will inevitably use node_ptr->next, which will dereference a nullptr. I tried to use if to separate the occasion, but the condition line will also require the node_ptr->next, which will cause the same problem. Can someone give me some hint about it? Thanks!|86|0|active|The ++ operator should only be used on iterators that point to an actual Node, not to ones that point to nullptr. The past-the-end iterator cannot be incremented. ||0
l156of6p77960p|How to make an Iterator pointer point to itself?|I'm getting the error. Indirection requires pointer operand ('List<int>::Iterator' invalid). wherever there is a pointer operand. How do I return an Iterator pointer to the actual iterator the operand is inside of? Or is that something I even need to do, and there's something else wrong elsewhere?|71|0|active|Nevermind- I think I figured 'this' one out!||0
l156mug9y33ye|self assignment|my partner and I are getting a false positive on autograder for a test that checks self assignment, any help on how to fix?|77|0|active|I believe a false positive means that your tests are reporting a bug on a correct implementation. This means that something is wrong with the test case itself. I would make sure that the test is doing what is should do. Self assignment should just return the node.||0
l156hjwm43s5sm|iterator range|is the range for iterator from the first node to past the end or is it before the first node to past the end?|59|0|active|The range is from the first node to one past the end.||0
l156csozc1n2ed|What should these be?|if there are two elements in list such as 6, 42, what should first-prev, first_next, last-previous, and last-next be?. |66|0|active|first-prev: nullptr. first_next: 42. last-prev: 6. last-next: nullptr||1
l1566y0gi6237|== operator|should the == iterator operator work for a null pointer?|68|0|active|Yes, since you can compare whether or not two pointers are both nullptr or not.||0
l1563rq6f3t1g3|Our pop_back and front are causing memory access errors|Hello, . I hope youre doing well,. For some reason were getting an exception thrown error when we set first->prev to nullptr after setting first to first->next.. . . This is what the code looks like, and the error were getting is when we push front 4 integers into the list, then popback all of them. it happens on the first pop back. The error is in popfront since i tried to make sure it was both and not just popback.. . . . . This is our push front code, and the green text was just something i was trying out, and it didnt fix the problem either. Im not quite sure what were missing since we call push front 4 times, then pop back 4 times, it doesnt seem like were  doing anything illegal and specifically accessing anything out of bounds. . . Any help is greatly appreciated. thank you|9|0|private|Which test case is this being run on? Also, do you know where/which line in the test case this is throwing an exception?||1
l155zskwzpl60o|Iterator pointing question|After inserting a new element, does the iterator point to the oringial first or the newly inserted element?|125|0|active|Using iterators after insert() or erase() is sketchy so I wouldn't recommend it. It can work for insert but where it'll point to next can change based off of how you implement insert().||0
l155wbf4drl42b|Segmentation Fault in pop_front() function|. This is my pop_front() function. Can someone please tell me why I'm receiving a segmentation fault in the line that I've highlighted?. . I've also posted this question to instructors only, since I'm sharing code.|5|0|private|You're likely getting a segfault here because one of the pointers you're dereferencing is a null pointer. To figure out why its a null pointer (and what you should do to make sure you recognize that situation and don't dereference it), try drawing out what happens in a couple different cases for this List, using circles to represent Nodes and arrows between them for the pointers (plus arrows for the first and last pointers). Specifically consider the scenario where there's only one node in the list, since we should still be able to call pop_front on a list like that! ||0
l155ql1mmzv5ke|Quesiton on iterator|if we have an iterator that points past the end, if we do -- is it suppsoed to be pointing to the last element?|56|0|active|No, the implementation we're given requires that the node_ptr isn't null.||0
l155bkuqf5v5u|memory leak|"if we have an unexposed memory leak somewhere in our code, would it make sense that we keep getting seemingly ""random"" assert fails in our tests?"|58|1|active|Not necessarily. . Edit, other user: I have a memory leak in my code right now but all of my tests past; so not necessarily||0
l154w45td007ay|calling assignment operator|"To assign list2 to an empty list1 would we say ""List<int> list1(list2)"" or List<int> list1 = list2?"|84|0|active|These both copy-construct lsit1 from list2. No assignment happens here. You would have a call to the copy-assignment operator if list1 existed already in your second option instead of being declared and initialized here:. . List<int> list1 {can contain whatever, will be overwritten in the assignment below};. list1 = list2;. ||0
l154fdj3kj933m|Getting this bad access error in push_back, not sure to fix it||4|0|private|Recall that for the `last` node, its `next` pointer should not be pointing to anything. Since it's not pointing to anything (i.e. it points to `nullptr`) what would happen if we try to assign it? (Hint: It's shown on the line getting the `EXC_BAD_ACCESS` error)||0
l154e1hiohksz|Honor code question|Hi,. . Can we use code provided in lecture / lecture notes in project 4?|7|0|private|Yes - you can use anything that we provide you!||0
l154d9ge9h47im|What would be cause thread bad access error p4?||87|1|active|A couple of the reasons for a bad access error (assuming you mean an error like Thread 1: EXC_BAD_ACCESS) would be trying to use a pointer that was pointing to data, but data was already deallocated. For instance, if I had done something where last->next = aNode, this would result in the error above within VSCode’s debugger since last->next would be nullptr. (the reason for that, is due to the data structure of a doubly-linked list itself) If you want to read more about this error, there are a number of articles online describing it, but one of the more helpful ones I found was here (some of the syntax does talk about more C related things, but I still found it very useful) Hope this helps!. . Also, I’d recommend looking at @2865 for help, if this does not work (from P3, but still applicable). ||0
l1546fw6jsa4gc|new Node leak|I believe I am getting an error due to making a new Node, but even after I set p to nullptr and delete it, it doesn't work. When that happens, the address sanitizer says I am using it after I delete it from the heap. I will include one of the functions below. Thanky ou for your help!|6|0|private|I figured it out! Thank you!||0
l153mfv1zbfrw|destructor test|Do we have to include destructor tests ? |113|0|active|nope! the deconstructor will automatically be called at the end of each of the test functions so it is implicitly tested through those calls. ||0
l152yi5w8cm653|Autograder Error Help|We're getting this error in autograder for our size function and we're not sure to fix this error. So we were wondering if we could have some help with this. I have included a picture of our size function below.  . . |4|0|private|An invalid read of size 8 means you are trying to access memory that doesn't exist. Since it is originating from the size() function and I see a for loop, there might be a place where next does not point to a correct node (potentially one that has been deleted). Trying to access a node that has been deleted or a bad memory address will cause this error because the for loop doesn't stop and you can't access ->next of a node that doesn't exist. Remember that when you pop back you set the new last->next equal to null pointer.. . Just as another tip, you don't have to calculate the size in the size function if you keep track of it (increment and decrement) in the other functions.. . Hope this helps!||0
l152m27g2es3az|List_compile_check: no operator matches these operands|Why do I get that error even though I've overloaded the operators and made them public in List.h?. |95|0|active|Resolved below, it seems.||1
l151zdz5scy77d|Does the assignment operator call the copy constructor?|When I am testing my assignment operator, I define two lists and push back elements into both. Then, I use the assignment operator with the line lst1 = lst2; However, after further testing, I noticed that this line runs both the copy constructor and the assignment operator. It still seems to function properly, but is this supposed to happen with the assignment operator?|171|0|active|This isn't required for all types that implement both a copy constructor and a copy assignment operator, but it's a very common pattern for a good reason. The copy assignment operator has to perform a copy, and so does the copy constructor. Why not have one call the other? This way, you avoid writing the same logic for copying in two different places.. . c++ - What is the copy-and-swap idiom? - Stack Overflow||1
l1506vfyawq2pp|Question|Hi,. . Do we need to add the operator<< and implement it? I get this error because I don't have this operator, since the spec, and the comments on the list.h file doesn't say we need to implement it.... . |105|0|active|Per above: Remember that the dereference operator (`*`) should return the element that the iterator points to. If we just get that element, do we need to overload `||0
l14kfj0lnkm69s|Big Three for Iterator Class?|"I know that many people have posted such a question and that instructors have said that they are on the right track. However, on autograder, there is a test case that tests the big three for the iterator; its called ""List test iterator big three"". This is what made me doubt whether not having custom implementations for the big 3 is wrong. However, the lecture slides say we don't need it. . . Could someone please clarify? Thanks.. . . . "|198|3|active|The real mystery here is if they are testing for if we do have to big three or if we don't have the big three. Or, if we don't have the big three, can we still pass the test?||0
l14k0ds4nlg6ek|Private member errors|"We were getting errors that said things ""'operator*' is a private member."" When we moved the operator functions to be under ""public:"" in our Iterator class, we resolved the issue, but I wasn't sure if we were allowed to do that because the comments seemed to indicate that we were supposed to make these functions above 'public:'. Would what we did be a viable solution considering that?"|80|0|active|"yes the ""operator*"" and all other operator overloads should be in the public section as they will be used outside of the class in your test cases. . . Hope this helps!"||0
l14jc93eymim|Can you use erase on an empty list?|I was wondering if this is something I have to consider within the function, or if I should use an assert statement instead. I don't entirely understand what the RME for the function means.|134|0|active|No you don't need to consider the use of erase() on empty lists, because it is in the requires clause, which means that if it is called on an empty list, thats behavior for which function performance is unknown.||0
l14jblav5ay38u|caen and valgrind|do i have to log out of caen after running valgrind?|68|0|active|you can just type exit||1
l14i3m1bfcu3kg|vs code and ubuntu not working|My ubuntu and visual studio code both arent loading. What should I do?|63|0|active|Did you try to restart your computer? I've occasionally run into issues where ubuntu crashes or won't load VSCode, so restarting my computer has helped.||1
l14ga75m4k936n|autograder invalid free|what does this autograder output mean?. |112|0|active|these outputs means you are trying to delete something that has already been deleted - aka a double delete. I would suggest tracing back all of the functions that are called, starting with the test case. Write out what the linked list should be and how it reacts as each function is called. Based off a first glance, it looks like the problem is coming from the clear() function. I would suggest making sure that how you loop through works (the stop condition stops the code). The problem could be that the loop condition is never met so the computer tries to pop_front() nodes that don't exist.. . Hope this helps!||1
l14f23k044su1|Memory Leak In Insert|My code didn't pass the compile check because of the memory leak in the insert function. I heard that the big 3 isn't necessary for the iterator class, but I wasn't sure how to insert a new node without creating a new node in dynamic memory. For the special cases, I was able to call the push_back and push_front functions, but if I want to insert something in the middle of the list, I'd have to create a new node. Is there a better way to do this?. . The destructor for my list class is able to delete nodes just fine, but for some reason, it isn't able to delete work for this case. Am I able to delete this new node using my destructor for the iterator class? If so, how do I make a destructor for the iterator class?. . This is my List.h. . . . |8|0|private|If you take a look at what the insert is being called on, it is being called on my_list.begin() -- a pointer to the beginning. Going by your code, the code will make it to the for loop in the else statement. This will create a segmentation fault (SEGV) with the p->prev->next. This is because the first node has a prev of nullptr so you would be trying to access nullptr->next which is invalid. You can't access parts of a nullptr.. . I see you tried to use the push_front function which is a great idea! I would suggest re-evaluating your if condition to make sure you call it whenever an iterator to the first element is passed in.. . Hope this helps!||1
l14ei2ujb65678|Assigning something to itself|. Hi, I am getting this error trying to run my tests cases (on Visual Studio Code) while my partner is not (on xcode). Our = operator has an if statement where:. . if (this == &rhs) {. return *this;. }. . We have a 42/42 on autograder right now, so I wasn't sure if this is an error that we need to fix or else we will actually get a worse score, or if it's just something picked up by visual studio code but not necessary, or if it is a vital error.. . Thanks for any help|115|0|active|If it runs on xcode and autograder, I don't think it is something to worry about||0
l14e30egjfl431|autograder public test|I just submitted to the autograder but for my public tests, it says. bash: ./List_public_test.exe: No such file or directoryHow do i fix this?|102|0|active|Looking at the error output from List Public Test for compile it looks like you're trying to return something from a constructor. ||0
l14e2lzuiz65i4|Code compiling on local comp not autograder|My code is compiling on my local machine but not when I submit it to the autograder. What should I do about this?|66|0|active|You can sync it to CAEN and try to run it on CAEN network. If it works on CAEN it should work on autograder. It will tell you the errors on CAEN when you try to compile it there. https://eecs280staff.github.io/p1-stats/setup_caen.html||0
l14dtg8cptv4w|unknown error||73|0|active|Have you written a definition of the constructor template <typename T> List<T>::Iterator::Iterator(List<T>::Node*) this error is complaining about?||0
l14d2lv4e9o7ho|deleting first-&gt;prev vs. setting a temporary node to first-&gt;prev and deleting that node|What is the difference between these two ways of popping the first node in a linked list? Why does the former produce a seg fault?|123|0|active|Think of what is held in `first->prev` at the first element of a doubly linked list. Since we are at the front, `first->prev` would be `nullptr`. (assuming you had not already tried to move `first` and are using the original data that `first` was pointing to) Trying to delete that will cause issues as you experienced.||0
l14coqkaauh7db|delete in insert|. Im getting this valgrind error because I created a new Node in insert() and didn't delete it. should I delete it at the end? I thought it may mess something up to delete it if I just inserted it into the List.|239|1|active|I believe the problem lies in the fact that you don't delete the node when you clean up the list (either in dtor or clear()). Valgrind is pointing to when the item that wasn't deleted was created, not necessarily the point where it was leaked. I would recommend checking every place you try to delete or remove and item and make sure you're deleting everything properly. ||1
l14cl6xsxr16k1|Valgrind error||129|0|active|I believe this error is indicating that you didn't delete an item that you made when you called push_back(). I'd recommend double checking every place where you delete a node and make sure that you're properly deleting what you want to delete.||1
l14c2rxeu5910j|Testing List Destructor|Do we have to test these explicitly or can we assume that they are being tested when the Lists created in the test function go out of scope? Just wondering since I'm missing 2 points on tests and am unsure on what else I could be missing.|135|0|active|No. Destructor should never be explicitly called(unless in very special cases). If your destructor causes memory leak, Valgrind test will reveal it.. . Think about every function in `List` and `Iterator`, and every branch you write in those funcitons.||0
l14bt7wqrncn0|Clearing list and then adding elements to it for list_tests issue|For list_tests.cpp, we should be able to create a list, add elements to it, clear it, and then add elements to the same list (using push_back() or push_front()), right? I'm getting an address sanitizer error when doing this. |77|0|active|Yes, you should be allowed to add to a list even after clearing it. If you're getting an address sanitizer error then it's likely your clear() function isn't deleting everything properly.||0
l14bqvfo3f94pz|Question|Hi,. . I have a question: Why am I seeing this error in the == operator, and != operator? I also have another question: Is my ++ operator, and . *operator correct? based on the implementation I made? I've been testing thoroughly, and I see that there are no errors, except for the ==, and != operators... So I just want to make sure of these operators, in order to not to cause any compiler error.. . |7|0|private|Note for the `==` and `!=` operators, you want to see if they are the same iterator or not. You'll want to return some boolean in the appropriate case. You are somewhat on track but you'll need to modify what you are returning and comparing. (Since you'll want to pass in some iterator that represents the iterator on the right-hand side, to compare) Additionally, you will want to go over your `operator*` function, since you want to return the actual datum of the node that the iterator points to.||0
l14bnispoer556|Error of Disallowed Libraries|. Don't know what the error is. Saw someone else had this issue as well but the solution given did not help.|55|0|active|Make sure you don't have json.hpp included in either List.h or List_tests.cpp - the json file includes libraries that are disallowed on the List portion of the project, but json is only necessary for api.cpp.||0
l14b3kddhrf3l3|Confusion about Asserting for insert/erase|"About Iterator erase(),  how do you assert that the iterator i is a ""dereference-able iterator associated with this list"", isn't that inherent to the iterator so long as the dereference operator is implemented?. . As for insert(), how do you assert that ""i is a valid iterator associated with this list"".  . . are asserts even required here?"|166|0|active|1. No, you could not know if a pointer is dereferenceable or not. So, you do not need to `assert` that part.. 2. No, you could not know if a iterator is valid or not. Also, you do not need to assert this.. . Yes, assert is not required at all for this project. It is optional.||0
l14a3bza45pcb|Test cases|For our test cases, should we make sure the next and prev values for nodes are correct with an assert statement? If so, how would I call the next and prev values in the test file?|131|0|active|You are testing the public interface in `Iterator` and `List`. You do not have access and not need to have access to `prev` and `next` in `Node`.. . @1051||0
l1498l5so1a6yg|templating error|resolved. |11|0|private|||0
l1490ijz1jr4rv|Errors with Operator Functions|I get these following error messages with my operator functions. I'm not sure where I went wrong since I followed the formatting from the lecture slides.. . . . |9|0|private|I notice for the `==` and `!=` operators, you seem to return `bool Iterator&`; Is this the correct type, or would we want to return just a boolean when comparing the two iterators? I'd think about what you want to return from those functions, first.||1
l148r0fojgl6jt|Testcase error|Dear instructors, I have several false positive issues regarding my testcase. Sepcifically, the testcase for operator--, insert, and erase. . Operator --:. . This test case actually works fine for my code, and operator-- is provided in starter files. So I'm really confused why this testcase is false positive.. . Secondly, the test case for erase:. . . Thirdly, test case for insert:. . I also include the current state of test case in comment line.. . Thank you so much for your help!|8|0|private|"I think with all of these there is a misunderstanding of where the node_ptr of an iterator set to List.end() points. end() creates a node_ptr to ""past the end"", this isn't the same thing as the last node in a list. Additionally, I think there might be a syntax error with how the iterator operators are being called. Think about how these operators are usually called when used on a simpler data type like an int. "||0
l14895jdqxb71y|Why can we use -- on an iterator pointing to the first element?|Why does the -- starter code allow an iterator pointing to the first node to be decremented? Wouldn't that make the iterator point to nullptr which is supposed to represent one node past the end of the list?|147|0|active|The possibility of allowing decrement does not mean that should happen. Decreasing `begin()` is undefined behavior.||1
l146k5budb25y6|False Positive Tests|I was getting multiple false positive tests on the autograder, but when I wrote them down and went step by step I could not identify where the false positive occurred. Is it possible to see where the error is?|9|0|private|"False positives usually mean your test case was written incorrectly or you have a conceptual misunderstanding and have coded your implementation incorrectly and then tried testing it with that incorrect understanding of what should be happening. This makes them hard to test with a debugger since they will usually ""pass"" on your implementation. . . After taking a look at your AG and code, it looks like most of the false positives are happening when you're testing operators on iterators. Take a carful look at how you're calling these operators from the test cases (I believe the syntax here is incorrect). Also I believe you have a misunderstanding with your implementation of an end() iterator. It should be creating an iterator to ""past the end"", I think you are currently making an iterator that points to the end. "||0
l146gjmy42e4ic|Memory Leaks|If we have memory leaks in our final submission will points be taken off even it it still works?|90|0|active|Valgrind will probably fail, but points aren't deducted from valgrind||0
l145lv7fv8x7|iterators end|if i have two iterators pointing at the end of two different lists, are they equal since they would both be pointing at null or are they not equal because it’s two different lists?|111|0|active|Since they both point to a nullptr they are technically equivalent in that sense. However, if the lists contain different type (i.e. List::Iterator and List::Iterator) the iterators of the corresponding lists are not comparable. However if two iterators pointing at lists of the same type, they will be comparable and can be equivalent.||1
l145akgg40uba|Getting zsh: segmentation fault only in command line - not Xcode|"Getting error for my popback/popfront functions. For some reason it works fine in Xcode but when I run it using my terminal it gives a zsh: segmentation fault error. . . Error occurs when I popfront a second time. I would first pushback 4 values, then I would remove them one by one from the front but I can't seem to remove a second value after removing the first.. . I figured it out: I was deleting the wrong ""first"" node as I deleted it after I reset the first node, effectively deleting my ""new"" first node after removing the one I actually wanted to. However I am very confused as to why it still runs in Xcode with no issues, as the code is wrong.. . "|130|1|active|. ||0
l14386ik4dg1p8|Repetition of code in test cases|For the style check, does using repeating code in the test cases matter? For example, the setup for initializing the function that we are testing is the same code, but the overall implementation is different.|103|0|active|Test cases do not count towards code duplication.||1
l142fop5hno6pa|Resolved|Resolved|74|0|active|Resolved.||0
l141utcpral5if|test cases dynamic memory|do we have to do anything like delete list in the test cases, like in p2? i am getting memory leaks in my test cases, but if i try to delete the list directly i get an error. Does this mean there is an error in the class destructor?. |157|0|active|For memory leaks, remember that any object created with the keyword `new` should be deleted with the `delete` keyword. If you are getting memory leaks, I would recommend reviewing any functions that involve the deallocation of dynamic memory (destructor, pop functions, erase) to ensure you aren't forgetting to delete anything. Valgrind will help a lot with checking if you don't have any leaks.||0
l141r2lwj8f7o3|Why do my tests sometimes fail half the time and work the other half?|I have two test cases, both testing different Iterator insert scenarios, that fail about 50% of the time, but pass with no issue the other 50%. Why could this be? Also, the error is not within the test case, but rather after the test case somewhere within the destructor and its processes. I've debugged a lot but it's difficult when sometimes it work and sometimes doesn't. Could just submit to the AG and hope it'll be one of the times it works but I'd rather get to the bottom of it.|157|0|active|When you're getting different results between test runs, it means you probably have undefined behavior. I'd run it through valgrind or address sanitizer to see if that exposes anything. ||0
l141lvl5f8s37k|Autograder Library Error|Me and my partner are getting this error from ag:. . We have no idea what caused it, since our first submit has the exact same libraries as this submit but we keep getting this error.. Update: we removed the JSON library and now it submits, but don't we require this for the project?. |66|0|active|You're not allowed to include algorithm for list.h||1
l141cbvbjkj17l|iterator erase and end|Why is the iterator not passed by reference for functions like erase? After erase is called the iterator is pointing to an element that is no longer in the list, is this what we want? Also, can we not start with list.end() and traverse backwards since there is just a nullptr that cannot point to a previous or are we expected to figure out a way around that? |165|0|active|We can't start with list.end() and traverse backwards because it is a nullptr and therefore won't have a Node->prev that we can access.||0
l140nwome0620l|Why do I get an &#34;invalid pointer&#34; error?|". . When I run the compile check, I get an error when it comes time to erase using iterator. Specifically, the ""delete &i"" gives an error saying it's an ""invalid pointer"". I'm a bit confused on how I would delete the iterator. Or am I not supposed to delete the iterators, only lists and nodes if necessary?"|7|0|private|Overall, you should only be deleting dynamically allocated memory - so only addresses that were created using `new`. In this project, that should only be Node objects, so you would only be deleting pointers to Nodes.. . In this case, you're trying to delete the memory address of i, which is an Iterator parameter being passed into the erase function. Delete is expecting a memory address to something allocated on the heap, but i is just a local stack variable - that's why deleting it is invalid. It might be a bit confusing because Iterators are very similar to Node pointers, because Iterators are an abstraction on top of them. So, I'd keep in mind that you should only be deleting pointers to Nodes if at all, and Iterators store a pointer to a Node as member variable!||0
l140g309lho34k|insert function edge cases clarification|When implementing the insert function, do we need to consider the scenario when the list is empty? Say, the list int_list is empty, can I call int_list.insert(int_list.begin(), 1)?. . Also, a similar scenario where the iterator points to the int_list.end(). Can I call int_list.insert(int_list.end(), 1)?|162|0|active|I think it would be best if you considered the scenario when empty() == true because of what that would mean for your first and last node pointers. You can indeed call int_list.insert(int_list.end(), 1).||2
l13z5bkwyda11u|Unknown Error|. I am getting this error in my pop front function in relation to when the program tries to delete victim after running my test cases. I debugged and everytime the function was called, delete victim was called so I'm not sure what the error is. This only happens when I do pop_front for a List, and then do list.clear() after to wipe the list of data for the next list. |103|0|active|It's likely an issue related to your destructor--make sure that every variable it's checking to know when to stop deleting is kept up to date.||0
l13ykp06xxn198|Autograder says I am not submitting tests|". When I submitted to the autograder today, I got a 0 out of 21 on my tests because ""no test cases were submitted"". However, I wrote 16 test cases, and submitted the List_tests.cpp file to the autograder. In Student List tests on Student lists it even ran my tests and printed out the test summary...When I run this in my terminal it works fine. I have the TEST_MAIN() at the end of the List_test.cpp file, I have the project UID and both files included, as well as namespace std. This was not a problem last time I submitted, and all I have changed is adding more tests. any idea what is going on here?"|151|1|active|||2
l13xcx5x8wd4ie|just started my program any tips? also what functions from the big three are needed?|basically the title. . well technically I started the day it got assigned. I stopped last week on wednesday because I thought I was done just by checking the compile test. . however that was not the case.  I think i might be missing some test cases. . what tips can anyone give so I can still complete this on time?. . |165|0|active|I'd recommend starting with the List functions then moving on to Iterator. Also make sure to draw out w/pen and paper what's happening as you implement, as that will help you understand what to do with the prev/next pointers. Make sure to write test cases as you go!. . I'd also highly recommend coming to OH. IAs will be able to give more specific help and answer any questions you have.||0
l13vczkssfu15s|Use of Iterator|As I understand things, the iterator is intended to be used within  the list class, so that for functions like push_front() in list are able to change the previous pointer of the node that came before them to point at this newly (front) pushed node.  If this is not the case, how are we supposed to access the prev/next pointers for the nodes in front of or behind the node we want to add?. . thanks|118|0|active|Not entirely sure what you mean, but the Iterator is not meant to be used within the list class. You can access any nodes by using node->prev to get to its previous node or node->next to get to the next node||0
l13v88lwtyv1u3|first/last prev/next confusion|Is it an issue that my first/last values (specifically first/last prev and next values) are not set - almost appear empty? Do those values need to be reset by me whenever they change or is that something that isn't tested? Here is a picture of what I mean exactly - I'm specifically talking about the lines that say datum (int). |104|0|active|Your last node looks ok, it makes sense that last->next is null because if last->next pointed to another node then it wouldn't really be the last node. The datum under last->next has nothing because it hasn't been initialize since it doesn't belong to a real node. Your first node also looks good to me.||0
l13ueppto4h23x|out of range|Hello!. . All of our test cases pass, but we get this error:. . any idea as to why this might be?|107|0|active|This would be hard to help with without some more information:. . Which test case are you running?What have you narrowed this down to?Have you submitted to the AG? Please update your piazza name per @6 to include your uniqname.Have you run Valgrind? If not, run Valgrind and let us know what the output is.||0
l13rp6k9covk9|Destructor Issue|Hi everyone. I'm receiving an error on my destructor, and I'm struggling to understand what it means. My destructor calls the clear() function, which calls pop_front() while List is not empty. This is successfully destroying all the elements, but then it just keeps trying to destroy that element over and over until it throws this error... Can anyone help me interpret?. |166|0|active|see followups||1
l13qjpdplwt32a|Iterator Insert Function - Do we need to insert at the very end of the list as well?|Do we need to be able to add an element at the very end of the list using iterators? Since the iterator insert function inserts before the iterator, the last place you can insert to would be the second to last spot. |138|0|active|"Consider what would happen if you passed an iterator with node_ptr = nullptr into the insert function. Is this allowed? If so, what do you think should happen? Remember that the nullptr is ""one past the end."" Hope this helps!"||0
l13qgpzspwl2p6|testing|Do we need to write tests that check both iterator functions as well as list functions?|107|0|active|@4730||0
l13q3bajl8e2m6|Iterator Erase function|When you use the iterator erase function in the test cases, what does the iterator parameter that's passed in point to once we call the functions and erase? Do we need to manually set it to nullptr, or just not use it in the rest of the test case? |201|0|active|This invalidates the iterator, so you can't use it anymore, no need to set it to anything else. This post might answer this question more clearly than I did: @4742||0
l13pts6o5om5kj|List from Only Insert|I've been playing around with Insert edge cases, and there's only one that produces problems: Lists from only insert. The functionality itself seems perfectly good (ie passes all unit_test_framework assertions) but any list I create with only Insert produces memory leaks. Any hints as to why this may be happening? I've been breakpointing destructor and it always seems like every Node is removed (first ends as null, last ends as null), but Valgrind does not agree.. . Edit: Resolved! Was double adding nodes in iterator-past-the-end case!|123|0|active|Marking resolved||0
l13oxcortjm23s|compile check|When i run the compile check, I am getting this output... which confuses me because nowhere do i use cout or endl in my code |90|0|active|Make sure List_compile_check has these two lines at the top:. . . using std::cout;. using std::endl;. . If these lines are not there, you may have accidentally altered the file. I would recommend redownloading it if that's the case.||1
l13n97cqke42x0|runtime error insert function|Hi, I have this implementation for my insert function, but when I run the compile check, line 291 has a runtime error. I'm not sure I totally understand what is wrong, so could somebody help clarify? |10|0|private|To answer your questions in the follow up, checking if the iterator is pointing to the first or one past the last node sounds like a good idea. And if the iterator is storing a null pointer, you cannot increment or decrement it as those operators require that the pointer is dereferenceable.. . The reason you were getting a runtime error is the case that i.node_ptr is a null pointer, but it looks like you were able to fix that||1
l133vfu6y8s6b9|insert back|"The effect of insert is. . . ""inserts datum before the element at the specified position."". . does that means we can't insert an element at the very end of the list just like push_pack() because insert always inserts the datum in front of the specified iterator?. "|140|0|active|"If some passes in an iterator that points to nullptr, it would be pointing ""one past the end"" and therefore the space before it would technically be the end of the list, which means we'd insert the datum at the end of the list"||0
l133uyrnb7v7ae|Assert fail|Hi, i have this code right here, and when i run the public tests, the assertion fails. I believe an iterator can point to an empty list, but then I think that affects what behavior it is allowed to undergo? Can someone help clarify and/or point in the right direction of clarifying resources?. . Thanks. . |8|0|private|Just followed up about this on your other post here!: @4793||1
l13333tylu64pc|iterator when list is empty|Can you return an iterator pointing to the first element of a List if the list is empty?|172|1|active|`List::begin()` does not require the List contain any elements - if you call it on an empty list, it would return the same thing as `List::end()` (so you can call begin on an empty list). ||1
l132bcfoe7x7ib|Test cases|In my latest submission, I still have one bug not exposed. But I believe I have considered all conditions as I can. What kind of test do I need to add?|10|0|private|Unfortunately we can't give away too much in terms of what test cases you should be writing, and the best thing you can do is make sure you're testing every function you wrote and considering any edge cases you can think of. Are you testing all the iterator functions you wrote? Also make sure you're testing the copy constructor and assignment operator.||0
l131ruk4pvi605|deference operator|When I cout *it, it outputs the correct answer.. But when I use ASSERT_EQUAL, it says . |121|1|active|"That error means you're trying to dereference a nullptr, could you maybe be changing the iterator in some way before the assert statement? Additionally, maybe inside of your dereference overload you're changing the iterator and that's why it's different once you get to the assert statement.. . Edit: Are you maybe trying to compare this to *list.end()? end() goes ""one past the end"" so its a nullptr and wouldn't pass that assertion if you tried to derefence it"||1
l13141mdbne38e|Testing Iterator|How do you test Iterator functions?. . I tried declaring an iterator like this in the test file: Iterator i ... but it says Iterator is undefined.|148|0|active|Recall that `Iterator` is a class that is defined within `List`. Thus, any time you want to construct an `Iterator` object, you need the scope resolution operator. (`::`)||1
l130vy4wly13g3|Confused by List_compile_check.cpp|In the List_compile_check.cpp starter code line 33, we initialize a new iterator with the beginning pointer of an empty list. I was under the impression that this pointer would be a nullptr. Then we try to insert a datum at that iterator, but that isn't allowed according to the RME of insert() because the iterator isn't valid. What am I missing here?|174|0|active|"Note that an Iterator being valid in this context means it points to some ""valid"" spot in the List. Valid spots are any node, or the spot just past the end of the list. In other words, `List::end()` returns a valid iterator. You'll notice that the RME's for some other functions require a valid *and dereferenceable* iterator - how would that restrict the set of Iterators we can pass in? The wording here is a little tricky!"||1
l130pbqyf9q6k|Size Private Member Variable|I'm just missing two bugs in the autograder, but never added a size member variable to the List class. Is it 100% necessary to have one, or am I okay without it?|97|0|active|You should have one based on previous Piazza posts.||0
l130gfu4c7o4wx|Inconsistencies with iterator&#43;&#43; operator|. So in this test I have created an Iterator called it. As you can see I have used it++ multiple times and it works perfectly fine (I have ran through it with the debugger and works right). But on my second test I made Iterator itThree and made it equal to list.begin(), and then immediately used operator++. However it led to a segmentation fault. After running it through the debugger I noticed that after the line null_ptr = null_ptr->next; it is setting it to a null_pointer and that is causing the segmentation fault, when it should be setting it to the address of the node with datum 3? What could be causing this inconsistency? (The error happens with both the postfix and prefix ++ operator). |7|0|private|Could it be that you want itThree to point to `six.begin()` rather than `five.begin()` (which might be empty after you've erased from it in the above test)?||0
l12zltlizhv4u4|&#34;Pointer being freed was not allocated&#34; error after compile check|"My compile check seems to run correctly (it gets to the return statement successfully) but afterwards it outputs an error ""pointer being freed was not allocated."" Not sure what this means, and am a little confused on why it's only getting flagged after the entire compile check runs successfully.. . Also is there a compile check correct file/answer key? I want to see if these outputs are what they're supposed to be.. . "|119|0|active|The issue is very likely in your destructor. Make sure that your destructor doesn't have issues cleaning up all the memory it needs to (it shouldn't call pop more than necessary!)||0
l12z1cq3yom2v5|Friendship Declaration Location|Hi everyone. My code only compiles when I declare List as a friend in this section of the Iterator class, but does not when I declare it in the comment-marked section inside of private. Is it okay to declare it here, or how can I fix this issue? |110|0|active|Note that depending on where you implement your functions (whether you implement right where they are declared in `List.h`, or below them) and where you place your friend class declaration, the compiler will throw an error. (this is when the functions come before the friend declaration since the compiler will try to analyze the function but throw an error when trying to access private members of `List` since it hasn't reached the point of the friend class declaration) It's fine to move if to a place where it will work for your design, so long as you still implement the member functions we describe.||0
l12yxdpb8e33dk|Segmentation fault|I'm getting a segmentation fault when testing copy_all() through copy ctor. It stops at the safe_equals_helper function in the unit test framework. What could be causing this?. . In my test, I am making sure a value in the new list is equal to the value in the original list using ASSERT_EQUALS|268|0|active|See followups||2
l12yf1bzgqc6xg|No Tests Submitted|I am having a similar issue as a few people on here saying there are no test cases submitted but none of the answers have helped me so far I was wondering what I should do?. . Screen_Shot_2022-03-22_at_10.34.57_PM.png|153|0|active|Its generally from modifying the public interface for List.h and writing tests based on that modified public interface - this will cause a compile error because we don't compile your List tests with your List.h. People are probably going to run into this issue in unique ways, but the general advice would be to check that you have only added functions, operators, and constructors that we've suggested you add or have already included stubs for in the starter code.. . In your case, I would double check the constructors you've added for Iterator - there should only be the private constructor that takes in a Node * parameter, and a default constructor!||1
l12y36sxuwq3pi|Can the datum in the node be an object in dynamic memory in our list object?|Hello,. . Can the datum in the node be an object in dynamic memory in our list object?. e.g. doing. . list.push_back(*new int(1));. . If so, how is it possible to distinguish whether the object contained in node is is dynamic or not when we delete the node pointer. Because if nodes could contain  dynamic objects, then we'd have to find a way to delete them but make sure we're not deleting them if they're just static integers. . |78|0|active|That's a good question! Someone could absolutely use your List.h implementation to contain pointers that point to dynamic memory. However, that isn't dynamic memory you've created or are responsible for - that's on the user of your List container, so they need to make sure it gets cleaned up properly. There's no guarantee we're giving that our List class will manage any and all dynamic memory that makes its way into the container, instead we just guarantee we won't leak any memory that we're using to implement the basic list structure. Put differently, the type is the user's responsibility, and from our perspective inside the List, we just work with type `T` generically. There is no way to distinguish if someone is trying to store pointers to dynamic memory in the List, but that's okay because that's not our responsibility.. .  ||0
l12xozvdsj05ve|student list tests Valgrind error|I submitted the files in the autograder, and for the Student List tests section, Compile and Run passed but there's an error with Valgrind. It says that there's an error with my test for insert(), *i is 0 but it should be 3. But in Run test *i does equal 3 and it doesn't show an error, so I'm confused about why Run and Valgrind has different results. Can somebody explain to me? Thanks!. . |104|1|active|"The valgrind errors suggest you have undefined behavior in your program due to invalid memory access/usage in some way (in this case, it looks like using uninitialized values). Undefined behavior can cause the same program to behave differently on successive runs, despite nothing in the programming logic changing. So in this case, when the autograder ran your program in the ""Run"" test case, it looks like everything happened to work out so it could pass, but when it ran your program again through valgrind, it ran into some unpredictable memory bug that caused the different behavior.. . Your valgrind errors are all stemming from your test case test_insert itself though, rather than your List implementation (at least based on the stack trace) so I'd first check to see if you're test case is doing anything ill-defined "||0
l12xn4p7v1j6ub|nullptr increment|Should we have assert for iterator not to be nullptr for iterator increment and decrement? We can't increment nullptr right?. . But for comparing, ==, we do can take in nullptr as param and compare ?. |83|0|active|Yes, you are right.||0
l12wjisyiqm6q3|Comparison operators use of !=|". In the self assignment check of my assignment operator, it uses this != rhs similar to the lecture slide shown above. In autograder my code is not compiling saying, ""no match for 'operator!='. Am I expected to make an overloaded != operator to compare this and rhs together?"|145|0|active|No, you shouldn't need to overload !=. Make sure that you're doing &rhs and not just rhs, and make sure that you're doing this, not *this. ||1
l12w5t32ejx691|difference of lecture 16 and actual project|What is the difference in code implementation from what is in the lecture? Or is there no difference? If you can't say the difference may be a direction to go in?|66|0|active|Much of the project does take from lecture 16. However, lecture 16 only deals with a singly linked list, while the project is with a doubly linked list. That means that you'll have to take the prev pointer into account when writing your functions. ||0
l12vmicjg0ccd|How do I edit in CAEN?|I set up my files in CAEN, but whenever I edit my code it doesn't reflect when I run it in the CAEN environment. Is there a command I'm missing to synchronize my changes?|57|0|active|Revoked.||1
l12vl9yepwb7hs|copy_all()  and RME confusion|I don't understand the RME for copy_all(). It requires that the list is empty, but also copies all nodes over. If the list is empty, then there are no nodes to copy over, right?. . Isn't the entire point of copy_all() to be used in the assignment operator for List to comply with the Big Three?. . |16|1|private|"I think it means the list you're copying to should be empty before you start copying. So you just need to clear() ""this"" in the function before you do stuff. You can refer to the lecture slides, one of those shows a good framework of how this function should be written."||0
l12uyio9q3l4he|valgrind for list test|"I had a valgrind problem with my list test, I am not sure what exactly does it mean. My guessing is not deleting ""new"" in functions? But in my past submission, this function doesn't have a valgrind problem.. . . Or do you mind taking a look at my autograder for the precise error message?. . "|7|0|private|The error isn't directly related to deleting. It looks like what's happening is that you're trying to compare to something (on line 272 of your test), but that thing was already deleted in erase. ||0
l12uajr4cmm5wg|using iterator pointing to end() to erase|Say I have a list: 1, 2, 3. . If I want to erase the end of the list,3, how do I compare this iterator pointing at 3 to end of the list? . . I can't create a pointer pointing at end() because that is pointing at one past 3 but not 3.|155|0|active|You would have to create an iterator that points to the beginning, and then increment it twice so that it points at 3. ||0
l12t54cckqj5ax|Initializing a Node|Hey all, curious about node initialization:  In the lecture notes, I've only ever seen node initialized via:. . . which to me makes no sense seeing as the private data of the Node is a pointer to the next node, previous node, and datum.  So why are there only ever two arguments passed for initialization? shouldnt there be 3?|85|0|active|The lecture notes show how to implement a singly liked list. In the project, we are implementing a doubly linked list, so yes, there would be 3.||0
l12sziakrsk5b|== operator|Hey, y'all, I'm working on the iterator operator for == and !=. I'm getting a funky error because it's trying to compare a const Iterator and a non-const Iterator. It only happens in that order (because the operator is manually comparing the second thing to the first- it doesn't have any trouble comparing a non-const and a const in that order). How can I resolve this?|107|0|active|Hmm, could this be relevant?: @4558||0
l12rp7664ie3nt|what should happen if someone calls insert with the nullptr|since its one before should we assume the one before the nullptr is the last element?|102|0|active|"What I did is insert the element in the end. Since the nullptr is representing ""past the end."""||0
l12rj77r7xu34f|Node *first and Node *last|I want to clarify about these member Nodes given in List.h; are these Nodes meant to actually BE the first and last elements of the linked list, or are they simply intended to POINT to the beginning and end of the list? i.e., should first→datum or last→datum be modified (are they even relevant), or is first→next supposed to point to a different Node that actually will hold the 1st datum on the list? I'm trying to figure out how the Nodes should be modified and whether they should be deleted.|82|0|active|first and last should be the actual nodes that hold the datum for the first and last elements respectively. I hope that helps. I pasted a diagram from Professor Juett's slides, hopefully that's more useful than my description.. ||0
l12q0mhjb5o5uo|Error Message| undefined reference to `List<int>::Iterator::Iterator(List<int>::Node*)', keep getting this error message, any idea what it means?|112|1|active|Looks like an issue with trying to use the private Iterator constructor  that takes in a Node * parameter. Note that this is a private constructor, so you normally can't call it outside of the class - if you do need to access it from another class (such as List), consider using a friend declaration!||2
l12pa7h8iz0335|Function Stubs|Do we have to implement function stubs at the bottom of List.h, or can I implement the functions directly within the classes and functions defined in List.h|67|0|active|Either works for this project! We generally promote the ADT pattern where the implementation is separate from the definition of the class, but you may implement them directly in the definitions.||0
l12oqku8zxn82|Project 2 List_compile _check|When I run my program on the autograder, there is nothing wrong with my compile check, hiwever, when I run the List_compile_check with List.h in xcode I get a error.. Screen_Shot_2022-03-22_at_6.03.26_PM.png. Screen_Shot_2022-03-22_at_6.03.01_PM.png|83|0|active|Hmm, are you submitting the same program? Did you make any changes to it? And if possible could you run valgrind on your program and show the results? My guess is that it might be a changed file||0
l12nx2asz7y5ri|Copy constructor for a list object|Does a copy constructor for a list make an entirely new chain of nodes, or does it simply make two new nodes which are also the first and last nodes?|121|0|active|Copy constructor for a list object should copy all the nodes - if a `linked_list_1` is 1 --> 2 --> 3, then a copy of that into `linked_list_2` should be entirely new nodes that also go 1 --> 2 --> 3||0
l12nkqjjyj43dc|How do first (and last) get an address after initialization|As I understand it, the default ctor for List initializes first to be nullptr (same for last).. . . Then, when we push_front(), we have to create that new node, copy the specified datum into the new node's datum, set p->next to first (since it's the new first element), and set p->prev to nullptr (since p is at the beginning of the list), finally we copy p into first (since it's the new first element). However, the address of first (initialized to nullptr) is never modified. I just don't understand when/where we're supposed to update the addresses of first/last and what we're supposed to set them to.. |20|0|private|Remember that assigning a value to a pointer is *changing the address stored in the pointer variable*, and it doesn't actually affect the object it was previously pointing at before the assignment.. . So, when we do `first = p`, we *are* modifying the first pointer. I would try to draw a memory diagram of all the pointers moving around, and recognize that we get an entirely new address to some spot on the heap when we call `new Node`. So `first = p` is saying the first node is now the address of this new node we constructed on the heap. It can definitely be confusing working with all these addresses and pointers, so please feel free to follow up or stop by office hours!||0
l12nhqdmqmc4zg|question|are we supposed to have a print function for list.h|64|0|active|I don't believe so||0
l12m7fpqlbl48h|assert statement in dereference overload|. I am confused by the assert statement in this function because if node_ptr is just pointing at a node, when would node_ptr ever be null? If the pointer is deleted, isn't it undefined behavior so not necessarily a null pointer? Since each node has different data inside of it I do not really understand what it means to assert(null_ptr)... what exactly is this looking at?|99|0|active|It looks at if node ptr is a nullptr. This is because we wouldn't want to dereference a nullptr since that will give a segmentation error. When we use the delete keyword we don't technically delete the pointer but it still exists and it still points to an object||0
l12lyt5ay1n5en|friend class operator error|We are getting an error on our operator functions in the iterator class. We already declared List as a friend of the Iterator class. . . Error:. Non-friend class member 'operator*' cannot have a qualified name|91|0|active|Are you declaring List as a friend of the Iterator class within the Iterator class?||0
l12lae8b1q41jh|Stuck!|Hi, my partner and I are stuck on 35/42 and can't think of any other possible bugs to catch. Anyone have any ideas about a topic or area to focus on, or something we may have not considered? Thanks! :). . Edit: still stuck! we have a few more but really can't think of any else|201|0|active|Did you test the functions for iterators? Also try to think about different scenarios of list with different sizes. I think as long as you test those and cover most of the functions, you can pass the public tests. ||1
l12jwa5xl5g6wi|test cases|Just want to clarify, we need to write test cases for . push_front(), push_back(), pop_front(), pop_back(), insert(), erase(), empty(), size(). What else do we need to test? Can we just add *++-- in the above test functions to test them?|251|0|active|Don't forget to test the operators like =, ==, !=||0
l12j7bqao637j8|Adding helper functions to Iterator|are we allowed to add public helper functions to the Iterator class?. . EDIT: nevermind, I realized that I don't actually need this for my specific question.|76|0|active|marking as resolved||0
l12fwdtjx1r6y0|Valgrind error|Do we need to delete List or Node elsewhere? I used `clear()` in destructor, so I think all Nodes created would be automatically deleted. But why would there still be Valgrind error? Thanks so much for your help!!!. . constructor and destructor:. ```cpp. List(): first(nullptr), last(nullptr), sz(0) {}.   List(const List &other): List() {.     copy_all(other);.   }.   ~List() { clear(); }. ```. . This is the error output on Autograder:. ```cpp. ==78== 24 bytes in 1 blocks are definitely lost in loss record 1 of 2. ==78==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so). ==78==    by 0x407117: List::insert(List::Iterator, int const&) (List.h:232). ==78==    by 0x404841: test_insert() (List_tests.cpp:147). ==78==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420). ==78==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509). ==78==    by 0x404B9D: main (List_tests.cpp:173). ==78== . ```. . This is my `insert()` function:. ```cpp. void insert(Iterator i, const T &datum) {.     Node* node = new Node; node->datum = datum;.     if (i.node_ptr == nullptr) { // empty or point the end.       push_back(datum);.     } else if (i.node_ptr == first) {.       node->prev = nullptr; node->next = first;.       first->prev = node; first = node;.     } else {.       node->prev = i.node_ptr->prev; .       node->next = i.node_ptr;.       i.node_ptr->prev->next = node;.       i.node_ptr->prev = node;.     }.   }. ```. . this is my insert test case:. ```cpp. . TEST(test_insert) {.   List list; // 8 11 12 7 9 10.   list.push_back(9);.   List::Iterator it = list.begin();.   list.insert(it, 8);.   list.insert(it, 7);.   ASSERT_EQUAL(list.front(), 8);.   it = list.end();.   list.insert(it, 10);.   ASSERT_EQUAL(list.back(), 10);.   it = ++list.begin();.   list.insert(it, 11);.   list.insert(it, 12);.   it = ++++list.begin();.   ASSERT_EQUAL(*it, 12);. }. ```|9|0|private|I recommend drawing a picture of the linked list using circles for nodes and arrows for pointers, and stepping through your insert function while updating pointers. Whenever you call `new Node`, you should draw another circle somewhere near the list; whenever you assign a value to a pointer, you should update where that pointer is pointing to. You should also have two pointers drawn for the first and last pointers.. . If you go through this process for the different situations for inserting into a linked list, you should hopefully identify the causes of any leaks! A leak in this case would be having a Node that isn't connected to the linked list at the end of the function.||0
l12e06farqk2wd|Exception: p4 has triggered a breakpoint|Hello to all instructors!. . Due to time/exam conflict, I might have trouble attending the office hours before Thursday, so I want to post this question on Piazza now to see if there is any solution before I make it through the exams. . . Here is my insert function: . The issue is mainly on line 280. Before it on 279, I used the debugger to make sure that the begin() and the == functions were not the source of issue (they all successfully returned something). But right before I was able to go to 280, I was given this exception in delete_scalar.cpp (the debugger arrow was never at line 280): . . so I'm just wondering if anyone has any potential suggestions for how to solve this issue . . Sorry for the long post! . Any advice would be really appreciated!|8|0|private|Did you mean to include a screenshot of your insert function?. . It sounds like you're running into an error with moving past the condition of an if statement - you're able to step into everything inside, but just before you move into one of the branches, you throw a weird exception. One possibility is that when you call `begin()`, you return an Iterator object that only lives for the scope inside the if statement condition. Once the condition is evaluated, that begin iterator's destructor is called, so if the bug is coming from there, that could explain why you're seeing this behavior with your debugger. I think @4713 might be helpful to read through if you've created a destructor for your Iterator class!. . Good luck on your upcoming exams!||0
l12cpjcni2r66r|pop_all, push_all, big three|If i wanted to implement my own pop_all and push_all functions for the List class, can somebody explain why they would be private? . . Additionally, what is the difference between a function like pop_all and clear? And push_all and copy_all?. . Thanks|259|0|active|Pop_all() and clear() are equivalent functions but with different names; The same applies to push_all() and copy_all(). Also, we make push_all() (a.k.a. copy_all()) private because the user technically does not ever have a need to call push_all() directly. If the user ever wants to make a copy of a list, then they may use either the copy constructor or the overloaded equal operator via the Big 3 instead. ||1
l12bt9qz6ul3l1|segmentation fault errors when &#43;&#43; an integer/\.|So I declared a private integer variable numE that keeps track of the number of elements in the list. . Whenever I tried to ++numE after push_back or push_front, it says segmentation fault. When I get rid of the ++numE, the segmentation fault goes away. When I have more than one element in the list, ++numE works just fine. I'm not sure how tyring to ++ an integer variable will create a segmentation fault.. ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkswkxlvz8t52ut%2F3d7f7ac92c01b0d269b15a9ae035980d0e87e5ff3acb494ff095615165ce5413%2Fimage.png). ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkswkxlvz8t52ut%2Fd0dfb6b7ba8023a2241863ebc2e0dd177bef39771fffd9da81fc4441b8856671%2Fimage.png). ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkswkxlvz8t52ut%2Fd1cb2c8b6aa5365ebd184b276850005f5eae37cbff638d95e818e6666246d7b2%2Fimage.png). ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkswkxlvz8t52ut%2F3019f617a49a09a121622e25e305958212cc389ce6a2540b838d40684d07d4c0%2Fimage.png)|10|0|private|I'd recommend running with valgrind or address sanitizer to see if that will point out where the error is coming from||0
l12bh9rr22b6r|Why operator== is a member function?|In the example of lecture slides, `operator==` is a member function. But what is the reason that  we make `operator==` and `operator!=` member functions? . . Generally, when we overload `operator==`, it is not a member function. What we usually do is `bool operator==(const int &lhs, const int &rhs)`. I know there is no difference in usage. . . Here is an implementation from LLVM standard header files. The `operator==` is a non-member function.. . ![Screen_Shot_2022-03-22_at_11.55.08.png](/redirect/s3?bucket=uploads&prefix=paste%2Fke97zxvroac2cg%2F19579a9089a6abb10f07a2b4f212b9d46d9d203d02e9b157c0fd90eeab1227f3%2FScreen_Shot_2022-03-22_at_11.55.08.png)|138|0|active|Between member operator overloads and free operator overloads, it seems like there's only a few differences that would warrant using one over the other.. . One difference/benefit is that you can freely access private members inside the operator overload. If you needed to do this from a free operator function, you would either need to modify the public interface of the class to add accessors that you can use, or declare that operator a friend function as described here: https://stackoverflow.com/questions/2828280/friend-functions-and-operator-overloading-what-is-the-proper-way-to-overlo . . . . . Another difference is that by using the member operator overload, it requires the left-hand-side of any usage of that operator to be an instance of the class. For example, if you had a class that you want to allow adding numbers to, like. . ```. Duck d;. d + 2;     <--- does something. ```. We *could* implement this using a member operator overload, but we could not support the following usage with the member operator overload:. ```. Duck d;. 2 + d;. ```. Because 2 is an integer, not an object - we'd need to use a free operator overload instead, with the correct types for both arguments passed in.. . So in general that's what it seems like the differences are - if none of these apply, then its probably just a matter of preference. For this project, we do want access to Iterator's private members, and the left-hand side will always be of type Iterator for == and !=, so we went with the member operator overloads here. I guess we could have made it a free operator overload with that operator marked as a friend function from the Iterator class, but the member functions may have seemed simpler.. . That's my impression though, so anyone with more experience feel free to edit/followup!||0
l12atguvw5c3az|&lt;&lt; operator|I'm not sure what should be passed into the operator overload. I know it should just be one argument but I'm not sure if it would be an os stream or an iterator. I'm also not sure on what this should return. Are there any resources for implementing the operator<< somewhere?|163|0|active|I don't believe the operator<< needs to be implemented for either List or Iterator in this project.. . In general though, for implementing the << operator, you would take in a ostream reference and the object you want to print, and return the ostream reference like so:. ```. ostream & operator<<(ostream & os, const Object & thing) { }. ```. Where you would just return `os` after you've printed whatever you need to from the Object to it. The reason for returning it at the end is to support chaining prints like with cout: `cout << 1 << 2 << 3 << ...`. . But again, this isn't necessary at least for the List.h implementation!||1
l12a1qkdz7l4rn|how to test with test01.in|How do I use those provided test01, test02 to test my list.h? Is the server.py helping to run those test files?. . Or can I assume if I get full 42 on autograder, then I should pass all test01, test02,etc?. . |141|0|active|I believe those files are designed to work with api.cpp + your list implementation. But we're not writing the driver program this semester, so I don't think they are useful for us.||1
l125qlfu2405qp|segmentation fault error for tests|I am running my tests in the terminal and keep getting a zsh: segmentation fault error when I try to do the test. . ASSERT_TRUE(list.front() =='a');. . I had the program cout list.front() before this as well and it successfully prints 'a', so I am not sure why I am getting this issue. . |179|0|active|see followups||1
l11p9w2x28z6h5|Sorry, resolved!|I don't lknow how  to delete this|9|0|private|Marking resolved||0
l11o66rgilm7di|Does null count as an element?|Is a list still an empty list if we push NULL into it?|111|0|active|It depends on what type your list is, it can be a list of ints, doubles, chars, etc. So unless you have a list of pointers (which you probably never will), then no, null is not considered an element of a list.||0
l11lnjkzau05i5|no test submitted|"After submitting the test file, I faced this problem. Can anyone tell me how to fix it?. . My file contains this bug: Static_assert failed due to requirement 'is_equality_comparable<int &, nullptr_t, void>::value' ""types cannot be compared with == and !="""|113|0|active|It looks like you have an incompatible type comparison, which happens if you try to compare objects of different types||0
l11ldtaq34t4yc|Error when testing list.front()|I am getting an error when I test my list.front()--. . I am pushing back 5 values:. . list.push_back('a');. list.push_back('b');. list.push_back('c');. list.push_back('d');. list.push_back('e');. . So when I do list.front() it should be returning 'a'.... However, each time I run this in the terminal it returns 'e', which is odd to me because when I go to the debugger and step through, it works correctly and returns 'a'. I am not sure what I am doing wrong since my implementation is similar to the lecture slides...The only thing I can see that might be different is that I am deleting the new Node that I create to push back to the list. Should I not be deleting the node at the end of push_back?|6|0|private|If you delete the node at the end of push_back, it’s deleting the node that you just pushed into the list. Push functions should be allocating dynamic memory, but shouldn’t be deleting it.||0
l11l636c7br4pn|List constructors|Do we need any list constructors apart from the default and copy constructors?|192|0|active|We can’t explicitly give this answer away as thinking about the Big Three is the biggest part of this project. However, I would think about what other constructors you would be thinking of implementing. Would anyone be creating a List any other way? Does the Bug Three require any other constructors? Does List.h specify the need for any other constructors?||0
l11kzefsa2v7hv|iterator pointing|after an iterator erases a node in the list, which new node is it pointing to? the same with insert, if an iterator inserts a new node, whcih node is it now pointing to?|265|2|active|Put differently, neither insert or erase should change where the Iterator is pointing! For erase, this will invalidate the given Iterator.||1
l11kism9blcly|Question|Hi, . . I have a question: Could anyone give me any ideas of how to write more test cases for the linked lists? As far as I know that I've fixed 11 bugs per the autograder submission, and I'm looking for more ideas, and I'm not able to get any...|8|0|private|I think the best way to test linked lists is to consider different sizes, so I would test your functions on empty linked lists (if the RME doesn't require it to have nodes), a linked list with 1 node, and a linked list with 2 nodes, and then many nodes. Also make sure you write multiple test cases for each function||0
l11k03w7t6x75p|!= Operator Error|"We implemented the != operator almost exactly the same as our == operator, except a != in the expression instead of a ==. We have tried implimenting it literally dozens and dozens of different ways and we always either get a segmentation error or ""./List.h:153:14: error: non-const lvalue reference to type 'bool' cannot bind to a temporary of type 'bool'"". . I have no idea what else to do. Can anyone help?"|149|1|active|Are you returning your boolean by reference? There shouldn't be a need to do that because you don't need to modify that boolean for anything (and returning by reference, for simple cases like this, won't make your program much more optimized).||0
l11jmnmbwkr4x|friend|Say I have a iterator class inside list class.. . Without friend declaration, can list access interator's private variables (WHY)?. . Can iterator access list's private variables (WHY) ?|120|0|active|Because iterator was declared inside of the list class, iterator has access to the private member variables in list. Because iterator is a class with private members, its private members can’t be accessed outside of its member declarations. Therefore, Iterator can access list’s private members but list can’t access iterator’s private members. The place you probably want to use keyword friend is inside of the Iterator class.||0
l11jdye9wus4gh|Using &#34;List::Iterator::&#34; in overloaded assignment operator|"I'm declaring the operator overrides exactly as it says in the lecture notes here: . I'm getting an error on the ""template <typename T> line that says ""Declaration of 'T' shadows template parameter"" but when I replace it with any other letter it goes away. Will that create problems?. . Another error I'm getting is on the ""List<T>::Iterator::"" part for both where it says ""Nested name specifier 'List<T>::Iterator::' for declaration does not refer into a class, class template or class template partial specialization"". I'm not sure what this means but if I change the declaration to just ""bool operator=="" that error goes away but I think I need it so other areas can access it? I'm currently overriding in the public iterator class."|182|0|active|You're really close, the syntax you're looking for is something like this:. . bool operator==(Iterator rhs) const {. . So basically, you can just delete the List<T>::Iterator:: and it should compile||0
l11j90kxn0u2va|overloaded assignment = operator|Does the default = operator only copies the static member variables? If we have a node ptr variable in an iterator class, does it count as static?|112|0|active|The default = operator should only be dealing with variables in the List class.||0
l11j894pydhxn|Private functions|In project 4 should we only be testing the public member functions?|124|0|active|Make sure you're testing all the code you write, regardless of public/private. You'll probably find, though, that a lot of the private functions will be called anyways by other public functions so you might not need to explicitly test them.||0
l11ipnyyl886fd|Getting this error in autograder, how to fix?||71|0|active|It looks like you are reading invalid parts of memory. You are being pointed to List.h line 199. Double check that line of code and make sure you are not accessing memory that you have not allocated. Also, since you know which test is failing on the AG, try using your debugger to step through this test and see if you can find anything.||0
l11imz6zk5x3qq|do we have to write like list char in the test to get points?||75|0|active|I'm not sure I completely understand your question, but yes, you will need to write test cases to get points for catching bugs (just like you've done for P2 and P3). The list tests you write can contain `int`s, `char`s - whatever feels appropriate to you.||0
l11iev4nwov3nf|Delete in clear()|If we use delete in pop_front() and pop_back(), do we have to use delete in clear()? I would think we wouldn't have to because this would be a double delete, but I'm not sure. |127|1|active|It depends on how you choose to implement clear(). If you clear everything by calling pop_front (or pop_back) several times until everything is deleted, it would be redundant to use the delete keyword again. If you choose to manually delete all the elements, you’ll have to delete everything by yourself.. . (As you can probably see, one option is a lot easier to implement than the other!). ||1
l11id7afd7l5hs|Destructor|"For the destructor in list I tried to delete a pointer p to first that I then iterate through the list. However, it is saying ""pointer being freed was not allocated"". Am I deleting the wrong thing?"|135|0|active|If you delete p, then try to move onto p->next, there will no longer be a 'next' as p was just deleted||0
l11i3xhr9p4vo|No Test Cases Submitted|When I submit my tests cases, it says no test cases submitted. I don't have any for loops or i iterations. Does anyone know why that is happening?. |95|0|active|Looking at your submitted code on autograder, it seems that there are some compiler errors with your test cases. Are you calling your functions (like empty()) correctly?. ||0
l11hzz7hryf4xx|do we need test cases for iterator?||130|1|active|I would recommend testing iterator :))||0
l11hvtonpxy5d5|question|In iterator class in list.h it say .begin, what exactly is referring is that referring to?|70|0|active|When we have a list or container and we do something like: list.begin() , it will return an iterator that points to the first element in the list.||1
l11h823v31n1e2|Is writing the destructor really as simple as it seems?|Just wondering if there is anything more to it.|125|0|active|I think so. Because all the hard part is in clear(). If you've done that function, then the destructor is just as simple as calling clear().||0
l11h77ru9vl62a|Any suggestions on how to approach assignment operator function?||105|0|active|I would take a look at last week’s lab slides. There is a pretty rigid way to implement any assignment operator. You need to check for self-assignment, delete dynamically allocated memory, copy static variables, and deep copy the dynamic memory (think about which function you could use to do this within List).||0
l11h1do5b9c3wp|erase and insert|how do you use the erase and insert functions in List_tests.cpp?. If I declare an interator i, do i just do i.erase()?|219|0|active|You call erase on a list, ex: list.erase(you put an iterator here). Same for insert but you also give it data as parameter. ||0
l11focea2bs3|Xcode won&#39;t let me use custom working directory|"I am trying to debug my project 4 in Xcode but it won't let me use a custom working directory. It lets me edit my scheme and check ""use custom working directory"" but the folder selector bar is grayed out. What should I do?"|59|0|active|Did you try clicking on that small folder icon to the left of $(BUILT_PRODUCTS_DIR) and then navigating to your folder from there?||1
l11fhgaftl57el|if i use delete in pop() and use pop function in erase(), do i still use delete in the erase()||157|0|active|If you're using pop() to handle erasing the last node, then the pop should handle deleting that node and you don't also need to delete it in erase||1
l11f4eroq6c2k5|False Positive|Hi. I am getting false positives with a lot of my test cases and I'm not sure if my logic is just wrong and I'm not understanding the project because that would be bad. I have a very simple test case as an example of one of the false positives that I've attached. What is wrong with it?|8|0|private|You are explicitly calling your destructor in this test case, which is automatically called when you call delete l. Calling the destructor explicitly like this therefore results in a double-free, causing the AG to tell you false positive (not the best message the AG could give, but this is your issue).||0
l11etju1r6w3x8|What happens when I got this error?|I don't know what happens. All my private tests can be passed, but the AutoTrader shows this Valgrind error and cannot run.. . Screen_Shot_2022-03-21_at_8.39.28_PM.png. Screen_Shot_2022-03-21_at_8.36.43_PM.png|213|0|active|"see followups. Also, specifically the ""conditional jump error"" is saying that you have some uninitialized value in your code. "||1
l11eb4sxxrx3l7|overloading ==|bool operator==(Iterator rhs) const {        return node_ptr == rhs.node_ptr;    }. . This is how my operator== looks like, but whenever it is called, it crashes on the body of the function (return node_ptr == rhs.node_ptr;). I'm confused on why is this cuz I meant to compare the address that the pointer points to, but is it calling the == inside of operator==?|9|0|private|That looks good to me your error might be in a different part of your code that relies on those calls.||0
l11e8dv54m9zu|Iterator copy constructor?|I figured since Iterator doesn't use dynamic memory and just wraps a node pointer, it doesn't need a copy ctor, assignment function, or dtor, but I saw an instructor-endorsed student answer which said Iterator needed a copy ctor and I'm confused on what that'd even do. If you copy an Iterator, wouldn't it just copy over the node pointer stored in it?|153|1|active|@4713. . Also, sorry if I caused any confusion. I actually struggled 2 hours last night trying to implement deep copy for Iterator only to find out I don't need it at the end. I'm still learning!||1
l11e7nscw6879u|test case reveals function out of bounds error in wrong function|. . My pop back function wont work for some reason and it pulls an out of access violation error even though there doesnt seem to be an error. On paper it makes sense that there shouldnt be an error. the test case that caused it to fail is . this one which doesnt even touch pop back.. . Not quite sure how to fix it|8|0|private|Does your destructor use pop_back()? The issue might be there, since when you exit the function the destructor is implicitly called.||1
l11dr9im9dr6hb|previous node|Does the prev node need to be updated for all the pop and push functions or just the push functions since the pop functions delete the prev front and back nodes respectively.|135|0|active|They should (depending on the situation you may or may not have a previous node i.e. push to an empty node). Since this is a linked list, all nodes should be linked together properly. So when you add an item, you have to connect the previous node to the node you just added. And if you deleted a node, then you need to find a way to connect the nodes properly, so that you can traverse the list in the correct order through iterators.||0
l11dlmyr9w81go|end () function for the List class|Can we implement our end function for the List class where an Iterator is returned inside the class itself?|72|0|active|Yah. ||0
l11dctn05iq1x7|The Big Three For Iterator|Hello! Initially, my partner and I were under the impression that the Iterator class does not require the implementation of The Big Three, as it does not manage dynamic memory. This belief was reinforced by the lecture slides and post @4631. In the post, an instructor answer stated that we can infer that the Iterator class does not need customized constructors.. . However, the piazza post @4664 has a student answer (that is endorsed by an instructor) that states that an Iterator copy constructor, part of the big three, is required. We would just like some clarification, as these two posts seem to be contradicting. |270|0|active|"I think the endorsement in that second post was directed towards the first part of the student answer that copy_all isn't the copy constructor. I agree with both of your points that only classes that manage dynamic memory itself (i.e. create, use, and destroy dynamic memory) need the Big Three, and that the Iterator class doesn't really manage dynamic memory (its really just maintaining a pointer to the List's dynamic memory). Also, the comment in the List.h starter code states ""You should add in a default constructor, destructor, copy constructor, and overloaded assignment operator, **if appropriate**"", meaning the default versions of those are fine if they do what you need them to. So, I'd say you're on the right track! "||0
l11cpxpq5v35x2|copy all and size|When I implement the push_back() function, I have increased the private variable size. In copy_all() function, I use push_back(). Now copy_all fails, and I found there is something to do with size. May I ask if I should directly set the size of the new list to be the old list?|180|0|active|One thing to be careful of is that the size variable is appropriately set before you call copy_all in either the copy constructor or assignment operator. If you're letting push_back do the work of adding a new node, then its also going to be updating the size as you're copying nodes. So you want to make sure its initialized to 0 before you call copy_all so it gets incremented to the correct size of the other list||0
l11cd248zc427l|Generic Type without Default Constructor|Should the `List` implementation be able to handle a class type `T` that does not have a default constructor `T()` defined? I had a test for this which worked locally, but would not submit to the autograder.|6|0|private|You could implement `List` to handle a type `T` without a default constructor, but it isn't necessary for this project, so you don't need to.. . If you wanted to though, you would have to be more careful about how you create `Node`'s - since they're structs that contain an value of type `T`, if we can't assume that `T` has a default constructor, then we can't use `Node`'s default constructor anywhere in List.h either. So you'd have to take a look at any of your uses of the Node's default constructor and decide how to create the struct instead! Again, not necessary for this project though||0
l11c0gdcwnq7po|Style|. Can someone please explain what does this error mean? I am receiving this for basically all my style check. |141|0|active|That's strange - looking at your autograder, you are passing the compile check test for the style checking, but failing to compile for the rest of the actual style tests.. . You are getting a compiler error though, so that's why the autograder is unable to style check your code - take a look at the line numbers in the output (lines 204 and 205 of List.h) and make sure you aren't any List functions from the Iterator class. Also, we mention that you should add the Big 3 to the Iterator class *if appropriate* - I would think about when its appropriate to have the Big 3 for a class!||0
l11bsgktt1x5m8|pop front/back|if the size of the list is just 1, would we have to call delete or can we just set first and last to null pointers?|117|0|active|The node has to be deleted, even if the length is 1.||0
l11bcsruwaf4rh|Why copy all gives me a different size?|Hello! There is a size error that the correct size should be 1 but the given size is 2. We used debugger and found this was caused by the copy_all function. But we can not find where the copy_all function nor the push_back fucntion fails. . . Screen_Shot_2022-03-21_at_7.02.29_PM.png. Screen_Shot_2022-03-21_at_6.59.09_PM.png|11|0|private|The way you work with size in push_back seems okay to me. If you're calling copy_all from something like the copy constructor or the assignment operator, you need to make sure that the size variable is starting from 0 because you're using push_back to update the size instead. So, check your member initializer list and the assignment operator, because the issue could be there!||1
l11aknteeoy65i|pop_front|Do we need to reset the first->prev to nullptr after we implement pop_front? |86|0|active|Yes. ||0
l1194moipx713|valgrind error 4 blocks are definitely lost in record|In my autograder output for valgrind, I have 4 blocks definitely in loss of record, and it is telling me its is the line in push_front and push_back where I create a new node to insert in the list. Why would that be losing memory? I shouldn't have to delete the new node, do i?|263|1|active|It's not those functions. The reason why it is pointing to your push front and push back is that, in those functions you write new Node, and because of your other incorrect functions not deleting those Nodes, the Nodes you are creating with push are leaking memory. Make sure you use delete in your clear, erase, and pop functions, and that you have a destructor for list||2
l118pb5zzax7n2|Iterator == operator question?|Are we only checking for the value of the datum at these two points or are we checking that the memory location is the same.. Say we have a list named list1 and we copy it into list2 (creating new dynamic memory),. If we compare the iterator pointing to the first element of list1 to the iterator pointing to the first element of list 2 using the == operator are we supposed to get true or false?|117|0|active|It checks whether both iterators point at the same node or not, which would require the addresses to be the same||0
l117f95ykom4e7|Getting a compiler error for a lecture given function|void push_front(const T& datum) {.         first = new Node{ datum, first };.     }. Getting this issue for a push_front() that I got from the class slides.. . . . Anyone know a fix?|82|0|active|Project 4 is using doubly linked lists so the Node takes in a next, prev, and datum, instead of just datum and first.||0
l116p3u1604jb|Valgrind Issue|When I try to follow the steps on the valgrind setup to run my project on valgrind it isn't working. The screenshot is what happens when I try to follow the steps. If anyone knows what is wrong please let me know.. Screen_Shot_2022-03-21_at_4.50.33_PM.png|108|0|active|Make sure you don't run `make sync` from CAEN (from your terminal, you can tell from the hostname in the command prompt `@caen-vnc-mi12` that its ssh'd into a CAEN machine)! The sync command is only for moving your code from your local computer to CAEN, so you should only run it from a local terminal (rather than one connected to CAEN). I think that's a confusing thing about following the valgrind tutorial to the letter, it doesn't make that really clear.. . Another option is to use git, if you have version control set up. You can push your changes to gitlab, then clone that repo from CAEN to get your code onto CAEN.. . A third option as Carissa mentioned in the followups is to install valgrind locally - the steps aren't that difficult. I think for MacOS, the command would be `brew install valgrind`, then you can run any valgrind command locally on your computer from the terminal - you won't need to connect to CAEN.. . A wild fourth option is to use address sanitizer, which can give you a lot of the same hints as valgrind - you would just modify your Makefile according to this section of the tutorial: https://eecs280staff.github.io/p1-stats/setup_asan.html#quick-start. . That was a lot of different stuff, so feel free to followup if you need any help!||1
l1168k0k21q3m5|empty()|How do we know that a list is empty? Would first and last be pointing to nullptrs?|121|0|active|Yes, that is one way to tell. Another would be to see if size() == 0.||1
l1163mtwsqn3ih|Iterator constructor|Should there be a default iterator constructor that points to nullptr?. . Should the constructor that takes in a node * be a private member of Iterator?. . Thanks!|125|1|active|You should add a default constructor if you think the implicit default constructor won't do what you need it to! This might be helpful to consider: the implicit default constructor will leave member variables as uninitialized (which is not the same thing as nullptr).. . For the other Iterator constructor that takes in a Node pointer, it should be left as a private member. If you find that you need to access it from another class, consider this!: https://eecs280staff.github.io/notes/18_Iterators.html#creating-iterators (specifically the last paragraph in this section, leading into the next section on friend declarations)||0
l115srgijvr2xu|iterator &#43;&#43; question|why does ++i works but i++ cause compile error?|103|0|active|In the project, we only implement the ++i operator and not the i++ (they are different). So only use ++i.||0
l114mspb7f52lx|segmentation fault|I am getting a segmentation fault when traversing by node pointer in copy_all. In my for loop, I initalize the Node ptr to be other.first, end it at ptr, and set ptr = ptr-> next. Why is that getting me a segmentation fault?|160|0|active|Perhaps you're trying to access member variables of an object that's null (e.g. you try to access ptr->next when ptr isn't a Node).||0
l114iss64xm6kw|Having trouble with insert() function|Hello! We're having trouble implementing our insert() function. Here's what we have so far:. . However, we get the following error when running the compile check:. . Do you have any suggestions as to why we might be getting these errors?|5|0|private|Looks like there's a type mismatch - remember that Node pointers and Iterators are different types, even though Iterators are sort of similar to a Node pointer (it contains a Node pointer as a member variable). We'd need to access that Node pointer inside the Iterator like `i.node_ptr` - but, this is a private member variable of the Iterator class and `insert()` is a function in the List class. Is there anything we can do to let List access Iterator's private members?||0
l1148xdxcah2s6|custom constructor and assignment|". . Hi I write this line of code. I was assuming that it will use ""="" this  function. However, it invoke the constructor firstly(shown in the second picture).. I was wondering why it invokes the constructor firstly then invoke the ""="" function?. . Thank you.. . "|117|0|active|No assignment happens here. This is copy initialization—the copy constructor is called, and the copy assignment operator is not called.||0
l113kx6pooj7nb|compile_check|I tried to go through compile_check on my own, should. . cout << b << endl; . cout 1?|81|0|active|see followup||1
l113fbctwt7kj|Error Declaring Iterator|"I'm getting errors when trying to declare an Iterator.. (List_tests.cpp). . The first red squiggle says ""identifier 'Iterator' undefined"" and the second says ""expected a ;"". the push_front() and begin() functions are also already defined.. . (List.h). . My default constructor is in the public section of Iterator which is in the public part of List. I have also written ""friend class List;"" where the starter code said to add friendship. . . I have been looking at the code and the lecture slides and cannot find what I am missing. Is there something I need to add for this to compile?"|140|0|active|Iterator is a nested class of List class. That means you need to use a scope resolution operator with List in order to declare an iterator type. For example, List<int>::Iterator i = list1.begin();||0
l1138z611kw7e8|Node is unrecognized in Iterator Class|In our code, we don't understand why Node isn't recognized when we try to use it in our Iterator class. How should we go about fixing this issue?. |6|1|private|You shouldn't need to anything specific to get Node recognized in the Iterator class, so that's weird. I think it could be an issue with calling `empty()` - have you implemented that function?||0
l1136js1sxz7i8|Valgrind Error|I am getting this valgrind error when I run one of my test cases on insert but I don't get it on any of the other ones. I am wondering why that is. I will attach pictures of the error, the test case, and my insert function. My unique name is also sydvogel if you would like to check my autograder yourself. . . Error: Screen_Shot_2022-03-21_at_3.09.50_PM.png. Test Case: Screen_Shot_2022-03-21_at_3.12.33_PM.png. Insert function: Screen_Shot_2022-03-21_at_3.13.00_PM.png|7|0|private|I would draw out a picture of a few different scenarios when inserting into a linked list! Making sure that every single line, you update the appropriate pointers, and create any new nodes when you allocate memory using `new`. . . In this case, you may want to look more carefully at where you're creating new dynamic memory, and where it actually gets used in `insert()`.||0
l111h9qhp0d2gn|Error when trying to Overload = Operator|"Hi,. . I'm getting an error when I try to overload the = operator in List.h. Xcode says ""Expected ';' after access declaration"". I'm not quite sure where this error is coming from and how to approach fixing it.. Thanks"|7|0|private|You're missing the return type of the function in the function header.||0
l110es6lnci5io|Compile Check Failing|So I was able to pass the compile check previously, but then noticed I had memory leak issues so I added in a destructor and assignment operator for list, but now it says I have a double delete, but I have no idea why, because I looked into my clear() function and it's not supposed to do anything when the list is empty. Please help me with this?. . (Resolved!). . . . |7|0|private|Your assignment operator is missing one of the key steps, try adding it in and see if it helps!||0
l10yb568sp61y3|Unable To Understand The Error|When I run my code I get the following error, but I don't understand what it means. It seems to be the same error that occurs multiple times, but I don't know what the error itself is trying to convey. I've also made a submission on the autograder so you can look at my code if necessary to help me out. Any guidance would be appreciated!. . EDIT : I was able to figure it out. . |9|0|private|marking as resolved!||0
l10xgpucsy516f|I don&#39;t know where this error is coming from|My test cases are printing the right results but at the end I get this strange error. I do not really understand what pointer being freed was not allocated. I am thinking it is something to do with the delete in pop_back() but I am unsure.. |9|0|private|Does the pop_back() RME specify that the List cannot be empty? If so, you might want to assert this to see if that's where your issue is coming from.||0
l10x20yqdcf42o|Address Sanitizer errors|I keep getting WRITE address sanitizer errors on this function and I'm not too sure what's going on, any ideas on where to begin?|11|0|private|Can you provide a little more info about your error, such as a screenshot?||1
l10w18z4ohn1ia|Copy ctor|Should we be making a copy ctor for List as well as for Iterator?|171|0|active|Does List have any of its own dynamic memory? If it does, it needs its own copy constructor! (General rule: if a class has any of its own dynamic memory, it needs the big three)!||0
l10tiqkqg9l68t|general question about implementation formatting|Do we have to always put the function implementation below and then add a one line declaration within the class? or can we just implement in the class itself for some of them like the big three?|93|1|active|Up to you. ||0
l10t61z4r5f31h|Compile Operator Error|. The photo (taken from list_compile_check) shows that I have errors with only some of my operators- why does the == work in line one but not line two? Unsure on how it is different here? The error in line two says that no operator matches. |106|0|active|I've also seen the above happen in Xcode, if it persists after compiling (i.e. the build fails), follow up!||0
l10rf4chrr2k|Trick Instructions in List.h (Read Before Continuing)||140|0|active|||1
l109bht2wtc7a0|list compile check|What do I do about this compile check output? What does it mean?. |198|0|active|Have you defined a List Iterator constructor that takes in a Node* as an argument?||1
l1093wem87x6yq|Insert function|Edit---- Please ignore. Issue resolved|167|0|active|Marking as resolved||0
l108w6p2ym51ow|iterators|What is the syntax for declaring an iterator in a test case?|169|0|active|It will be of type `List::Iterator` with `T` as the underlying type of the list (whether `int`, `string`, etc.)||0
l107cfhn9fo2xx|Compile error for List.h|"When I try to compile the List_public_test.exe I get this error in my terminal:. . c++ -Wall -Werror -pedantic --std=c++11 -g List_public_test.cpp -o List_public_test.exe. Undefined symbols for architecture arm64:.   ""List<int>::empty() const"", referenced from:.       test_list_default_ctor() in List_public_test-1cca89.o. ld: symbol(s) not found for architecture arm64. clang: error: linker command failed with exit code 1 (use -v to see invocation). make: *** [List_public_test.exe] Error 1. . I'm confused as I do have code in my List.h file and the empty function as well, I was wondering if someone could look at my code in the AG and see what might've gone wrong? "|128|0|active|Based on your submitted files, it looks like the List.h you've submitted only has the starter code - I think this might've been a mistake, so you'll just need to submit the List.h file with all the functions implemented! If you compile before you submit, you should be able to catch any errors locally rather than on the autograder!||0
l1069sbb3sx529|double free|What do i do if I get this error?. |174|0|active|Looks like you might be deleting a pointer twice or a nullptr. Have you tried running on Valgrind to see if it narrows down which part of your code you should look at?||1
l10634o63nzpe|Style Checks P4|Hi, just checking if style checks are supposed to run on List_tests.cpp, since I thought they usually did not run on our test cases file. Thanks!|95|0|active|Style checks will be run on all submitted files to the AG.||0
l104lhdhptf641|Iterator pointing to a null|What happens when you deference an iterator pointing to the past-the-end in the lists? I'm guessing undefined behavior|99|0|active|Well, a nullptr will not point to a Node, so it will probably give you a runtime error||0
l104cj4dtxu5g6|monster css file p4|I was looking through the css file for p4 and it has over 17k lines of code so I was intrigued.. . Is it normally that long for a simple website?. . How long did 17k lines of css take to put together?|85|0|active|"I would say that 17k lines of CSS is not ""normal"" for a simple website, but also that it's still pretty commonplace due to CSS frameworks and libraries.. . In the case of the office hours queue, I believe bulma.io was used to generate most of the CSS for the stylesheet. So, it wasn't hand-written, and probably didn't take *too* long to put together."||0
l103poahigk3oz|custom constructor|how can I fix it? Isn't this a constructor?|7|0|private|resolved :D||0
l102fl3le38ex|Accessing size private variable from List class?|We have declared list as a friend class inside the iterator class. However, we are unable to access the private member variable from the functions in the list class. (We are able to use the private member non-default constructor in Iterator for whichever functions in List require them though). . . Please guide us. Thank you! |178|0|active|you shouldn't need to access any private member variables such as last. You can use the node_ptr member variable of the Iterator class! The iterator one past the end should just be a nullptr!. . Hope this helps!||0
l1023e60zdl2v3|List constructor|Just to clarify, the constructor for List should just  create an empty List right with first and last being nullptrs?|124|0|active|The default one, yes, since List starts out empty||1
l101bx4al887kn|Error for Iterator constructor|What do these mean?|101|0|active|1) I'm confused why you are writing Iterator::Iterator. 2) your == error on line 190 is comparing two different types. Looks like the thing on the left is an Iterator and the thing on the right is the address to a node pointer||0
l0zzjpis2sq1he|question on lecture code|. this is the code from lecture notes, but when i input the last=last->next=new_node, it shows bad access. why?|95|0|active|It is probably because last is a nullptr. You can't access ->next of a nullptr. I would check how you implement empty() and make sure that you are always updating the variable you are using to implement (whether it be listSize, first or last). . . Hope this helps!||0
l0zzjafw73q68w|copy constructor|is it okay to pass in an empty list into the parameter? |120|0|active|I believe it should be fine since I tried it with mine and it worked||0
l0zyjxjjwiw9f|Question|. Hi,. . Is my copy all function correct?? I've attempted to get this function, could I know if this is correct, or if there is anything needed to be added? I've been testing this function thoroughly, and I have been getting the segmentation fault.. . |10|0|private|When you are copying all, you are going to need a for loop to loop through all of the nodes of the other list. Think about what functions you have already implemented that you can call in this for loop to add nodes to the list one by one.. . Hope this helps!||0
l0zxi99edvz5zl|Segmentation Fault in Ubuntu but not the Visual Studio Debugger|When I run my test cases through the Visual Studio debugger, it runs fine without any segmentation faults. But when I run it through Ubuntu I keep getting a segmentation fault error. I'm unsure of what to do since it's really hard to comb through all my code to find what's causing the memory error without a debugger.|160|0|active|"I would suggest looking at your deconstructor and make sure it deletes all of the memory as well as doesn't access bad memory such as node-> next when node is a nullptr. I would also suggest adding ""cout"" statements to your code. Those will print to the terminal (Ubuntu) and will help you analyze where the segmentation fault could be coming from.. . Hope this helps!"||1
l0zvktmj8he1sc|Copy Constructor / copy_all()|Is void copy_all() itself the copy constructor or shall we implement another copy constructor called List(const List<T> &other)? Thanks|203|1|active|copy_all is so that there is no code duplication between the copy constructor and assignment operator.. . you do need dynamic memory!||1
l0zuv69tlzh41x|&#34;No test cases submitted&#34; why???|"Autograder keeps giving me this ""No test cases submitted"" error message & I cannot figure out why?? I already went through my entire implementation to make sure we've implemented everything necessary + didn't change the given public interfaces & I have no more ideas of what to try... . "|126|0|active|I had the same issue but you should look at the operators you are using. If you are using a for loop, it should be ++i at the third statement, not i++||0
l0zus6xpwdx80|What should list_test be like?|I wrote test cases based on List<int>, and i pretty much copied the test code structure from lecture slide like these:. . . list.push_front(1);    . list.front() = 4;      . list.pop_front();        . list.empty();    . They works fine but I wonder how are these connected to our projects' theme json objects?. . Should I test using Json objects, like below? Or using Int is already enough?. json j2=.......  list.push_front(j2); . |125|1|active|you can try with different types like string, char, bool etc also||0
l0zu2d3cfq56kz|Style Question (Comments)|"Do comments count for the ""long lines"" style check? I remember reading at some point that comments don't count for style checking but I can't find it again and now I'm wondering."|81|0|active|I think comments count for the long lines check but not for the long functions check||0
l0zru4xkgy42co|Is the Copy Constructor Required?|If we pass in all the Iterators to functions using const reference, do we still need to copy constructor?|189|1|active|Probably necessary for private tests||0
l0zqrtts7to22s|False positive|TEST(test_erase_2) {    List<double> l1;    l1.push_back(2.1);    l1.push_back(3.2);    l1.push_front(1);    List<double>::Iterator i = l1.end();    l1.erase(i);    ASSERT_TRUE(l1.back() == 2.1);}. . This test case was marked as false positive in autograder. Isn't l1.back() supposed to be 2.1? l1 was initially 1, 2.1, 3.2, and after erasing the end node, it became 1, 2.1. Why would it return false-positive message? Thanks!|7|0|private|"Remember that `Iterator end()` points to ""past the end"" and not the last element."||0
l0zqlt6zje23hy|Code for member functions in List|When writing my code for the member functions I found a lot of the code for the list functions in the slides. Is this okay to use or is it considered an honor code violation?|116|1|active|You're welcome to use any of the code provided in lecture slides!||0
l0zq9lumvcb672|Error &#39;forward_list&#39;|We've tried getting ride of the #include <forward_list> in the json.hpp and tried getting rid of other instances of this forward_list in the json.hpp but we keep getting this error. Anyone know how to solve it? . Thank you!. . . |71|0|active|Looks like `` is a library included in json.hpp - you shouldn't have this included in either List.h or List_tests.cpp if you do||1
l0zq2pibpfn6kc|List_tests.cpp|"In my list test file, I get an error in my first line at #include ""List.h"" where it says the List.h file is not found for some reason? "|113|0|active|Did you have list_tests and list.h in the same folder?||0
l0zpoas4kv25c5|Weird Valgrind Warnings/Errors|When trying to make List_tests.exe, I'm receiving some strange errors (mainly having to do with initialization). Am I actually supposed to initialize these some other way?|7|0|private|That is the correct way to implement the constructors. I would check where you implement each of these. Make sure listSize is in the private member variables inside the class and make sure any functions (including constructors) should have:. . template <typename T> . List<T>::List() : ..... {}. . Hope this helps!||0
l0zphw0odid2df|push back does not work when using copy all function||119|0|active|The best advice I can give you based on the information given is make sure you increment / change the listsize variable in the copy all function. Make sure you delete all nodes and set the listsize variable to 0. Then, create new node copies and make sure you increment the listsize.. . Hope this helps!||0
l0zp352k34e34q|when test the List_compile_check||188|0|active|There's not enough information here to help you solve this issue. It looks like the list is empty when the test calls pop_back, and I'm assuming before the pop_back call there is some sort of push call (so the list should not be empty). Have you tried stepping through the compile check?||1
l0zp0txh38b2gd|Where does the iterator point to?|When the linked list is empty, let iter be an iterator pointing to the begin of the list, so now iter should be nullptr. But at this time I push back a value to the list, and I do ++iter. Now where does iter point to? Should it also be a nullptr or points to the value?|155|0|active|You cannot increment a nullptr so you would get a segmentation fault. In order to have an iterator to the beginning of a once empty list, you would have to create a new iterator.||0
l0zof0hil9j30s|Make p-&gt;prev or p-&gt;next empty after delete|"```cpp.   //REQUIRES: list is not empty.   //MODIFIES: may invalidate list iterators.   //EFFECTS:  removes the item at the front of the list.   void pop_front() {.     assert(!empty());.     Node* p = first;.     first = first->next;.     delete p;.     p = nullptr; // question line.     --sz;.   }. .   //REQUIRES: list is not empty.   //MODIFIES: may invalidate list iterators.   //EFFECTS:  removes the item at the back of the list.   void pop_back() {.     assert(!empty());.     Node* p = last;.     last = last->prev;.     delete p;.     p = nullptr;  // question line.     --sz;.   }. ```. on question line, should I put `p = nullptr;` or `first->prev = nullptr;` and `last->next = nullptr;`?. Is it right to always keep `first->prev = nullptr;` and `last->next = nullptr;`? . . And in `empty()`, is it enough to only ensure that `first == nullptr || last == nullptr;`? Do I have  to compare the relative position between `first` and `last`, like `first "|13|0|private|"When you delete a node, the best way to assign nullptrs is to say p = nullptr. This ensures the computer knows that p no longer points to a node (because it is deleted and doesn't exist). Setting p->next to nullptr or last->next to nullptr would be redundant because when you set p = nullptr there is no p->next (since the node doesn't exist).. . In empty(), that can definitely be the way to ensure it is empty, however first and last must both be nullptr so it should be a && instead of ||. Ensure that you always set first and last to nullptr when needed!. . Hope this helps!"||1
l0znz4gsmu24a5|Code duplication style check list_tests.cpp|In the autograder, I am failing the style check for my list.cpp file. For tests, I thought it was okay if there was code duplication. Is it different for this project?|90|0|active|Marking resolved - based on your most recent submit, it looks like you've fixed the issue!. . bkayes: I don't believe code duplication is allowed in test cases - this has been true for all previous projects as well.||3
l0znw6c3c82xu|2 Questions (segmentation fault and general question about implementation formatting)|So the first one is pretty simple: do we have to always put the function implementation below and then add a one line declaration within the class? or can we just implement in the class itself for some of them like the big three?. . Also, I've been receiving a segmentation fault on CAEN but within the autograder and my own IDE, I recieve no issues (on the compilation check). . . . (it also runs to the very end and I tested this earlier by putting a cout before the return statement), so what could be causing this?. . Thank You|180|0|active|1 - it does not matter if you implement the functions outside of the class and add the function declarations in the class or if you just implement them directly in the class.. . 2 - this could potentially be caused by trying to access a bad address of a pointer (ex: node->next where node is a nullptr) or by your delete (or a combination of the both). Since your code makes it to the very end, I would suggest double checking your deconstructor to make sure it correctly deletes everything (no memory leaks) and make sure you don't access any bad addresses like nullptr. . Hope this helps!||0
l0znepn2om42jg|Compile check error saying functions aren&#39;t recognized|I am getting this error when I run the compile check that says . . List_compile_check.cpp:35:40: error: no member named 'begin' in 'List<int>'.     List<int>::Iterator iter = my_list.begin();. . What does this mean? The begin function is in the iterator class which is a nested class of List, so shouldn't this function be inherited? Could this have something to do with the = sign needing to be overloaded? Not really sure what to do here. |122|0|active|`Iterator` doesn't inherit any functions from `List`. `begin()` should be a member of `List`, not `Iterator`.||0
l0zl608b1vw2b7|Address Sanitizer|What does this error mean?. |8|0|private|This means you are reading into memory out of bounds. It looks like you are being pointed to line 208 (somewhere in your push_back function).||1
l0zkfipw4c4n3|Segmentation fault for empty()|When attempting to run public tests after finishing with List.h, my partner and I are receiving a segmentation fault for empty. Below I have attached terminal and our code. We received the code directly from the lecture slides so we are confused on why we would be receiving this error. |10|0|private|A segmentation fault is the result of some bad memory access. Comparing a pointer's address to 0 (the meaning of `first == nullptr`) doesn't really involve risky access of dynamic memory (`this` is not nullptr for sure because the lists are created on the stack in your tests). The problem is most likely not in `clear()`. What does Valgrind, Address Sanitizer, or your debugger tell you if you run the public test with one of them?||0
l0zjjq35lyj152|Intellisense|"I got a red squiggly line in the List_compile_check, even though it works when I compile it on WSL. Here's what it looks like:. . . In List.h, an intellisense message pops up:. . . Should I ""Add All Existing Instantiations""?"|94|0|active|Try running make List_compile_check.exe. This will check if there are any compile errors that the autograder will catch, so as long as make works you can still debug and run your code. The error could maybe be caused by a simple syntax error like a missing ; or }. If fixing the compile errors doesn't help, I would suggest going to office hours for more interactive help!||0
l0zilys0z292dr|Resolved||8|0|private|Marking resolved||0
l0zih2rvd6t5gd|Question about compile error|When we run compile-check, we keep getting this error about the private member functions we created in the iterator class, and we don't really know how to fix this. . |143|0|active|"> ""error: [...]::List::Iterator::operator[...]() is private within this context"". . Why would a function being private constitute an error? It's probably because you are trying to access a private function of Iterator somewhere outside Iterator. Since the compile check uses these overloaded operators outside Iterator, you can infer that these overloaded operators must be public. What remains is for you to make them public."||0
l0zhsxe3b8jv2|What should iterator point to|What should the iterator point to when you erase the node it is currently pointing to?|268|4|active|Don’t need to worry about this. In this situation, that iterator is invalid. Any actions that are trying to use such invalid iterators are undefined. Just like use already deleted pointers.So, AG will not test your implementation against test cases like this. But you should not use invalid iterators in your own implementation/tests either.||2
l0zhib9rmk34nk|Duplicate Private Member Variable Size|I have tried to add a private member variable int size to keep track of the size of the list, but when I run the public test it says that it is being created more than once. I looked through the whole List.h file, and I couldn't find it declared anywhere else. This is where I am declaring it. Any suggestions? |139|0|active|"You can't call it size because there's already a function called ""int size() const"". Just call it list size or something."||0
l0zflyj6sp12zo|Do we need to implement iterator class before we can do anything with List?|"I tried to make a List constructor so I could to tests on my list class, but I get errors saying ""argument list for class template 'list' is missing"". Is this because I have not implemented the iterator class yet?"|190|0|active|If you are implementing the constructor outside the class definition, make sure to give the function signature a templated type variable like so: `template`. Then, ensure that the fully qualified name of the function is `List::List`.||0
l0zdvtac1be2ud|Why assert has an error?|After I wrote erase and insert functions, there shows an error that the assert(note_ptr) fails. I use the debugger to find the fault and I checked those two functions again and again but did not find any way to solve it. Just stuck here for a night. Could you give some hint of why this occurs? thx! (Here is the error and the two functions). . Screen_Shot_2022-03-20_at_10.33.34_AM.png. Screen_Shot_2022-03-20_at_10.37.24_AM.png. Screen_Shot_2022-03-20_at_10.37.32_AM.png|9|0|private|The assertion is failing because node_ptr points to a nullptr. There are no glaring errors in your erase and insert functions. Without knowing what test case you were running it on, it is hard to tell what could be causing the issue. I would double check your test case to ensure you initialize the node_ptr to a valid node through the constructor. I would also double check your push front and back functions to ensure that all the pointers are set correctly and a nullptr isn't accidentally assigned to the wrong node.. . Hope this helps!||0
l0ysob4s4hn6iq|List::end()|"I'm somewhat confused about this. If we have List::end() return an iterator ""past the end,"" meaning its node_ptr is nullptr, is it impossible to iterate through the list backwards since that iterator will fail the assert(node_ptr) given in Iterator::operator--()?"|168|1|active|The students' answer is correct. For STL data structures, you would use `rbegin()` and `rend()` to traverse through the container backwards. _This is not expected for your List\ implementation---do NOT implement `rbegin()` or `rend()`._||0
l0yrqk56eqt7ko|What lecture should I be up to to succeed on Project 4?|I'm behind in lectures, is there a certain one I should be at in order to be successful on this project?|131|0|active|At the top of the 280 course website in the announcements section it says lectures 16 (linked lists) and 17 (iterators) are covered in this project.. . In my section (004), there will be some wrap up of Iterators at the beginning of 18 as well.||2
l0yq7xzr5q56c|Error Trying to Call List Member Functions in Iterator Class|I was trying to call some member functions of the List class to implement an overloaded operator, and received the error message the same as the one below:. . I've already declared List as a friend class to Iterator in the private section, but is there something else I'm not aware of?|129|0|active|"**Friendship is not necessarily symmetric.** Here, this means that if you declare that ""List\ is a friend class of Iterator"", you enable List\ to access the private members of Iterator, but not vice versa---Iterator still can't access the private members of List\.. . Are you sure you need to call `clear()` in Iterator?"||0
l0yplzg59fi3to|Address Sanitizer Error Running List_compile_check|My partner and I are running into an issue when running List_compile_check. When it gets to my_list.push_front(42), address sanitizer gives this error:. . . Does this mean that we're trying to use something that has already been deleted? We weren't exactly sure when we could have done that, as at the line address sanitizer refers to, we are making a new Node in the pop_front() function.|6|0|private|resolved||0
l0yplek6stgs|pop_front()|I checked a previous post about pop_front() and I added a condition of size() == 1, but still got this error. How to I fix it?|11|0|private|What tests have you tried so far? Which test is failing? ||1
l0yozrthie57go|Template and copy constructor|Do we need to account for the big 3 for the iterators and I'm also confused on how to work with the template?. |204|0|active|Generally, you need to customize the Big Three for a class if-and-only-if that class _owns_ dynamic memory directly. A `List` _owns_ the nodes inside it directly, so it needs the Big Three customized. A `List::Iterator` holds a pointer to a node, but it does not own that node---when an Iterator goes out of scope and gets destroyed, it shouldn't destroy the node it's pointing to. Therefore, you can infer that an Iterator doesn't need the Big Three customized.||0
l0ynxtrfrqd3vt|Question about pop_front and pop_back|Do we have to consider that if there's still nodes left to remove inside pop_front and pop_back function? Or that we should consider this outside these two function?|133|0|active|Not sure I understand your question. For the two functions you mentioned, in the RME we require that the list is not empty (at least one node) so you do not need to consider the case that when the list is empty and those two functions are being called. (If this is what you asked.)||0
l0ynwastp7t6so|destructors for identical lists|In one of my test cases, I created two lists, list1 and list2. I did list1 = list2 and checked that both lists had the same elements. When the program ends, list2 has all its elements cleared, but list1 immediately crashes when put into the destructors. I use pop_front() to clear.  For some reason, deleting the elements in list1 is causing issues. Any help would be appreciated.|173|0|active|Did you use deep copy? If not, after you delete all the nodes in list2, list1 is like dangling pointers and you may not use dangling pointers.||1
l0yno9uuxnk33e|Insert clarification|Suppose now I have an int list consisting of 1,2. If I let iterator 1 be the beginning of the list. Now I insert 5 before iterator 1. What would iterator 1 now be?|177|0|active|The iterator itself doesn't change. The node that the iterator points to now has a prev node 5. In general, think iterator provides you some location information so you may successfully find the node that you care about and insert a node before it.||0
l0yma5o2jc26nc|List_tests.cpp &#34;No test cases submitted&#34;|The following error is showing up on Autograder. List_tests.cpp seems to be compiling fine in VS Code. Any idea as to why this is happening?  |186|0|active|Make sure you aren't modifying the public interface of any class we give you, including `List` and `List::Iterator`. Also, please add your uniqname to your Piazza display name (instructions in @6) so that we can look up your Autograder submissions more easily.||2
l0yl6ku2ctf1m4|Question|Hi, . . I have a question: I'm confused as to why am I having the segmentation fault for the Test_13... Please help me in understanding this error, since the autograder is saying that the Test case is correct absolutely correct, because if the Test case is wrong, It will give you the Red warning that your test is incorrect...  . . . . . |13|0|private|Have you tried running valgrind on your tests? This will help you narrow down where the segfault is happening.||1
l0yiygnlord1aq|Comparing lists of different types|If we're comparing two lists (using overloaded == or !=), if the datum types in the nodes of the lists are different (eg. List<int> vs List<string>), this should result in a type mismatch right? Or should we consider this case and output some kind of error statement? . . Edit: also same for assignment operator, what should happen if we try to assign a List<int> to a List<string>?|118|0|active|List<int> and List<string> are technically two different classes, each of which have operators defined for doing certain operations between lists of their own type, but not between a list of their own type and another list not of their own type||0
l0yikp13kqu3fw|Error with Testing the Iterator?|"For the last 3 tests that I made, there was an error when it came to the for loop I was using but I don't understand why because I used the code from the lectures when writing the loop.. . These are the error messages:. name followed by '::' must be a class or namespace name. expected a ;. identifier ""i"" is undefined. . If any instructor can look at my autograder submission (the error appears in the last 3 tests, so I commented them out before submitting) that will be great"|112|0|active|Ok I managed to fix some of the errors but its still wrong||1
l0yhprz6xzd1le|Use of iterators in list functions|Hi,. . I was wondering if we need to use iterators for any of the functions before the iterator class is declared in the list.h file. For example, functions like push_front and pop_back. . . Thanks|117|0|active|You do not need to use iterators for those functions.||1
l0ygrje6kb24oe|&lt;&lt; not found when it&#39;s there|"#ifndef LIST_H#define LIST_H/* List.h * * doubly-linked, double-ended list with Iterator interface * Project UID c1f28c309e55405daf00c565d57ff9ad * EECS 280 Project 4 */#include <iostream>#include <cassert> //assert#include <cstddef> //NULLtemplate < typename T >class List {    //OVERVIEW: a doubly-linked, double-ended list with Iterator interfacepublic:    //EFFECTS:  returns true if the list is empty    bool empty() const {        return first == nullptr;    }    //EFFECTS: returns the number of elements in this List    //HINT:    Traversing a list is really slow.  Instead, keep track of the size    //         with a private member variable.  That's how std::list does it.    int size() const {        return listSize;    }    //REQUIRES: list is not empty    //EFFECTS: Returns the first element in the list by reference    T& front() {        return first->datum;    }    //REQUIRES: list is not empty    //EFFECTS: Returns the last element in the list by reference    T& back() {        return last->datum;    }    //EFFECTS:  inserts datum into the front of the list    void push_front(const T& datum) {               Node* newFirst = new Node;        newFirst->datum = datum;        if (empty()) {            first = last = newFirst;        }        else {            first->prev = newFirst;            newFirst->next = first;            first = newFirst;        }        ++listSize;    }    //EFFECTS:  inserts datum into the back of the list    void push_back(const T& datum) {                Node* newLast = new Node;        newLast->datum = datum;        if (empty()) {            last = first = newLast;        }        else {            last->next = newLast;            newLast->prev = last;            last = newLast;        }        ++listSize;    }    //REQUIRES: list is not empty    //MODIFIES: may invalidate list iterators    //EFFECTS:  removes the item at the front of the list    void pop_front() {        if (listSize == 1) {            delete first;        }        else if (listSize == 2) {            Node* newFirst = first->next;            newFirst->prev = nullptr;            newFirst->next = nullptr;            delete first;            last = first = newFirst;        }        else {            Node* newFirst = first->next;            newFirst->prev = nullptr;            delete first;            first = newFirst;        }        --listSize;    }    //REQUIRES: list is not empty    //MODIFIES: may invalidate list iterators    //EFFECTS:  removes the item at the back of the list    void pop_back() {        if (listSize == 1) {            delete last;        }        else if (listSize == 2) {            Node* newLast = last->prev;            newLast->next = nullptr;            newLast->prev = nullptr;            delete last;            first = last = newLast;        }        else {            Node* newLast = last->prev;            newLast->next = nullptr;            delete last;            last = newLast;        }        --listSize;    }    //MODIFIES: may invalidate list iterators    //EFFECTS:  removes all items from the list    void clear() {        while (!empty()) {            pop_front();        }    }    // You should add in a default constructor, destructor, copy constructor,    // and overloaded assignment operator, if appropriate. If these operations    // will work correctly without defining these, you can omit them. A user    // of the class must be able to create, copy, assign, and destroy Lists    List() {}    ~List() {        clear();    }    List(const List& other)        :first(nullptr), last(nullptr) {        copy_all(other);    }    List& operator=(const List& rhs) {        if (this == &rhs) { return *this; }        pop_all;        copy_all(rhs);        return *this;    }private:    //a private type    struct Node {        Node* next;        Node* prev;        T datum;    };    int listSize = 0;    //REQUIRES: list is empty    //EFFECTS:  copies all nodes from other to this    void copy_all(const List < T >& other) {        for (Node* np = other.first; np; np = np->next) {            push_back(np->datum);        }    }    Node* first; // points to first Node in list, or nullptr if list is empty    Node* last; // points to last Node in list, or nullptr if list is emptypublic:    ////////////////////////////////////////    class Iterator {        friend class List;        //OVERVIEW: Iterator interface to List        // You should add in a default constructor, destructor, copy constructor,        // and overloaded assignment operator, if appropriate. If these operations        // will work correctly without defining these, you can omit them. A user        // of the class must be able to create, copy, assign, and destroy Iterators.        // Your iterator should implement the following public operators: *,        // ++ (prefix), default constructor, == and !=.    public:        // This operator will be used to test your code. Do not modify it.        // Requires that the current element is dereferenceable.        Iterator& operator--() {            assert(node_ptr);            node_ptr = node_ptr->prev;            return *this;        }        Iterator& operator++() {            assert(node_ptr);            node_ptr = node_ptr->next;            return *this;        }        Iterator& operator*() {            assert(node_ptr);            return node_ptr->datum;        }        bool operator==(Iterator rhs) const{            assert(node_ptr);            return node_ptr == rhs.node_ptr;        }        bool operator!=(Iterator rhs) const {            assert(node_ptr);            return node_ptr != rhs.node_ptr;        }                        Iterator():node_ptr(nullptr) {}    private:        Node* node_ptr; //current Iterator position is a List node        // add any additional necessary member variables here        // add any friend declarations here                // construct an Iterator at a specific position        Iterator(Node* p):node_ptr(np) {}    }; //List::Iterator  ////////////////////////////////////////  // return an Iterator pointing to the first element    Iterator begin() const {        return Iterator(first);    }    // return an Iterator pointing to ""past the end""    Iterator end() const {        return Iterator();    }    //REQUIRES: i is a valid, dereferenceable iterator associated with this list    //MODIFIES: may invalidate other list iterators    //EFFECTS: Removes a single element from the list container    void erase(Iterator i) {        if (i.node_ptr == last) {            pop_back();        }        else if (i.node_ptr == first) {            pop_front();        }        else {            Node* nodeToRemove = i.node_ptr;            (nodeToRemove->prev)->next = (nodeToRemove->next);            (nodeToRemove->next)->prev = (nodeToRemove->prev)                delete nodeToRemove;        }        --listSize;    }    //REQUIRES: i is a valid iterator associated with this list    //EFFECTS: inserts datum before the element at the specified position.    void insert(Iterator i, const T& datum) {        if (i.node_ptr == first) {            push_front(datum);        }        else {            Node* nodeToAdd = new Node;            nodeToAdd->datum = datum;            nodeToAdd->next = i;            nodeToAdd->prev = i->prev;            (i->prev)->next = nodeToAdd;            i->prev = nodeToAdd;        }        ++listSize;    }}; //List////////////////////////////////////////////////////////////////////////////////// Add your member function implementations below or in the class above// (your choice). Do not change the public interface of List, although you// may add the Big Three if needed.  Do add the public member functions for// Iterator. template <typename T>std::ostream& operator<<(std::ostream& os, typename const List<T>::Iterator it) {    os << (it.node_ptr)->datum;    return os;}#endif // Do not remove this. Write all your code above this line.. . . . My code won't compile because ""Error C2679 binary '<<': no operator found which takes a right-hand operand of type 'List<int>::Iterator' (or there is no acceptable conversion)"". . I've tried overloading << for a few hours now, looking how it was done in previous projects and looking at the lecture slides, but I'm not sure what I'm doing wrong with the overload here."|10|0|private|Moving your operator overload above the place where it's used might solve this error directly, but note that directly printing an Iterator is not the proper way to print the data it's pointing to. An iterator should act like a pointer. How do you print something a pointer points to, say the value pointed at by `ptr`? You would print something an iterator points to with exactly the same syntax.||0
l0yg63izyfy46w|Confused about iterators|I'm confused about whether I'm understanding iterators correctly, is this correct?.  |11|0|private|It seems that you are on the right track of trying to change i->node_ptr's previous and next to point at each other. Was there a specific issue you weren't understanding?You can also test your implementation using List_compile_check or your own tests.||1
l0yg3rcdj7y51t|Operator test|Are we supposed to write tests for operator*, operator++, operator==, operator!= in the List_test.cpp?|116|1|active|Yes, it is a good idea to test your implementation of the operators in List_tests.cpp.||0
l0yfey1nlapxy|Past SI Project walkthrough material and Honor Code|I came across a past SI video that is publicly posted online, (https://www.youtube.com/watch?v=tcy5ibYZb74); it's long and probably gonna be very detailed (I haven't watched the whole thing yet just jumped around to see what topics are covered in this video). I'm wondering if it would be okay to reference something like this video (it seems like the video is specific to 280 but from last term) or anything outside of this term would be considered Honor code? |116|2|active|Video is fine to use.||0
l0yf7k8ncgb5pd|compiler test question|Why are lines 54 and 55 supposed to be true?. |94|0|active|`iter3` is set to be the end iterator at lines 43 and 44, so the statement `iter3 != my_list.end()` will be false||0
l0yev3gtv20sv|Error: List.h includes a disallowed library: &#39;list&#39;|"We're experiencing this error. When we remove the ""#include <list>"", we experience another error. ""./List.h:196:3: error: no template named 'list' in namespace 'std'; did you mean 'List'?  std::list<Student> queue;"". So we are unsure how to fix this error, specifically because the #include<list> was already implemented in the starter code. . Any help would be appreciated!!.  . "|85|0|active|For anyone coming back to this post, you should not include json.hpp in any of your List files (List.h or List_tests.cpp). That file includes libraries that are disallowed on the List portion of the project ||0
l0ye20815oh2z8|unknown segmentation fault|hi! my partner and I are currently doing project 4 and are having an issue with segmentation faults. The debugger says it is happening in pop_back() with our line last->next = nullptr. Are we not allowed to set this to nullptr?  We've been trying to run through our code and cannot figure out why this section is segfaulting. I made a submission on autograder, could someone look over it to see if we are making a crtitical error? my uniqname is bkrebs, thank you!!!|10|0|private|"The first line after ""Invalid read of size 8"" in your Valgrind output points to line 251, `last = last->prev`. The only access of dynamic memory here is dereferencing `last`, so `last` is not pointing to the right place. Following the Valgrind output's stack trace (hint: it's really useful), we see that `pop_back()` is being called during the execution of `~List`, i.e., when you are deconstructing a List. Since the call to `pop_back()` is inside `while (!empty())`, you know that `empty()` must be false, which means `first != nullptr`. Also, notice that the last line of the first paragraph in Valgrind's output says ""address 0x8 is not stack'd, [...]"", suggesting that the program was trying to access something at address 0x8. You can conclude here that somehow, `first != nullptr`, but `last == 0x8`. I suggest stepping through the code populating the list prior to the spot where the error occurs (in `test_assignment_operator`) in a debugger, paying close attention to how `last` becomes 0x8. That would give you clues to the root cause.. . (hint: a pointer is 8 bytes in size on modern (64-bit) systems, so `last == 0x8` is the result of incrementing a `nullptr`.)"||0
l0yc7hfowly3kv|first node prev pointer|What should the prev pointer of the first node point to? What should the next pointer of the last node point to?|101|2|active|pretty sure nullptr||0
l0ybn3m7itc5wp|prev next ordering|is i.node_ptr->prev->next the same as i.node_ptr->next->prev ? If they're different, why would you use one over the other?|83|0|active|Ideally, both would be pointing to i.node_ptr. However, you can accidently break the linked list by setting one of them to a different node.For example, in the image below,(1) would be the normal case for linked list. (2) would be a problem if we set i.node_ptr->prev->next to a different node instead of i.node_ptr||0
l0y9k8xxy2l2c5|Compiler Error overloaded functions|. . . The compiler is throwing errors because of the non-const vs. const lhs and rhs. I am not quite sure what these errors mean or where I have gone wrong.. |131|0|active|"The compiler's hint is most clear here: _""1st argument (`const List::Iterator`) would lose const qualifier""_. It's saying that if we were to actually call that `operator==` function, the ""argument"" being passed in---the right-hand side of your `==` clause, `my_list.end()` in this case---would have to lose its `const`-ness. Your `operator==` doesn't promise not to change the right-hand side, but since `my_list.end()` is const, the compiler is supposed to require that promise, so the requirement is not fulfilled here and leads to such an error. You can safely promise that you won't change `rhs`, right? How would you do that?"||0
l0y9gk79flk7mv|index.css|When I downloaded the starter files, I got this css file called index.css included with everything else in my files but the spec didn't include this in the downloading the files section, should I be concerned?|64|0|active|The css file is used to work together with the driver program to create the webpage. However, we're not writing the driver program this term. So I don't think it would be a problem.||0
l0y9eeg1jp62fu|About comparing two lists in our test cases|I tried to compare two lists by ASSERT_EQUAL(l1, l2), and I realized that we didn't define the == and != operator in our list interface. Since we are not allowed to change the public interface (although I am not sure if overloading an operator counts as changing the interface), should I write the helper function in the test instead?|70|0|active|Yes, using a helper function in your tests would be fine.||0
l0y82xpeet05hk|Copy Constructor Initialization|How do I correctly implement the function header for the copy constructor when I define this function outside of its declaration/the class?. . |143|0|active|"Check the line with the errors more closely---dissect it into the parts of a function signature and check that each part is expressed exactly as intended, as the compiler doesn't tend to give clear errors if you make a mistake here. For `List::operator=`, you'll want `List&` as the return type (no `typename` required---see @4568 for why), the function `operator=` _inside `List`_ as the function name, and what you have right now as the parameter list. In the screenshot, your return type seems to refer to some type `List` declared _inside_ a `List` class, which does not exist. Because the compiler sees that `operator=` doesn't belong to a class (it does---you just need to express that), it expects two parameters (""be a binary operator"")."||0
l0y7szx2bb5563|Reason behind adding function stubs?|What is the added benefit of copying the function stubs outside of the class definition and implementing them there?. . |129|1|active|"For one, this separates interface from implementation. Write a class declaration with only declarations of member functions, not definitions, and someone can take a glance at it and see from all these declarations (and comments! You wrote comments, right?) how to use this class, without being bothered by the distracting details of the class's inner workings.. . You can go one step farther. Move the member function definitions to a different file—a different translation unit—and you can compile them separately. Now if you want to change code that uses this class (and therefore includes the header that declares this class), you no longer have to recompile all these member function definitions! The translation unit you changed contains only their declarations—only the minimum amount of information the compiler needs to be able to compile uses of these functions properly—and any calls to these functions can be later linked to the object file containing their definitions that was produced by compiling these definitions separately.. . Here's a more concrete example, in the form of a hypothetical terminal session:. . $ ls. Foo.cpp Foo.hpp Main.cpp. $ cat Foo.hpp. struct Foo {.     // prints ""Hello, world!"".     void bar() const;. };. $ cat Foo.cpp. #include <iostream>. . void Foo::bar() const {.     std::cout << ""Hello, world!"" << std::endl;. }. $ cat Main.cpp. #include ""Foo.hpp"". . int main() {.     Foo const foo {};.     foo.bar();.     return 0;. }. $ g++ -c Foo.cpp    # -c means compile only and don't link, producing a object (.o) file. $ rm Foo.cpp        # For demonstration, delete the code that was just compiled :). $ ls                # Foo.o contains a compiled definition of Foo::bar. Foo.hpp Foo.o Main.cpp. $ g++ -c Main.cpp. $ g++ -o say-hi Main.o Foo.o    # Links both object files together to produce an executable named say-hi. $ ./say-hi. Hello, world!. $ rm Main.o say-hi    # Okay, let's now change how this class is used.. $ ls. Foo.hpp Foo.o Main.cpp. $ vim Main.cpp        # Make some edits, resulting in:. $ cat Main.cpp. #include ""Foo.hpp"". . int main() {.     Foo const foo {};.     foo.bar();.     foo.bar();.     return 0;. }. $ g++ -c Main.cpp. $ g++ -o say-hi Main.o Foo.o. $ ./say-hi. Hello, world!. Hello, world!. . Notice how the definition of this member function was only ever compiled once before we deleted its code. We were free to change all other parts of the program, as long as Foo.o still contains a compiled implementation of the interface declared in its associated header Foo.hpp, and only the parts that were changed (and the headers they included) had to be recompiled. Now imagine a much larger project that takes minutes to compile in entirety, or even hours—there's some serious benefit to be gained by limiting what has to be recompiled after a small local change."||0
l0y7afktplj1o2|bus error for either push_front() or front()|"I'm getting a ""bus error"" in my terminal when running my test for the front() function which uses both push_front() and front(), but I'm not sure what the issue is. I've attached my code for the functions to for reference.. . Screen_Shot_2022-03-19_at_2.43.18_PM.png"|8|0|private|"A ""bus error"" usually indicates bad memory access. Xcode run configurations usually attach its debugger by default and suspend the program at the instant it runs into such an error. If you do so (or alternatively, enable the address sanitizer or use Valgrind), can you find where exactly the bad memory access occurs?"||0
l0y7077qrd373z|Does &#34;i is a valid iterator associated with this list&#34; mean the list is empty?||123|0|active|"""i is a valid iterator associated with this list"" is more saying that i must be point to one of the elements of the list. Iterators can point to elements in a list sort of like how pointers can point to elements of a vector. So the list is not necessarily empty, in fact the list should never be empty (do you know why?) . . EDIT: The last sentence in this response is slightly off since there is a scenario where the list may be empty. As per the followups, an iterator pointing to List::end in an empty list is a valid iterator."||1
l0y6txd2ik777b|push_back debugger error|. . my debugger encounters an issue when I try to run List_compile_check, for some reason line 24 makes the issue happen. The debugger message is given in the first image. I used the code from the lecture, so I don't know what's going on, any help would be appreciated. |17|0|private|Making your code public on Piazza is against the Honor Code.  . As your IDE showed, when `last->next = p;` get executed, your `last` node is `nullptr`. This may suggest that before you call the function `push_back()`, your list may not be in a good status (when your list is not empty, your last node is somehow ```nullptr```, i.e., not corrected set).||0
l0y6o8jfvo72fw|Issues with pop_front() and pop_back()|I'm having some trouble with the pop_front() and pop_back() functions. I wrote my pop_back as a sort of mirror image of pop_front() (i.e. I'm creating a new victim and setting last to the previous node of victim) but I get a segmentation fault for some reason. . . Also... how should these functions work when there's only 1 node in the list?|159|1|active|Segmentation fault can happen for a number of reasons, for example I believe a double delete might cause a seg fault. I suggest tracking very carefully which Node* is pointing to what in your list and making sure it's doing what you want it to for whatever test case is causing the seg fault. The debugger or scratch paper might help with this process.. . If there's only 1 node in the list, both pop_front() and pop_back() should remove this node and set head and last to nullptr||0
l0y5g4687w91bq|Project , empty and size|"Do we have to make a private member variable for size for the LIst because I dont think there is one for the List in ""List.h"".  Also, do we have to make a constrcutor for the list."|178|0|active|I think we have to make a member variable that keeps track of the size. And yes, List needs a default constructor and a copy constructor.. . See @4570||0
l0y4wvgvq0w144|compiler error|Screen_Shot_2022-03-19_at_1.35.03_PM.png. . I keep getting these errors in the compile check file and I'm not sure why (i think I have a clue as to why but I want to just make sure), if anyone is able to help that would be great. Thank you!|74|0|active|Like the student followup mentioned, you'll have to overload most of the operators in the Iterator class. You can refer to lecture slides or project3 for specific syntax.||1
l0y3tb9xgnf1fn|clear() vs pop_all()|Is there a difference between the clear() function that has its header in the starter code and the pop_all() function that is implemented in the lecture slides?|102|0|active|Not really, they both have the same end goal of removing all elements from a linked list. The implementation **might** differ slightly depending on what functions/variables you have available to you.||0
l0y1nhalh3i1ys|project 4|I am facing the problem in Iterator begin() const . . No matching conversion for functional-style cast from 'List<int>::Node' to 'List<int>::Iterator'. . Can anyone tell me why?|135|0|active|It might be that your `begin` function is returning a `Node` object instead of an `Iterator`. ||0
l0xybizfvyo7ei|Project 4|I have downloaded all the starter files for project 4 and looked at the specs but I am very confused on where to start?|169|1|active|The required part of the project is implementing List.h. Specifically, implementing all of the public member functions of the list and iterator class. There’s info about what each function should do in the RME of each function. After you’ve finished List.h, if you’d like you can implement api.cpp. Info about api.cpp can be found in the spec for project 4.||1
l0xcua17xvw5k3|Error in pop_front|I'm getting this error when I delete my victim node in the pop front function. It happens after all my code is finished running so I'm not really sure where the error is. Does anyone know what I should do?. . Screen_Shot_2022-03-19_at_12.29.21_AM.png|217|0|active|It looks like a double delete problem. And given that it appears after the program execution, I suspect that it has something to do with your destructor of the list. But without further detail, I can't guarantee that. ||2
l0xaol0025g131|Why thing goes wrong?|I use the debugger to check this function and the previous function. But I really do not know why there is an error|20|0|private|I think posting your code on Piazza like that  is against the Honor Code... ||1
l0x9s0sxa6n38u|&#34;List Private Templating Test&#34; on Autograder|"I was just wondering what exactly ""List Private Templating Test"" will be testing for, it is on the autograder so I was wondering."|161|0|active|@4560||0
l0x9qmpdc297bp|When to include  versus when not to|"When should I use List versus List<T>? In other words, there are times when I will need to put List in the return type, as a parameter, etc, what are some good general guidelines for when I should include the bracketed T? For example, if I am writing the function implementations inside versus outside of the class declaration. Whether ""List"" shows up in the return type, as a parameter, etc. General guidelines on these cases and even other cases you think we should know about would be very helpful as I don't seem to fully get when I need to include the <T> and when I do not. For example, in this screenshot from lecture, in the third example, what happens if the <T> is omitted altogether?  Screen_Shot_2022-03-18_at_11.09.16_PM.png. . Thanks and hopefully my question makes sense."|120|0|active|"you should include <T> if you're writing something within a templated function/class. For instance, if you write your List functions outside of the class, they'll need to be templated and written like: . . template <typename T>. void List<T>::pop_back() {. .... }. In the screenshot you included, the <T> will just be filled in with whatever the programmer specifies when using this function (e.g. func<int>()). In this case the <T> isn't ""necessary"", this was just an example to show when the typename keyword is used"||0
l0x9h6yrro61jj|List test|I only wrote the test case for list<int>. I wonder do I need some other kinds of list for the test such as double, char, string, etc. Or are they generally the same? What else would you recommend me to consider for the test?|104|0|active|You'll be fine if you only test with List<int>. If it works with integers, it should work with any other type||0
l0x9chzf3k24f7|iterator function problem|"I keep getting this error in my compiler for List.h . ""Calling a private constructor of class 'List<int>::Iterator"".. . If anyone could tell me the reason why that would be of great help, thank you!"|133|0|active|make list a friend class of the iterator class||0
l0x99cdczbb5qj|git help|Hi, I'm not sure how to commit to my git repository? I have the starter files open in my IDE. |9|0|private|Looks like you have to create a local repository in your project folder. git init should do the trick--from there, you can use git add . to stage the starter files, and git commit to commit to your local repo. Not sure if you connected your local repo to a remote repo on GitHub/GitLab yet, but you can refer to the setup tutorial if you need assistance with that. Hope this helps!||0
l0x91vtsjj350b|iterator insert function expected behavior|"hi! what is the expected behavior of the insert function when the iterator is pointing at list.end()? the end() function is supposed to point ""just past"" the last node, so to a nullptr, right? is calling insert with an iterator that points ""just past the end""/to a nullptr supposed to insert that datum at the end of a list? "|167|1|active|that is correct! If the Iterator is an end iterator, then the insert function should add the datum at the end||0
l0x7i6jqq393jr|List erase function|For the erase function, what happens if the iterator's node ptr is end() (a nullptr)? Do I just go ahead and remove the last element? Also, what if the list is empty? There is no requires clause that says the list can not be empty, and it doesn't make sense to remove something from an empty list.|235|1|active|the Iterator that is passed in has to be dereferenceable, which is mentioned in the requires clause. An end Iterator under the hood is a null pointer, which is not dereferenceable--hope this helps!. ||0
l0x6yo6hqw94oc|Autograder test case submission problem|As I just submitted my code to autograder, it says that I have no test cases submitted. But I've checked that I submitted the correct file, and it compiles on CAEN and runs just fine.. . Here's the feedback from autograder:. |108|0|active|Marking as resolved||0
l0x6rciffoq21w|Clarification|I am a little confused on what this step of the List_compile_check is supposed to be doing. Is it assigning the front and back to 73? and if so is it supposed to write over the current values at the front and back?Screen_Shot_2022-03-18_at_9.40.47_PM.png|100|0|active|yup, these lines will change the two nodes in the list to have a value of 73||0
l0x5zdhtefi2l3|Read access violation|I am getting a read access violation in this portion of my code when I am utilizing the copy constructor on line 32 of the list compile check. My push_back function is not working on the second round of copy all. I get this error and I am not sure why it isn't working. Does anyone have any ideas?. |27|0|private|@4418 Does initializing your new Node using the last FAQ tip help?||0
l0x55ek713o6j3|return by reference nullptr|In the front function, if the list is empty, what should you return by reference because you can't just return *first since its a nullptr...|65|0|active|requires clause says list is not empty ||0
l0x4t2m0u8120n|When do we use assert statements?|"Do we use assert statements in our functions to assert the requires clause? I recall that we were not supposed to do this/didn't need to, but in the Iterators lecture I am seeing the assert statements used ""assert(node_ptr)"".. . What is considered the best practice?"|150|0|active|To see how these `assert` statement are useful, suppose you don't have them. Somewhere in your testing, you run into a segmentation fault. There are several ways to approach such an error---address sanitizer, Valgrind, debuggers, etc.---but they all take extra detective work for you to figure out where the segfault occurred and why. However, if you had such `assert` statements for the Requires clause, the error when it is violated points you directly to the line where the clause got violated, so you know the source of an upcoming segmentation fault right away and can focus on fixing it. In short, `assert` statements for Requires conditions gives better errors and potentially saves you debugging time.||1
l0x4a8um7j44h7|Why does this error occur?|"Hello! My code cannot compile because of this, I look at one similar question before, but I definitely set the ""friend class"". I don't know how to solve it. "|10|0|private|The error means the following:. > In the definition of `List::begin()`, you referred to `List::Iterator::Iterator(List::Node*)`, a constructor for `Iterator`, but this constructor is undefined (not implemented).. . To resolve this, implement the `Iterator` constructor.||0
l0x41fwp6is4t5|What Should I do|I'm kinda late to the party, but currently, I'm getting these errors when I do the compile check. I know what these errors mean and how to fix them. So we're supposed to overload operators for the Iterator class? Are there guidelines for what operators we should write or any limits to what we should write? I know in other projects we are not supposed to write functions that would be used in other cpp, but I'm guessing this is not the case here since we are modifying the .h file? (Tbh writing these functions still feel kinda weird, because all this time we are told to implement functions in the .cpp files..). . . . |183|2|active|You are supposed to write overloaded operators for the Iterator class. If you look at the starter code, it tells you to implement *, prefix ++, default constructor, ==, and !=. There's lots of good info in the Iterator section of the course notes on how to write these ||0
l0x3kmzhotx45k|Function stub for Iterator|Hello,. Happy Friday! I'm trying to do the function stubs for the iterator and was referring to the lecture notes but I'm still confused on what exactly to do.. |7|0|private|The two functions shown in your screenshot are actually List functions that return iterators. So if you want to write the functions outside of the class, it should look something like: typename List<T>::Iterator List<T>::end() const. Breaking this down, we see that the return type is List<T>::Iterator and we need the typename keyword since List<T> depends on the template parameter, and because we are writing this function outside the class, we must use the scope resolution operator (e.g. List<T>::end()). Also, the begin function is implemented for you so you don't need to worry about that. ||0
l0x39a9t8q15rm|Error Clarification|I got this error from the autograder and I am not sure what to make of it. If anyone could clarify this that would be great. Screen_Shot_2022-03-18_at_8.03.33_PM.png|123|0|active|"The error (slightly simplified) is: passing ""const Iterator"" as ""this"" discards qualifiers in a call to `operator==` and in a call to `operator!=`.. . The only qualifier involved here is ""const"", of ""const Iterator"". Why is ""const"" being discarded? `iter3 == my_list.end()` here means `iter3.operator==(my_list.end())`, so we are calling a member function on a ""const Iterator"". Because it's const, the compiler has to make sure that the `operator==` function does not modify it. To ""promise"" that a member function won't modify the instance it operates on (i.e., ""this""), we put ""const"" at the end of its signature, like so:. . bool operator==(const Iterator& other) const { ... }. . Since your definition does not have this final ""const"", the compiler isn't promised that `operator==` won't modify `this`, so the call must ""discard"" the ""const"" qualifier of the type ""const Iterator"".. . TL;DR: Add that `const`."||0
l0x0xqpg5wb7f4|Resolved|Resolved.|63|0|active|Resolved.||0
l0wzwt9j78x5xh|Function Stub for Iterators|How should we add function stubs for the public member function of Iterators? I've tried. . template<typename T>. Iterator List<T>::Iterator::end() const{.   assert (false);. }. But that's wrong.|171|0|active|On Juett's (and probably every other faculty member's) lecture slides, there is an example of a function stub for `List::Iterator::operator++()`:. . ```cpp. template. typename List::Iterator& List::Iterator::operator++() { ... }. ```. . When you're writing a function stub for an implementation separately, remember that the name of the function must reflect where it is declared. `end()` is a member of `List`, so its name & arguments in this function stub would be `List::end()`. In addition, note that `Iterator` is a class declared inside `List`, so to refer to it from a top-level definition, you need to use `typename List::Iterator` as the return type. (see @4568 for why you need `typename` a second time here.)||0
l0wxqjfx5ql50m|Iterator Invalidation|In the erase and insert functions, the iterator will be invalidated. Is this 'okay for the code to do, or do I need to write private members within the iterator class to somehow 'reset' the iterator to something valid after I've used the erase and insert functions? . . What I'm essentially trying to ask is - is it okay to leave the invalid iterator as it is or do I have to account for this invalidation|221|0|active|Leaving the iterators potentially invalidated is fine.||0
l0ww9dcfumw1wc|List insert function|So for the insert function, I know that if the list is empty or the iterator pointer points to the first element I can just use push_front, but what if the iterator node pointer points to a null pointer? Do I just go ahead and push it to the front as well? Or is the pointer only going to be null when the list is empty? Like in the compile check where mylist.begin is a nullptr.|216|0|active|The list being empty is one situation where the iterator's `node_ptr` will be null, but it is not the only situation where this occurs. Try to come up with a situation where a non-empty list has an iterator whose `node_ptr` is a nullptr. (taking a look at the `end()` function may be helpful here...)||1
l0wswev8j944qe|List size member variable|I'm not sure if we need to add a member variable to List to keep track of its size. If we do, is it only relevant in the size() function, or should we use it in other functions as well?|185|0|active|You'll want to make sure your size member variable correctly reflects the size of your list at all times, so you'll probably need to modify it when you add/remove elements from your list!||0
l0wjet37epy4ap|How to properly delete memory in erase()?|I am getting a valgrind error no matter what I do at the end of the erase function. I've tried doing delete i.node_ptr and not deleting anything, and both give me errors (the latter not on CAEN but on autograder). I'm stumped on how to properly delete the node that is being erased if i.node_ptr doesn't work.|216|1|active|"You delete by doing i.node_ptr in the erase function. I looked at your most recent autograder submission and it looks like the valgrind error is coming from the push_front function. I would suggest going through the error message line by line and finding where it is pointing to. Remember that you create a node by saying ""Node *ptr = new Node;"". . Hope this helps!"||1
l0vy09hacc5qv|Partners|I'm looking for a new partner for P4. If I work individually on autograder can I later go add a partner or will I have to work on my own?. . Thank you!|11|0|private|We do not allow partners if you work alone as the deadline approaches. Since the project is due next week, you will need to register with a partner on the AG.||0
l0vtm0h7apw2tf|Question|Hi, I've written the BIG 3 for the lists, and I have been struggling with the Big 3 and the constructors, and I want to make sure if I am on the right track here. Please give me some suggestions if am on the right track, do I need to make any changes or anything like that. Also, For Class Iterator, I'm not sure if we need a destructor and the Copy Constructor, or we don't need any constructor, only the Assignment operator, and the Destructor?. . |11|0|private|it looks like you are on the right track! I really like the constructor and the start of your operator=. For the copy constructor and operator=, though, remember that there is a function you can call that will avoid code duplication!. . For your deconstructor, unfortunately the computer won't be able to traverse through the linked list if you try to just delete first, because first is just a pointer to a node not a pointer to an array. You need to find a way to traverse through the linked list and delete all of the nodes.. . Hope this helps!!||0
l0vrjij2jih36i|List Private Test Compile Check|After submitting our Project 4 to Autograder, we noticed that our program did not compile for the private tests, while everything else worked successfully: . Is there some way of seeing what specific error caused compilation to fail? We aren't really sure whats wrong, since all other tests compiled and worked properly.|402|4|active|"The most common reason for failing to compile with the private tests has to do with the templates and how you use templated type `T` in your List.h. **The TL;DR here is that you should check your List implementation to make sure you're not accidentally using type specific operators on a value of templated type `T`, because doing so can cause a compile error in the private tests.**. . In a little bit more detail: For the compile check / public tests, you've probably only compiled using your List implementation by passing in `int` for the templated type. The issue is that the `int` type has a bunch of pre-defined operators such as ==, !=, , etc., so if you use one of those in your code on a value with templated type `T`, your code will compile just fine for the compile check and public tests. So we might think ""ok, let me compile with a different type, like `char` or `string`"" - the issue is that might still compile fine too, since they have a bunch of pre-defined operators that you may have accidentally used on a type `T` (especially == and != - these are pretty commonly defined, but are not universal/defined by default). See below on what type you'd need to use instead to catch an issue like this.. . For the private tests, we probably compile your List implementation with types that don't have any of these commonly defined operators (again, we don't actually know what the private tests do). So, the compile will fail when using your implementation here because it'll find that it doesn't have that type-specific operator defined that you're accidentally using somewhere in your List.h implementation. (It might seem odd to call a common operator like == a type-specific operation, but we can create our own types i.e. classes and struct that don't have an operator == defined, so its not universal to every possible type). . If you want to find where that accidental type specific operator usage is, and just staring really hard at your code isn't working, I recommend creating a dummy class in List_tests.cpp (I'd remove this once you're done tracking down the issue, so put it somewhere you'll remember it). This class won't have many of the common operators that might get accidentally used, so we can use it to test that our List compiles on our end. If you write a test case where you declare a List where you insert the class name as the templated type, and try to compile your List tests, you should get an error message similar to what you'd see on the autograder.. . . # Complete Sidenote. . The reason we need to do this is kind of interesting and has to do with how templates actually work in C++ - when you compile a program that uses a template, your c++ compiler generates and compiles a bunch of copies of the templated code on an as-needed basis depending on the types you’re using with that template. What that means is you can actually get away with using type specific operations when writing templated code, so long as you only compile programs with types that support those operations. That’s the reason you should test your List implementation with a bunch of different types, including custom class types. But that might seem kind of odd - why let us do type specific operations at all if the templated type is supposed to be this generic type?. . Interestingly other languages, such as Haskell and Java, make a different choice here and handle templating differently - in those languages, you’re forbidden from doing any type specific operations at all and you need to work with the templated type purely generically. This sort of gets into a deeper discussion of ad-hoc polymorphism (what c++ templating is) vs parametric polymorphism"||1
l0vpeuh0q145y|Problem with List_compile_check.cpp|When compiling our code, we are getting the following error from the List_compile_check.cpp:. . |178|0|active|Let's break down the error, or rather the two separate errors that you've gotten that both deal with `operator==`: . . For the first error, its having trouble with the following situation:. ```. b = iter3 == my_list.end(). ```. Because it can't apply your defined `operator==` - its specifically trying to call `iter3.operator==(my_list.end())`. The specific reason is because you've defined it to take in a non-const reference, and its passing in the Iterator returned from `my_list.end()`. You should treat this returned Iterator like an anonymous value, because we haven't given it a name yet (we haven't assigned it to a variable, so its just kind of this temporary thing floating around that we haven't bound a reference to). C++ doesn't allow you to declare non-const references to these anonymous values (because I guess it doesn't want you modifying them until they're properly bound to a variable). But it does let you declare const references to them!. . For the second error, its a little more intuitive what the issue is. This time, we've flipped the operands to `operator==` with the following line its having an issue with:. ```. b = my_list.end() == iter3;. ```. So its basically trying to call `my_list.end().operator==(iter3)` - note that iter3 is declared as a `const List::Iterator` in this file, so can you spot the issue with trying to pass it into your defined operator==?||1
l0vp9zvnexw5t2|P4 Autograder - api.cpp|To my understanding, the api.cpp (driver) part of P4 is entirely optional. However, why is api.cpp required as a file to submit on the autograder? Furthermore, when I actually submit to the autograder, why is api.cpp being graded for points??. . |162|3|active|Looks like we had the wrong one published. It should be fixed now. The autograder will only grade the List.h and List_tests.cpp files.||1
l0voj2mj4xd3bm|Visual Studio not showing compile time errors|"For some reason, my visual studio has just stopped showing any compile time errors in my list.h file. I am not exactly sure why or how to restore them. Is there a setting I have to change to fix this issue? One observation I made was that the only time I can get the red lines to show up, is if I delete the ""template <Typename T>,"" so perhaps it has something to do with that, but I am not entirely sure. For reference, I am using the 2019 version of Visual Studio. "|154|0|active|Technically, if your template is never expanded. That is not an error at all. Consider this example,. . ```c++. template . T foo(T in) {.     return in + 1;. }. ```. Can you say this line is wrong before the compiler expands this template, before the type deduction happens?. . Thus, C++ always believes if you never use that function, that template function can never be wrong. There is nothing to do with IDE or any tools. That is how C++ is designed, and how template works.. . If you have seen python before(in 183 or somewhere else). You should know that Python has the same behavior, but due to other reasons. Also in JavaScript.. . The only way to test it is to use a C++ static analysis tool. As the instructor mentioned, the best way is to use that function somwhere, like in `main`.||1
l0vo1ab14bi218|Xcode error|Does anyone know what this error means?. Screen_Shot_2022-03-17_at_8.09.22_PM.png|111|0|active|Looks like an issue with the `List::Iterator`'s private constructor. This constructor is private, but note that we're using it from `List::begin()` - this isn't a bug or error in the starter code. How can we let List use this constructor/other private info from its Iterator class, while still keeping all of that private?||0
l0vmafkiu613rm|Test for list|From my understanding, iterator is used so that we can work with the elements in the list easier and we can use them to write test cases. Do we have to actually write tests for the iterators as I assumed that they are used for testing the list functions? Thank you. |118|0|active|Iterators are implemented to provide a way to traverse lists easily. In general, ADTs have iterators so there is a uniform way to traverse any ADT by creating an iterator for that particular ADT.. . It's up to you whether or not you want to explicitly test Iterator. If you are using iterators in your other test cases, this might be sufficient. However, it might be a good idea to explicitly test all of the operations that Iterators support if they aren't being used in your other test cases.||0
l0vfdrjb21tk|==, != and * overload question|I understand overloading ++ and --, but I have a question about ==, != and * overloads. With regard to the == and !=, how does do I access the nodes to compare if no parameters are passed? In other projects I have used operator==(lhs, rhs) as a function, but List_compile_check.cpp just uses == as you would if you were comparing two ints. . . I am also a little confused about the purpose of overloading the dereference operator (*). What exactly do we want this to return, the node_ptr member within the node struct? I tried doing this but I am having some trouble and would appreciate some clarification. Thank you.|179|0|active|Keep in mind that `operator==(n1, n2)` is **exactly equivalent** to `n1 == n2`---the `operator` notation exists primarily for operator overloading syntax. Therefore, when you see `iter1 == iter2` on line 44 in `List_compile_check.cpp`, it really just means `operator==(iter1, iter2)`. If you overload this operator, that comparison will compile and call your overloaded implementation.. . The students' answer is correct for `Iterator::operator*`. For instance, if a `List x` has `{4, 2, 7}`, `*(x.begin())` should return a reference to the `int` 4.||1
l0veqfijbho1qe|Iterator|. I tried to implement the *function, but the error shows here. But I follow the way how --function implemented.  Then I tried to implement it in the below of h file like Template <typename T>, but still got bugs. How do I fix it?|10|0|private|What this error is saying is that the type you are returning does not match the return type of the function (so one of them is wrong)||1
l0vcprign704jd|Project 4 List.h not registering|Does anyone know how to make functions show up as colors again on XCode in List.h.? Mine is still running and showing errors, but it's acting like my compile sources are wrong even. Right now I have List.h and List_tests.cpp. The asserts should be a color. . . Resolved I just had to retype the assert statements for them to change color.|143|0|active|Resolved! It looks like retyping the assert statements fixed it. For anyone else having this issue, it should be enough to just have `List_tests.cpp` or `List_compile_check.cpp` in your compile sources (you don't/shouldn't need `List.h`)||0
l0vaa0azwgv6mf|Compiler giving me an error about the operators I implemented|So I've been working on the erase function for the list and I'm getting this compiler error about not being able to increment Iterators when I already implemented the operator ++ function (and -- was provided in the starter code).. . . (my implementation is outside the class).|188|1|active|There are actually two operator overloads for ++/--, because you can do both post-fix and pre-fix operations with them! In this case, we're overloading the pre-increment and pre-decrement operators, so you should move the ++ and -- before i like `++i` and `--i`.. . See here for the syntax for overloading the post-fix operator!: https://stackoverflow.com/questions/15244094/overloading-for-both-pre-and-post-increment - note, you don't/shouldn't need to do this for p4, its enough to just move the ++/-- to the pre-fix spot||0
l0v9feu3ydv3um|Project 4 not on Autograder|Project 4 isn't on my autograder, is this a mistake?. |149|0|active|We haven't opened the autograder for P4 yet.. . @4543||0
l0v5qowsvfd66a|List_tests|Could anyone lead me in the right direction on how to write the test cases for functions like push_front push_back, pop_front, and pop_back if they all return void?|147|0|active|They will all return void, but then you can use functions like front() and back() to test if the elements in the list are the elements that are supposed to be there||0
l0v4k2dazki3j2|Error with push_front and push_back|I'm having an error with not being able to set the next and prev pointers in these functions, I'm not too sure how to handle it since it doesn't seem to ever switch from the nullpointer.  Any suggestions?|157|0|active|I cannot provide more detailed suggestions without checking your code. However, it is very likely that when you try to use node->next() or node->prev(), the next node is nullptr. You need to consider extra things you need to do when the list is completely empty.||1
l0ufm0xazx5sm|P4 Autograder|When will the autogravder open for P4?|175|0|active|We're expecting to open it before friday (that is, sometime on thursday)||0
l0ufcfhnd4m5s|Iterator|Where in the .h would the commands for iterator be written. Can I/ should I write them within the Public member or can I put them down below with the rest of the list functions after declaring them as friends?|149|0|active|You can put them below, but remember to put their full scope: . . auto Inner::Outer::foo() -> void{}||0
l0uemvnrwk65qk|API Question|Is the entire api.cpp optional, or do we need to make the code work with the compiler, and not worry about it working as an actual website?|144|0|active|It is entirely optional.||0
l0ubmt5ds5u6y0|push_front()|I believe my push_front() implementation is buggy. When I initialize an empty list of integers, push_front() 1, and call back(), my test case fails. However, I can't really figure out what the problem with my function is.. .     void push_front(const T &datum) {.         Node *p = new Node;.         p->datum = datum;.         p->next = first;.         first = p;.         list_size++;.     }. . What am I missing here?|8|0|private|What happens if you try to perform `push_front` into an empty `List`? And additionally, since this is a doubly-linked list, what about the variable `prev`? Make sure to consider the different cases when you are trying to implement and test your list.||0
l0uamoz5fq17gl|spec of p4|I saw that most part of the spec is about driver, while we don't need to do it before ddl. What part of the spec is about list.h that we should submit to the autograder?|203|0|active|The “Linked list Specificaiton”, “Requirements  and Restrictions”, and “Appendix C” sections are all relevant to the required part of project 4. There’s also a lot of info in the List.h file itself. ||1
l0ua4t91xrh1iq|test case|I'm wondering if my implementation is incorrect, or my test case is incorrect. If I create an empty list of integers, and push 1 to the front, will front() of this list return 1?|164|0|active|I think so. I used something similar in my test case as well (different numbers of course)||1
l0u9uy9dxdu4u3|Question about List.h|. What does it mean exactly in the List.h?. . //MODIFIES: may invalidate other list iterators. |161|0|active|A lot of the functions that use that `MODIFIES` clause involve some direct manipulation of the elements in a `List` or of an `Iterator`, whether adding or removing an element. Doing so may make an iterator that pointed to an element in the list invalid. . . Consider this: Say I had an iterator for the front of a list. If I then run `pop_front()`, will that iterator still be valid?||1
l0u80nwza556l4|List.clear()|I'm trying to implement a clear and to an extent I feel as though that should be as simple as executing multiple pop_fronts or pop_backs till you reach the end of the list but I don't fully understand why this isn't working atm.|132|0|active|You have the right idea, you might have a bug in one of those functions if it's not working ||0
l0u7nlz5fjx4db|Do not change the public interface of list?|Does it simply mean that I can't break the interface, or that I can't define the functions where they've been declared. What i'm essentially asking is if I can implement the functions right where they've been declared or if I have to do it below the comments at the bottom of the list.h file|190|0|active|you can implement the functions where they are declared inside the actual class. The comment at the very bottom says so as well||1
l0u4xa8ldsf3zk|Prev for first element of list|What should prev point to for the first element in the list? Can I make it a nullptr?|91|0|active|Yes - you should make the prev pointer for the first element a nullptr. ||0
l0u2lu2xrpz3zm|push_back() segmentation fault|"Hello, I'm in the process of testing my push_back() for project 4; I'm currently getting a strange segmentation fault error whenever I call push_back() on an empty list. I've attached a screenshot with the last few lines omitted. The line ""first = ptr;"" causes this error, but I'm not sure why. Any ideas or advice would be greatly appreciated. Thanks!. . "|6|0|private|Thank you, the issue is now fixed! I accidentally was dereferencing first while it was null in the dtor (when calling pop_front() with size = 1 and using first->prev = nullptr; at the end instead of using an if statement to check first isn't null)||0
l0u0lspsz9y5l9|Concern Regarding Project 4|Hello, I am aware that from EECS 203, I have both homework due tomorrow and a midterm next Wednesday, I am afraid that I cannot make it work by both doing homework, submitting a project, and preparing an exam within the same week. I am freaking out that I won't be able to pass the class with this much of a condensed workload, I sent an extension request, but get declined. May I know if there is an alternate option for me in order to let me pass the class?|9|0|private|Unfortunately, it would not be fair to everyone to give extensions when students have a heavy workload.. . What I will say is that you have 10 days to complete project 4, and since this project is not as long as project 3, you can probably finish it on time if you work a little bit every day.||0
l0u07w5ke535r1|Question about List|It says that we are not allowed to modify the public interface of List class. Are we allowed to add customized constructor for List class?|259|1|active|You can create private constructors.||1
l0u02iq3dcq18u|Project 4 implementations|It seems like a decent amount of the implementations in list.h (such as push_front, empty(), pop_back()) are implemented in the lecture slides, are we allowed to use the code in lecture slides in our project?|163|0|active|Yes||0
l0tzuv1zozy2qs|proj 4 size|For proj4, are we able to create a private variable to represent size of the list?|176|0|active|that sounds like a good idea||0
l0tzkm1z1ym3iw|Question about typename keyword|". We do not need to add ""typename"" keyword at the front of T & List<T>::front() or not?. . "|151|0|active|You do not need `List.cpp` In this project, everything goes in `List.h`.. . And the answer to your question is No. You dont need that `typename T` in `List`. But you do need that in `template`.||1
l0tzex8lr123zn|Question for Project4|Just a check. We are not required to implement this part of project right?. |124|0|active|It's not required, but I HIGHLY recommend it because you will learn a lot from it.||0
l0tyidjttqx4bl|reusing code written in a past semester from a partnered project|Hi, I was wondering if I could reuse code that I've written last semester from a project that I partnered on (I'm working alone on the same project this semester). I read the policy on the syllabus regarding reusing your own code from past terms but it wasn't explicit on if it is allowed if the code was from a previously partnered project.|13|0|private|"From the syllabus on Project Partnerships: ""If you choose to work alone, you are free to reuse your own code from a previous term."". . You can also reuse your code if you are in a partnership, but we encourage starting together from scratch if you go that route."||0
l0tsjyb0r9b152|Honor Code|Copying code from lecture slides would not result in an honor code violation, correct?|230|0|active|This is correct! Anything that we give you is fine :)||0
l0tq93m3glc2dt|Iterator constructor uses a private member variable of the list class|. . . As the images say, the iterator constructor is calling a parameter from the private section of the list class– am I missing something?|168|0|active|Did you check `friend` part in the lecture notes?. . ||1
l0sw895sm7v6l8|P4 error|I'm making function stubs and getting this error when I tried to make the stub for the == and != operators. How can I fix this?. . |10|0|private|I believe the error is telling you that it's expecting only one argument and you're sending it two. So for instance: Iterator& operator==(List &lhs, List&rhs) is receiving two parameters but should only be receiving one. . . Additionally, I would recommend reconsidering the parameter types of the two functions that are being highlighted here. These functions should overload the != and == operator. As of now the return types are Iterators but the parameters are of type List. Think about how != and == typically work||0
l0srpjo7a7v1ok|Autograder not opening|Does anyone get this message when they open the autograder?. . . I am logged into my michigan account, so permission is not an issue. |227|0|active|I just tried opening the autograder and it works fine. Are you trying to open a project that hasn't been released yet?Project 4 autograder has not been opened yet.||1
l0srb1ebf3n1io|Confused about push_back with Lists (project 4)|"Hi,. . Just to preface, I am using the list class as I have not started implementing my own List class yet.. . So I just started project 4, and although I assume that I am probably doing some things incorrectly, I have encountered an issue with my code that I can't quite figure out. As I have programmed it, when a POST /api/queue/head/ command comes in, the input is parsed and then sent a member function of the OHQueue class called ""push_back(json input)"", which itself creates a student object and then runs queue.push_back(student). However, it seems like after the OHQueue push_back() function runs, the queue list erases itself. Within the OHQeue push_back() function, I wrote a cout statement before and after running queue.push_back(student) that prints the size of the queue using list::size(), which shows that each time I run the function the length of queue always starts at zero, but does increase to 1 after running queue.push_back().. . There could be another bug in my code, but before messing around debugging, am I missing something? Am I not able to do queue.push_back() in that scope for some reason?. My constructor for the OHQueue is empty, could it be an issue with the way I create/initialize the OHQueue object?. . There could always be something that I've missed in the project specs, so if there are any particular sections I need to re-read regarding this, I'd appreciate it.. . "|13|0|private|When you push back to a linked list, the queue should not restart and build back up again. Instead, it just appends one item to the end of the list. ||0
l0sqhzb5myy3|partner search|if anyone is searching for a partner for project 4 feel free to email bt21w777@gmail.com or comment your uniqe name and I can reach out. |223|0|active|If you are looking for a partner, @5 would be the place to go. (and it looks like there are already several ongoing searches for p4 so I'm sure you can find someone there :))||0
l0smtd0wlpu2wk|Project 4 Lectures|How many of the lectures will be needed to complete Project 4?|230|4|active|"It says ""Lectures 16 (linked lists) and 17 (iterators) are covered on the project."" on the website."||0
l0sftc02fig5dk|Empty list using insert|If the list is empty and we put an iterator at the beginning of the list (pointing to null value), and call insert what is the behavior that we are expecting? Would it insert the value to the front of the list or would the program crash... and if the insertion is valid do we also have the iterator continue to point at null junk or do we move it to point at the new beginning of the list? |244|0|active|In most cases, iterators do not guarantee to be valid after certain modifications of original container. Therefore, in the context you mentioned, the iterator should still point to `nullptr`, and since it is invalid in this case, you should not use it anymore because `++itor` is undefined behavior.. . Since the iterator is created when the list is empty. According to standard, it `list.begin() == list.end()`. Theoretically, you should not use that iterator anymore. But since list does not have past-the-end concept like `std::vector`, the iterator you have is still valid to some degree because you should not dereference `list.end()`.. . Yes, if the list is empty, `push_front` and `push_back` are both allowed. You can play with `std::list` to see its behavior.. . ```c++. int main() {.     list l;.     cout << boolalpha;.     auto begin = l.begin();.     cout << (l.begin() == l.end()) << endl; // True.     // You should not use that iterator anymore.     l.push_front(1);.     // But begin still == l.end().     cout << (begin == l.end()) << endl; // True.     ++begin;.     cout << (begin == l.begin()) << endl;  // True?.     cout << *begin << endl; // 1?.     // Does this make any sense?.     ++begin;.     cout << (begin == l.end()) << endl; // True?. }. ```. [https://en.cppreference.com/w/cpp/container/list/insert](https://en.cppreference.com/w/cpp/container/list/insert)||0
l0r55wrompi53n|P4 and lecture slides|Can we use the lecture slides as reference for the functions in the project files?|128|0|active|Yes! All lecture slide functions are free game||1
l0qzwbygw9d4fg|Project 4 FAQ|"This is the thread for P4 FAQ's.  Reminder P4 is due on Friday, March 25th at 8pm!  Please add your uniqnames on Piazza (the post @6 gives you instructions on how to do so).  This really saves us so much time when helping you whether it be looking up your code on the AG or doing anything exam related.. . Spec is here.. . The p4 intro session is on Wednesday, March 16th from 7-8 PM EST over Zoom. Please see post @4390 for more information..  . FAQ:. . Q: What is a linked list/iterator?. . A: A linked list is another kind of container and an iterator is an object used to traverse and access elements in a container. You can refer to the lecture slides or the class notes (https://eecs280staff.github.io/notes/) if you have any questions..  . Q: Why am I getting an error related to accessing a private member of Iterator in a List function?. . A: By default private members of the nested Iterator class are not accessible to the List class. The solution is friendship! We'll be covering friend declarations in the Iterator lecture. .  . Q: Should I test the destructor/How do I test the destructor?. . A: You should write tests for every function that you can. You're not responsible for testing the destructor in your test cases, but you should use a tool like valgrind to ensure that your code isn't leaking memory. You shouldn't call the destructor explicitly! The compiler does so automatically when the object dies..  . Q: Why am I getting a segfault/undefined behavior?. . A: Valgrind can be a helpful tool for tracking memory related errors. In general, a common cause for segfaults and undefined behavior in this project is uninitialized pointers. Make sure whenever you create a pointer variable (like first, last, or the members of a Node) that it is given a clear value. Valgrind tutorial: https://eecs280staff.github.io/p1-stats/setup_valgrind.html .  . Q: Why does my test case compile on CAEN, but not on the Autograder?. . A: Double check that you haven't added any public functions or made one that was originally declared private, public. Also, double check that you've not put using namespace std in a header file. Also, you can't compare an Iterator with a pointer.. . Q: How do I start api.cpp? What should the program look like?. . A: Be sure to check out the project intro slides here.  They include information that you may find useful when implementing api.cpp.  Think about where you need to take input from, and what different things your program needs to be able to do with it. Then, break your code up into different functions or a class or whatever structure you'd like - just try and keep things organized, and don't just use one giant function.. . Q: On the style check I'm getting a ""memory is allocated but not initialized"" error whenever I create a Node.  But I'm initializing my Node data member variables in the lines directly following.  How do I fix this?. . A:  This occurs because the style checker sees that you create your Node on one line, but is not smart enough to check the following lines to see that you initialize the members of the newly created Node. This can be solved in a few different ways.. . Default constructing your members then initializing them.. . Node* n = new Node{};. n->datum = datum;. .... . Using brace intialization to create the new node.. . Node* n = new Node{next_in, prev_in, datum};. . Creating a default constructor for Node.. . We recommend options 1 or 2, since they are easiest to implement and integrate into your existing code. Option 3 is a little more complex, but good practice.. . Good luck and Happy coding!. "|806|2|active|||0
l0quk905u937e|Project 4 with no previous Python experience|I have not taken any EECS or ENGR classes before 280 and have no experience with Python, but I noticed that there is some in project 4. Do I need to learn anything before beginning, or will I be ok to just start working on it?|186|0|active|You won’t need to code anything in Python for Project 4, only in C++ as you have been doing for the other projects. The server.py file in the project is used for testing purposes. (see here) If you are interested in learning Python, (some classes after you finish 280 and 281 use it, such as Computer Vision and Machine Learning) there are several tutorials and resources online to start learning it!||0
l0qtairdgj73s8|Project 4 Overview Session|. . Hi everyone!. . Staff will be hosting a project 4 overview session this Wednesday, March 16th from 7-8 PM EST over Zoom. We will go through a broad overview of the different components of the project as well as some general tips for getting started/working through it. This session will be recorded with the link posted in this post and on eecs280.org, and here are the slides we will be going through. We hope to see you there!. . . Link to recording:https://umich.zoom.us/rec/share/ZfXQF2-f6rilYG3Zul4gOp8-wIec9a2drMEmbUzKnyjvu4CfFv1A5iuVKmFUppOq.1y10DJ27SO82M153. . |564|1|active|||1
l0q8ivf76eb1gr|Human player|. We did pass the other 2 tests. In test50, it works at the beginning, but later, the names of the players become numbers, and it doesn't print outputs after line 71. What are the possible causes?|146|0|active|Pretty sure you are printing the memory address of the players. Make sure you are properly dereferencing them.||0
l0n7wf95imh6mn|Project 4 requirements|Given that the Project 4 is due in two weeks, can we reasonably assume that it is the same as it was from Fall 2021, and we would only need to implement List.h and List_tests.cpp without api.cpp?|169|1|active|I have heard that api.cpp will be optional this semester.||1
l0n6fem3redqo|Confused about APIs in Web|How do you get the API request into api.cpp? Are you supposed to use cin or using parameters in main? For example, if the request is GET /api/queue/ , how would api.cpp get this string?|137|0|active|For project 4, if you're choosing to do api.cpp, you should read requests from cin: https://eecs280staff.github.io/p4-web/#code-structure (spec from last semester)||0
l0iaa65q1p31d4|Where to Start?|I'm very confused about where to start with this project in general. It seems that there is only a .h file for List but no corresponding .cpp file. Are we supposed to write all the code in the .h file? But I thought we are supposed to only write functions in the .cpp file?. . I watched the lectures on linked lists but so far I keep getting lost. From my understanding, they are basically like vectors but far more complicated? Why do we need to use them for this project?. . P.s I heard from the discord that 281 is doing an among us project. Does this mean I should learn how to play among us during the break? (Yes, ik its a meme and very popular game but I'm not a gamer I just watch anime)|229|0|active|For project 4 in general you are implementing a Linked list and its functions, so basically what you want to do is create a linked list as well as implement the functions to add and remove things from the list, etc. I would recommend for now googling how to implement these functions and you'll probably find some inspiration online.. . And no I don't think it's necessary to do any prep for a class you haven't taken if you don't want to, but learning how to play at any point won't hurt.||3

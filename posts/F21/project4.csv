post_id|subject|content|unique_views|good_question|visibility|i_answer|s_answer|num_followups
kwy8hmb66ar31u|insert Map.h weird error|Very confused why this assertion is failing and could not find an answer anywhere.. . Here is my insert. . find. . return type. . and error output. . edit - the first line of insert should have a != instead of ==, but the error output is still the same.|13|0|private|The assertion is failing in line 285 of BST, so it looks like you are trying to add the same element twice to the tree. ||0
kwl7g7ubrrh11a|Why is P4 out of 119 points on Canvas?||127|11|active|This was a mistake, it looks like it is now fixed though!||0
kwl7dptq6yy785|Project 4 Grading|Hey,. I just checked the grades in Canvas and it says project 4 was out of 119 points while on the autograder it says the total is 73 points. Was this a mistake or was the actual total out of 119 points? Thanks.. . Daniel|9|0|private|This was a mistake, it looks like it is now fixed though!||0
kwl7ccijb41oh|Canvas grade for P4|The canvas grade for p4 was set to be out of 119 instead of the 73 advertised on autograder.|7|0|private|||1
kwl6dku8s91a4|Project 4 Canvas grade|I was wondering why the Canvas P4 grade is out of 119, when he autograder has it out of 73? Thanks|8|0|private|This was a mistake, it looks like it is now fixed though!||0
kwl5zre55jj2ni|Project 4 Canvas Grade Confusion|On Canvas, I noticed that my project 4 grade is listed as a 66/119, even though on autograder I received a 66/73, which is roughly a 90.4%. The class average is also listed as a 63.45/73, and I was wondering if the /119 was a mistake or if there is something else I need to be looking out for. Thanks!|15|0|private|This was a mistake, it looks like it is now fixed though!||2
kwb6pdbwi726wi|min_greater_than|I think I'm a little confused on how this function should be linear recursive (which I read in another Piazza post, should only recursively call the function one time). However, I'm confused because the smallest node that is greater than val can be in either of the subtrees depending on what val is. This makes me think we should call the function two times, one for each subtree. Any tips? I might just not be understanding what this function is supposed to do.|214|0|active|Yes, the min greatest value could be in either of the sub-trees, but because of the sorting invariant, you can eliminate one half of the tree at each step. Think about which branch the value must be in depending on how the current node compares to `val`.||1
kw6hrvd9zz9sr|Project 4 Point Deduction Explanation|Hello!. I lost some points in the private tests for Project 4 and I would like to know why that is the case. Do I have to go to office hours to ask those questions?|92|0|active|The best place to go for this is proffice hours. If you come to IA office hours, we may be able to help you narrow down where things may have gone wrong, but proffice hours will be more helpful.||0
kw2lr4n4jsi258|Undeclared identifier|. can anyone explain why i am getting these errors?|76|0|active|Marking as resolved||2
kw17ulsy2rzio|Question about project 4 grading|Hey there, so for my final grade, one of my submissions with only 10/21 bugs exposed was graded, even though I had various later submissions with 20/21 bugs exposed. They compiled in the private tests and everything, so I'm wondering why one of my lowest public scores is my final grade. Could it perhaps be a valgrind error? Some feedback would be helpful, as I don't know what could've caused this to happen. I didn't really change anything in my list.h code, mostly it was adding new test cases.. . My uniqname is ezecutin.|146|0|active|You scored more on the private test cases in your earlier submission. You seem to have introduced a bug in your later submissions which caused you to fail several of the hidden test cases.||0
kw0yx1dcxl85z9|Score for previous Autograder submissions|Dear instructors,. . My partner and I submitted two separate files to Autograder for project 4. We also wrote separate tests cases. It occurred to us that the Autograder graded the one that we think had more bugs but was the latest submission. . We put our test cases together and tested both submissions. The previous submission passed all the test cases while the graded one failed some of them. Also, the previous submission passed the Valgrind test and the graded one also failed some.. Therefore, we think that either Autograder graded the last submission instead of the best one, which is very unlikely, or we had some significant conceptual error in our previous submission.. Is there any chance that we can know the score of one of our previous submissions, namely the second one?. . Thank you so much!|10|0|private|Your second submission also received a score of 68/73.||0
kw03bstcjrr6m8|Private tests|Hi, I was wondering if I could see my private test score for the second to last submission(the one which received full public test score). I am not seeing if I got a higher score there because I already got full score, but my partner and I would like to know what that submission got.|16|0|private|To see this type of information about autograder submissions, please attend proffice hours.||0
kvzy8g30dfsxo|clarification on project 4 submission grading|Hi, Autograder seems to have used an earlier submission for my partner and I's project 4 grade that had scored 36/42 on the publicly visible tests, as opposed to our last submission that scored 38/42. Is this because the former submission scored higher on private tests and thus had a higher overall score despite scoring lower in publicly visible scores?|10|0|private|Yes, the final score you see is the highest final total score. This means the score you see has the highest overall score (private tests included)||0
kvzvusz8s2j72q|Valgrind Memory Leak - cannot find where a delete would be needed|Hi! We had an extension for p4, and are trying to get this valgrind error resolved. . . . We know this means we have a memory leak, but our deconstructor, clear(), and push_back() seem to work fine in other test cases, even ones concerning our iterator erase. I was wondering if anyone had any suggestions of where else to look to find this leak.. . Thank you in advance!|149|0|active|figured this out, marking as resolved :)||0
kvztre71o6n2w3|help for official testing|Can I know what is the size and empty test and List test erase I ? I want to debug and improve my program. . |147|0|active|Any information about the specific test cases can't be revealed, however if you go to office hours then a faculty member may be able to help you understand where you can improve your code.||0
kvzmghsaklw24r|test cases|how would i test_back to make sure the last/ back() of the list equals a certain value. i cant figure out how to use back() it keeps saying i cant compare to int (ASSERT_EQUAL(my_list.back(), 2))and i cant use --end() (ASSERT_EQUAL(*--my_list.end(), 2)) bc end is nullptr and cannot use -- on null. |9|0|private|resolved||0
kvy5dtzttdo1im|valgrind permission denied|. I cant even use valgrind idk what the issue is. |14|0|private|You do not currently have execution privileges over `List_tests.exe`. To give yourself permission to run the executable, run `chmod u+x List_tests.exe`.||0
kvxawb3rk3zu0|Forgot to remove a debug message|Hi,. . I forgot to remove a single debug message (std::cout << call) on the insert(..) function that's part of List.. . Assuming my insert() function was perfectly implemented minus the debug message, am I going to lose points from the private tests for insert because of this??.. I'm not sure if output is considered on AG or not... . Thank you for reading|14|0|private|This should not be an issue since this project is not dependent on output. Hope this eases your mind!||0
kvx2jo7ps9p37q|Is there any way to get additional autograder submissions?|"So, in my specific program (Visual Studio), there are certain lines of code that are not counted as errors that the autograder counted as errors. Specifically, two independent lines of code which just had a variable name and a semicolon (for example, ""variable;""). My debugger did not tell me at all that this was an error, but the autograder counts it as one (well, it counts it as a warning, which is being treated as an error). I have been to office hours many times today, and have generally gotten the consensus from all GSIs that Visual Studio is far less consistent than the other 2 main debuggers.. My question is, is there any way to apply for additional autograder submissions? Had these errors (which I had no clue existed, because Visual Studio did not inform me of them, and in-fact when I ran the debugger included with the software, ran completely) not been present, the code would have run without issue."|14|0|private|Unfortunately there is no way to apply for extra submits as it would be unfair to give one student extra submits and not give them to everybody else. In the future, if you are having problems with Visual Studio, I would recommend switching over to VSCode (or XCode if you're on a Mac). Sorry to hear that this happened!||0
kvx1kmuz1wy1c3|OH Zoom Off|Hello I was on Zoom OH with an IA last 30 minutes and unfortunately, I can't both charge while using the computer so my computer was shut off. . . I would like to reconnect with the IA because now after I turn of my Visual Studio Code the file wouldn't open again. . . I remember the instructor has blonde hair with an unknown pronoun. (I would say girl but I can't assume). . I am currently risking my life to use the computer so please reply to this post asap. |15|0|private|Unfortunately you will have to wait until next office hours to connect with an IA over Zoom.||0
kvx0b8vnk7u7h2|Iterator value after Erase|After the erase function is called are we supposed to move the node_ptr for the iterator to the next node? If so, would that mean that if we erase the last node in the list do we move the node to the nullptr after the list?|105|0|active|The iterator just gets invalidated||0
kvwzy8yxjst6sr|Question about amount of bug exposed|I got 21 bugs exposed by my test but I hear from my friends that they got 22 bugs exposed. Do I need to find all 22 bugs to get full points in the private test?|123|0|active|You only need to catch 21 bugs to get full points on the mutation testing suite||1
kvwype057kc5f6|caen error cannot find /usr/lib64/libubsan|Trying to run my List_tests file on CAEN. It works on my vs code debugger. And it's sort of a weird error too, can anyone help me make sense of what's going on? Thanks.. . . |81|0|active|@7||0
kvwxvni1quh4h6|tests don&#39;t run on autograder but do on xcode|"My tests run fine through my xcode but do not run through autograder, i have been trying to figure out where it is coming from and cannot seem to find the culprit. . both run and valgrind fail. valgrind gives this error. ""Conditional jump or move depends on uninitialized value(s)"". for all my tests. but i initialize everything i think.. any help would be appreciated, I personally do not understand the output in the autograder to even know where to start.. Thank you!"|10|0|private|resolved||0
kvwxajni7n7q0|Creating new Node causes seg fault error, but only when insert is called with end() parameter|"I am currently debugging insert() edge cases and for whatever reason, when I call insert with the end iterator, it gives the following error when the line ""Node *p = new Node;"" in push_back() is ran. push_back() is called when insert has the end iterator as a parameter.. . Unable to open 'malloc.c': Unable to read file 'vscode-remote://wsl+ubuntu-20.04/build/glibc-eX1tMB/glibc-2.31/malloc/malloc.c' (Error: Unable to resolve nonexistent file 'vscode-remote://wsl+ubuntu-20.04/build/glibc-eX1tMB/glibc-2.31/malloc/malloc.c').. . Any ideas as to what could be happening? If more information is needed I will gladly provide it."|15|0|private|Marking as resolved as p4 is over.||0
kvwwqhd3xt965d|end() and --operator|i'm creating test cases right now and my current implementation of end() doesn't seem correct. Since its one past the last element, it should be a nullptr, so my implementation is last+1 using array arithmetic. I just realized this doesn't work with linked lists. Would I be able to access one past the end with last->next?. . Also, in a test case, if I wanted to create an iterator that equals list.end(), it wouldn't let me use the -- operator on it to check if the iterator is equal to the last element due to the assert statement (assert(node_ptr);) which checks if its dereferencable. How do i work my way around this?|108|0|active|Yes to your first question.. . You can't call -- on an end iterator because operator-- requires the iterator be dereferencable (and an end iterator is not dereferencable).  If you want to test that you created an end iterator, then you can create a begin iterator on your list and ++ that iterator until it's past the last element in the list and check that that is equal to an end iterator.||0
kvww9z30qor7a0|Valgrind Error on Student List tests on student list|. . We have been trying to debug this valgrind error in autograder for the past 5 hours. We believe It refers to memory loss, but we can't seem to find the problem with our code. We've looked through and our destructor, and pop_back seem to be effectively deleting memory but we're not completely sure. We also suspect that it could be because we purposely use the ++ operator in our tests to go past the end of the list to check end? Any help or advice would be much appreciated. Thank You!|90|1|active|I had a tricky memory leak with clear(), which was my function that popped all the nodes in the list to make sure there were no memory leaks. Like yours, mine complained about push_back. If you're testing something that uses pop_front or pop_back, try using the other to see if the memory leak disappears. That might give you some insight on where to look closer.. . For your insert, make certain that you're making the nodes point correctly. Say you have node a, b, d, and you want c between b and d. Make absolutely certain that b's next points to c, c's prev points to b, c's next points to d, and d's prev points to c. I think I had a memory error with that too.. . Good luck!||0
kvwvote2f6k1ch|Specific Valgrind memory issue|This is the valgrind error I receive when running my list_tests. I have a list destructor and for all the places I use new (to create new nodes) whenever I try to put a delete in I get a segmentation fault when trying to compile it. Do these mean that my issue is within push_front and push back thats causing the memory leaks??. |116|0|active|It could be that in one of your functions, you create a dynamic object but then don't have a way to get the address of that object once the function returns.  Make sure that you're only creating a new node in push_front, push_back, insert, and/or copy_all (depending on implementation of copy_all, you may not directly be calling new in that function).  Also make sure that when creating a dynamic object, you make sure to update next/prev/first/last so that you have a way to access that memory object again after the function returns||0
kvwvky8xn002yy|valgrind works in CAEN but autograder says there&#39;s errors|"I have ""0 errors from 0 contexts (suppressed: 0 from 0)"" from valgrind in CAEN for both my List_tests & List_public_test, but autograder says there's these valgrind errors:. . ==78== 24 bytes in 1 blocks are definitely lost in loss record 1 of 32==78== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)3==78== by 0x409F57: List<int>::push_front(int const&) (List.h:78)4==78== by 0x405A7D: test13_erase_middle() (List_tests.cpp:265)5==78== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)6==78== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)7==78== by 0x407815: main (List_tests.cpp:470)8==78==9==78== 24 bytes in 1 blocks are definitely lost in loss record 2 of 310==78== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)11==78== by 0x40A13B: List<int>::push_back(int const&) (List.h:97)12==78== by 0x40A58A: List<int>::insert(List<int>::Iterator, int const&) (List.h:291)13==78== by 0x407220: test28_insert_decrease_erase_size3() (List_tests.cpp:430)14==78== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)15==78== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)16==78== by 0x407815: main (List_tests.cpp:470)17==78=="|86|0|active|This means there is a memory leak in List::push_front, when it is called in test13_erase_middle(). You can also try running valgrind locally with ```--leak-check=full```, but idk if that will make it show up as an error.||0
kvwuygiunx774m|Test case error| When I try to run this test case, it doesnt tell me an error message, all I can see is that it failed. I'm not sure how to improve this.|15|0|private|Marking as resolved as P4 is over.||1
kvwu08ibzjt22j|Autograder error|Autograder won't recognize test cases. Why is that?|126|0|active|You created a public member function called pop_all which means you changed the public interface of List, and trying to call pop_all in your List_tests caused the compile error.  Since clear() is already a member function of the public interface of List, I'd recommend using and implementing clear() instead of creating pop_all||1
kvwtxjk25wsb2|Valgrind Error|I'm really confused about those errors when passing the Valgrind. Could someone help me to interpret them? Any type of advice would be warmly appreciated!. ==80== Invalid read of size 82==80== at 0x4095B4: List<int>::pop_front() (List.h:299)3==80== by 0x40A494: List<int>::clear() (List.h:331)4==80== by 0x408FAB: List<int>::~List() (List.h:28)5==80== by 0x40486E: test_push() (List_tests.cpp:134)6==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)7==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)8==80== by 0x407338: main (List_tests.cpp:623)9==80== Address 0x5ac3b10 is 0 bytes inside a block of size 24 free'd10==80== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)11==80== by 0x409607: List<int>::pop_front() (List.h:306)12==80== by 0x40A494: List<int>::clear() (List.h:331)13==80== by 0x408FAB: List<int>::~List() (List.h:28)14==80== by 0x404847: test_push() (List_tests.cpp:153)15==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)16==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)17==80== by 0x407338: main (List_tests.cpp:623)18==80== Block was alloc'd at19==80== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)20==80== by 0x4092AF: List<int>::push_back(int const&) (List.h:277)21==80== by 0x40A51C: List<int>::copy_all(List<int> const&) (List.h:91)22==80== by 0x40949B: List<int>::List(List<int> const&) (List.h:35)23==80== by 0x404543: test_push() (List_tests.cpp:153)24==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)25==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)26==80== by 0x407338: main (List_tests.cpp:623)27==80==28==80== Invalid read of size 829==80== at 0x409009: List<int>::size() const (List.h:235)30==80== by 0x4095C9: List<int>::pop_front() (List.h:300)31==80== by 0x40A494: List<int>::clear() (List.h:331)32==80== by 0x408FAB: List<int>::~List() (List.h:28)33==80== by 0x40486E: test_push() (List_tests.cpp:134)34==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)35==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)36==80== by 0x407338: main (List_tests.cpp:623)37==80== Address 0x5ac3b70 is 0 bytes inside a block of size 24 free'd38==80== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)39==80== by 0x409607: List<int>::pop_front() (List.h:306)40==80== by 0x40A494: List<int>::clear() (List.h:331)41==80== by 0x408FAB: List<int>::~List() (List.h:28)42==80== by 0x404847: test_push() (List_tests.cpp:153)43==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)44==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)45==80== by 0x407338: main (List_tests.cpp:623)46==80== Block was alloc'd at47==80== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)48==80== by 0x4092AF: List<int>::push_back(int const&) (List.h:277)49==80== by 0x40455D: test_push() (List_tests.cpp:154)50==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)51==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)52==80== by 0x407338: main (List_tests.cpp:623)53==80==54==80== Invalid write of size 855==80== at 0x4095F4: List<int>::pop_front() (List.h:305)56==80== by 0x40A494: List<int>::clear() (List.h:331)57==80== by 0x408FAB: List<int>::~List() (List.h:28)58==80== by 0x40486E: test_push() (List_tests.cpp:134)59==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)60==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)61==80== by 0x407338: main (List_tests.cpp:623)62==80== Address 0x5ac3b78 is 8 bytes inside a block of size 24 free'd63==80== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)64==80== by 0x409607: List<int>::pop_front() (List.h:306)65==80== by 0x40A494: List<int>::clear() (List.h:331)66==80== by 0x408FAB: List<int>::~List() (List.h:28)67==80== by 0x404847: test_push() (List_tests.cpp:153)68==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)69==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)70==80== by 0x407338: main (List_tests.cpp:623)71==80== Block was alloc'd at72==80== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)73==80== by 0x4092AF: List<int>::push_back(int const&) (List.h:277)74==80== by 0x40455D: test_push() (List_tests.cpp:154)75==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)76==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)77==80== by 0x407338: main (List_tests.cpp:623)78==80==79==80== Invalid free() / delete / delete[] / realloc()80==80== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)81==80== by 0x409607: List<int>::pop_front() (List.h:306)82==80== by 0x40A494: List<int>::clear() (List.h:331)83==80== by 0x408FAB: List<int>::~List() (List.h:28)84==80== by 0x40486E: test_push() (List_tests.cpp:134)85==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)86==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)87==80== by 0x407338: main (List_tests.cpp:623)88==80== Address 0x5ac3b10 is 0 bytes inside a block of size 24 free'd89==80== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)90==80== by 0x409607: List<int>::pop_front() (List.h:306)91==80== by 0x40A494: List<int>::clear() (List.h:331)92==80== by 0x408FAB: List<int>::~List() (List.h:28)93==80== by 0x404847: test_push() (List_tests.cpp:153)94==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)95==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)96==80== by 0x407338: main (List_tests.cpp:623)97==80== Block was alloc'd at98==80== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)99==80== by 0x4092AF: List<int>::push_back(int const&) (List.h:277)100==80== by 0x40A51C: List<int>::copy_all(List<int> const&) (List.h:91)101==80== by 0x40949B: List<int>::List(List<int> const&) (List.h:35)102==80== by 0x404543: test_push() (List_tests.cpp:153)103==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)104==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)105==80== by 0x407338: main (List_tests.cpp:623)106==80==107==80== Invalid free() / delete / delete[] / realloc()108==80== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)109==80== by 0x4095EA: List<int>::pop_front() (List.h:302)110==80== by 0x40A494: List<int>::clear() (List.h:331)111==80== by 0x408FAB: List<int>::~List() (List.h:28)112==80== by 0x40486E: test_push() (List_tests.cpp:134)113==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)114==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)115==80== by 0x407338: main (List_tests.cpp:623)116==80== Address 0x5ac3c30 is 0 bytes inside a block of size 24 free'd117==80== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)118==80== by 0x4095EA: List<int>::pop_front() (List.h:302)119==80== by 0x40A494: List<int>::clear() (List.h:331)120==80== by 0x408FAB: List<int>::~List() (List.h:28)121==80== by 0x404847: test_push() (List_tests.cpp:153)122==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)123==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)124==80== by 0x407338: main (List_tests.cpp:623)125==80== Block was alloc'd at126==80== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)127==80== by 0x4092AF: List<int>::push_back(int const&) (List.h:277)128==80== by 0x40463E: test_push() (List_tests.cpp:165)129==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)130==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)131==80== by 0x407338: main (List_tests.cpp:623)132==80==133==80== 48 bytes in 2 blocks are definitely lost in loss record 1 of 2134==80== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)135==80== by 0x409031: List<int>::push_front(int const&) (List.h:258)136==80== by 0x4043E7: test_push() (List_tests.cpp:135)137==80== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)138==80== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)139==80== by 0x407338: main (List_tests.cpp:623)140==80==|89|0|active|It looks like you're dereferencing pointers that point to invalid data, that you're trying to delete a pointer into part of a block of memory, and that you also have some memory leaks. It may be helpful to step through some tests in a debugger so that you can isolate these different errors one at a time, making sure that for every `new` you have a corresponding `delete`, and that you're not doing any pointer arithmetic or other changes that could cause you to get an invalid pointer.||0
kvwtwpxvtpx4rd|Problem with &#43;&#43; and -- overload|When running list_compile_check.exe I get a runtime error once it reaches the line. . cout << *++--iter << endl;. . I believe this is because iter points to the first element in the list, so when -- is called iter then points to the nullptr. Which then leads to a problem when I try to call ++ on iter. However, inside of the ++ operator overload I placed. . assert(node_ptr);. Which doesn't fail.. . . |80|0|active|In List_compile_check.cpp, iter evolves like this:. ```c++. // iter is declared and used a bit above.... . iter = my_list.begin(); // points to first element. /* ... */. ++iter; // now points to second element. cout << *iter << endl; // prints out second element. cout << *++--iter << endl; // prints out second element again. ```. So iter should never be looking at a nullptr. You probably have a bug in your `operator++` or `operator*` (because you shouldn't have modified `operator--`).||1
kvwscyhg15y33g|Build failing with list compile check|"Hi, so I've been running all of my tests and such with no errors. However, in the list_compile_check, I can't seem to resolve this error, which is appearing twice (don't worry, this is not my code just the compile check code):. . . . It says ""Invalid operands to binary expression ('const List<int>::Iterator' and 'List<int>::Iterator')"", I don't have const in end() but I do have consts in the arguments of both == and !=. Any ideas?. . Thanks so much."|85|0|active|Did you make sure the `this` pointer was const in both `opeartor==` and `operator!=`, as in did you declare them with a second const after the argument but before the body as follows?. ```cpp. bool operator==(const Iterator &rhs) const { }. //                     you need this ^^^^^. ```||1
kvwscxo6wke4or|Operator overload for Iterator compiler error|"Previously I tried putting these definitions inside the iterator class with template typename T but the compiler throws an error saying something about template being shadowed. Now I move them outside to the bottom of List.h and this happens, what should I do?. . If I put template typename above each of them the error is instead ""declaration is incompatible"". "|8|0|private|If you're implementing outside the class, you'd need to write a declaration for the function inside of the Iterator class and also put template <typename T> on the line above the function implementation.||0
kvwrmsfyo121jh|valgrind errors|if I keep getting a valgrind error for my list_tests and am not able to fix it, will that highly affect the score that comes out of autograder?. Because its only 1 point in the autograder grading we have access to now, but I am just worried that if i am not able to fix the memory error, I won't be able to get anymore points from the private tests if that makes any sense.|64|0|active|marking resolved due to deadline||1
kvwre5ry1z93w|clear()|Can the clear() function be used on an empty list or is that against the RME?|60|0|active|If there is no mention of needing a non-empty list in the requires clause then you should be able to use it||0
kvwqjklepji13k|Weird push_back bug|There's a weird bug where I can't do push_back multiple times in a row, but I can still alternate between push_front and push_back. Push_front has an even weirder similar problem where it can only be repeated three times in a row before there's an issue. I'm really confused on how this is happening|87|0|active|The scenarios mentioned in the student answer are great examples to look at when testing!||0
kvwq8s5qj1v57z|having trouble testing iterator bool operators|"In my test cases, I'm trying to test the == and != operators by just comparing an Iterator ""i"" which I define above to a nullptr, using ASSERT_TRUE and the == when I know it should be a nullptr and the opposite when I know it shouldn't be. However, I'm getting an error in list_tests that says: . . . . Any ideas why this would be happening? My operators are all defined under the public section of iterator, and I have no trouble using the --,++,and * operators in my tests.. . Thank you!"|66|0|active|You can't compare an iterator directly to a pointer. If you want to check to see if an iterator is pointing past the end of the list, you should check if `i == list.end()`.||1
kvwpp9g7qiq52d|Running Tests Error|I. I was trying to run my tests on my computer, and I got this assertion fail. is this a operator code issue or is it because of my test case?|7|0|private|My guess is that you're trying to dereference an iterator that's pointing to nullptr in your test case.||1
kvwpkux1dyg4ia|autograder &#34;no tests submitted&#34; but were submitted|When I submitted list_tests and list.h, the autograder came back and said that no test cases were submitted. However, they are submitted and can be seen in the file preview given by the autograder. Every other time the autograder has worked. It worked 20 minutes earlier. All of the tests compile and run on my computer. This used up my final submit.|14|0|private|In the spec, it specifies that you are not allowed to modify the public interface of the List class. You have a public function print() in your list class, and autograder is flagging that as a compile error because you're not allowed to add public functions to your List class.||0
kvwosl1zcd52zd|valgrind test cases|We aren't able to remove the valgrind errors. We are getting a lot of. Conditional jump or move depends on uninitialised value(s) as the error and we looked for places it could come from and tried adding any initializations since our last autograder submit but are just unsure where to look from there. It seems they come from copy_all, erase or ==, but I looked over those and can't see where something would be uninitialized. We also added in clear initializations in pop_front/back and push but still are unsure, example below. Any help would be appreciated!|12|0|private|marking resolved due to deadline||1
kvwo2s8iz1326t|Grading for tests|If we use just assert instead of using ASSERT_EQUAL will we be graded down for not following unit testing framework?|83|0|active|I would suggest following the unit testing framework.  It's essentially the same thing as using assert statements.. . ex. assert(3 == 3) is the same thing as ASSERT_EQUAL(3, 3) for an example. . The ones you'll likely use are: ASSERT_EQUAL, ASSERT_NOT_EQUAL, ASSERT_TRUE, ASSERT_FALSE||0
kvwnjmmtxxna7|weird Address sanitizer error|"Address sanitizer points out an error on the line where I write newNode->datum = datum, wherever and whenever I put that in. Error is heap use after free on address. It then spits out a bunch of information including ""shadow bytes around the buggy address:"" and shows address errors. Any help in fixing this?"|52|0|active|For some reason, it's complaining that newNode is not something you're allowed to write to. Maybe you haven't called new and allocated memory for it, or some other reason, it depends on your code. ||1
kvwn5tke85c2sf|I keep getting a seg fault when with my pop_front function.|. I keep getting this seg fault it points to my else statement. I was using my pop front function in my clear function.|6|0|private|I would take a look at the other functions that you are calling before pop_front() to make sure that all pointers are being assigned correctly and that you are not trying to access an already deleted Node.||0
kvwmjw4jpo03bi|push front/back|If you were to push a node into the front of the list and one to the back, should they be connected? Should that be part of the implementation for the push functions?|65|0|active|This depends on the state of the current list being pushed into.. . If you have an empty list and then you push front and then back, then since those are the only two nodes in the list then there are direct pointers between them.. . However, if you have already existing nodes in the list and you push front and push back, then the already existing nodes will be between the first and last node, so you just need to make sure all connections are established appropriately.. . Let me know if you need any clarifications!||0
kvwm15lijhj63f|Big three inside or outside the class?|Should we write our big three code of List inside the List class or outside of it?|75|0|active|you can do either, but make sure if you’re doing it outside the class you put the function signature inside and prefix the function name with List<T>::||0
kvwkezm8lhx28|No Test submitted error|So I submitted my files and the valgrind error with them has gone away for list tests, however the autograder does not accept any of my tests. Is it because I'm trying to access private member variables out side of the list class? Heres my uniqname if anyone could take a look: bensoncr|98|0|active|You cannot add functions to the Iterator class (in your case LastNode()). You are also trying to access last within Iterator, and that is not allowed.||1
kvwj3vux6526x7|No result show in CANE, no bugs shown|I'm wondering why this happened?. . I'm pretty sure it can run on my local (passed all the tests I wrote) end but on CANE after I run it, there's no result shown. I don't think there is an infinite loop or sth like that since I just changed a function to fix the invalid read of size 8 Valgrind problem and the for loop in the function can be jumped out (I even add a break command in it to ensure it will break at the right place).|107|0|active|Resolved below||2
kvwiczv3ufs4s3|seg fault| Does anyone know why I'm getting this seg fault? I wrote multiple test cases for the insert function but it seems to be giving me the same error for them all? any input would be helpful|7|0|private|I've noticed a couple of things:. . 1) in the condition of your if statement, you are comparing an iterator to a Node pointer (as opposed to comparing two Node pointers), so that is likely causing some weird behavior.. . 2) in your else statement, it looks like you are deleting the Node (insertion) that you are creating at the top of the insert function and attempting to add to the list. By doing this you aren't actually adding a Node to the list, and are likely causing issues with invalid pointers.||1
kvwi3rg58eo6jx|student list tests valgrind errors|I'm not sure how to interpret these errors? The first 'invalid read of size 4' doesn't make sense because in the test case, there's 3 elements with a 4th one being inserted, but we don't call the size function and all the tests for the insert function pass.. |103|0|active|You may be trying to read in/return values that are null. Try reading through your code and analyzing where it could potentially return or access a null value.||0
kvwhha3zms05sx|Operator overloads|I'm a little confused are we expected to overload the operators for the link lists as well as the iterators?|124|0|active|You should also be implemented the decrement (--) overload. Additionally, just a little tweak to the student answer, the assignment operator is simple called the assignment operator, not the copy assignment constructor since this is not a constructor (just to avoid possible confusion).. . Additionally, the reason for overloading these operators in Iterator is because Iterators essentially allow us to inspect a single node in the list and gives us a way of traversing the list node by node. We do not need to overload these operators in List because what would ++List, --List, or *List even do? Sure we could overload ==, but no need to.||0
kvw3qvrljk714q|Pop_back failing tests due to double free|This test for pop_back:. . TEST(pop_back_basic) {.     List<int> newList;.     newList.push_back(5);.     newList.pop_back();.     ASSERT_TRUE(newList.empty());. }. aborts before the assertion due to double free. I have figured out that pop_back returns successfully but the error occurs before the assertion. Any tips for finding issues in pop_back? Any chance it could be a problem with empty() instead?|74|0|active|If the abort happens before the assertion, then empty shouldn't be the issue. I would also check push_back as well. My tips would be to use a debugger and step through each function to see what each of the variables are at all times. Another idea would be to draw out a linked list diagram with arrows to make sure your function correctly pushes and pops||0
kvvz28ygggi703|Segmentation Fault|. . Can anyone help me figure out the source of the segmentation fault? I initially thought it was coming from push_back but that doesn't seem to be the case since the value of list.front() is the expected value of 1. I also got a segmentation fault from running the make compile check but that isn't very useful. thanks!. uniquename: quw|26|0|private|Try running your code with a debugger: the debugger will usually stop on the line that is seg faulting, and give you information regarding which functions were called and the state of the List at the time of the seg fault.||2
kvvyhpkdsnu7j4|most weird bug, function not take in parameter|my function is not take in parameter, I did not modify its title or position, why is it not taking any parameter. The left picture is from the list.h and the right picture is from my test.|83|0|active|How do you initialize the iterator?||0
kvvxk1uiy9q2jb|how to check memory leak|I run my code on valgrind and get the memory leak so how could i check where the problem happend and then fix it. . |124|0|active|"this ""x bytes in y blocks are definitely lost"" error is telling you that you have a memory leak, which means you're creating a `Node` with `new` that you aren't freeing with `delete`. The trace after that tells you the function stack at the time when the `Node` is created with `new`. The part that's relevant to you (for the first one) is that the `insert` member function in your `test_insert_1` test case is creating the node, and then it isn't being deleted. You'll have to look at the code in your specific test cases to see what is responsible for cleaning up that memory. Is one of the push functions or erase supposed to do it? Is it the destructor? look through your code to see where you could be missing a `delete`"||1
kvvwryodw53t|pop_back segmentation error|When using pop_back() I got a segmentation error |70|0|active|segmentation errors are usually the result of trying to access memory that has either already been deleted or a nullptr. Remember that if `first` or `last` are still `nullptr` (like they are when we construct the list), you can't use the `->` operator to access `next` or `prev` for them. It's kinda hard to say anything else without knowing more details, but just try to trace through your code and see if you're double deleting something or trying to access a `nullptr` or some of the other memory errors we discussed in class||0
kvvwr6tnyqa7js|List_compile_check seg fault|All of my test cases work fine and List_tests.cpp compiles fine, but I'm getting a seg fault on lines 61 and 62 of List_compile_check.cpp. My only guess is that there is something wrong with my overloaded *, --, or ++ since those are the only operators/functions being called on those lines besides begin() which works fine everywhere else.. . . *. . ++. . --, obviously this one was given but want to make sure I didn't accidentally change it.|7|0|private|I just looked at your List.h since your operators look fine, and it looks like you aren't correctly setting your next and prev pointers in your push front/back functions.  I would take a look there to make sure the connections are correct.||0
kvvvzqt1de42jr|iterator on empty list clarification|If I have an iterator that points to the second Node in a list for example then clear the list so it is now empty, should dereferencing the iterator result in an error (meaning I somehow make the node_ptr in the iterator nullptr), or should it still output the datum at that Node?|111|0|active|It would result in an error anyway because the node the iterator is pointing to was freed - you don't need to worry about setting `node_ptr` to `nullptr`.||1
kvvux81o3bs5gr|iterator initialized to nullptr|If an iterator is initialized to a null pointer (by setting it equal to list.begin() for an empty list, for example) once an element is inserted into the list using the insert() function, should the iterator still be pointing at a null pointer? If so, would the iterator need to be updated after each insert() call during testing (or should this be done within a function somewhere)?|94|3|active|The iterator should still point to the null pointer.||0
kvvux26w8qm6pb|Testing Empty|If I want to test that a list is empty and that front and back is nullptr, how would I go about testing if something is nullptr?|95|0|active|If your list is empty, you could assert that a begin Iterator is the same as an end Iterator (i.e. they should be equal)||0
kvvu9mceaxdcb|Compile error|"Why does my IDE report those errors when passing the compile check?. . List.h:118:9: error: ‘victim’ was not declared in this scope  118 |   Node *victim = last;      |         ^~~~~~List.h:118:18: error: ‘last’ was not declared in this scope  118 |   Node *victim = last;      |                  ^~~~List.h:121:7: error: ‘first’ was not declared in this scope  121 |       first = nullptr;. List.h:131:15: error: a function-definition is not allowed here before ‘{’ token  131 |   void clear(){      |               ^List.h:137:9: error: expected ‘;’ before ‘{’ token  137 |   List(){      |         ^      |         ;List.h:142:10: error: expected ‘;’ before ‘{’ token  142 |   ~List(){. List.h:146:8: error: expected primary-expression before ‘const’  146 |   List(const List<T> &l)      |        ^~~~~List.h:156:1: error: expected primary-expression before ‘private’  156 | private:. List.h:241:3: error: ‘Iterator’ was not declared in this scope; did you mean ‘operator=’?  241 |   Iterator begin() const {. List_compile_check.cpp: In member function ‘int List<T>::main()’:List_compile_check.cpp:21:5: error: ‘cout’ was not declared in this scope; did you mean ‘std::cout’?   21 |     cout << (my_list.size() == size) << endl;. List.h:270:15: error: variable or field ‘insert’ declared void  270 |   void insert(Iterator i, const T &datum){. List_compile_check.cpp:37:20: error: ‘class List<int>’ has no member named ‘begin’   37 |     iter = my_list.begin();"|110|0|active|resolved||1
kvvu6122acp75m|test failed on autograder but run well in my own computer and CANE|"My ""student list test on student list"" failed and it doesn't show me the reason. However, my code and test run well on my own computer and on CANE. Appreciate all the advice. . "|61|0|active|resolved||1
kvvu1xvzzx1ci|Iterator Question|How to reassign the iterator to nullptr after deleting the node it points to? Or do I need to reassign the iterator to nullptr after the node it points to is being deleted?. . . . Here is one of my test cases. After the line ++iter_2, iter_1 is pointing to the first node, and iter_2 is pointing to the last node. But when I use pop_back(), the list will delete the last node, causing the iterator to point to a dead object. So how to set the iterator to a nullptr in this case?|86|0|active|The student answer is correct, but if you want to be safe, you can set iter_2 to be equal to my_list.end() if you know it has been invalidated. ||1
kvvt6q0mnri3rc|iterator|If an iterator(iter) is pointing to list.end(), should our code function such that --iter points to the last element of the list?|91|0|active|Not with how we have implemented the `--` and `++` operators. When you apply either operator to an Iterator, it has to be dereferenceable, which an end iterator is not (dereferencing `nullptr` causes undefined behavior). In our implementation, incrementing or decrementing an end iterator isn't valid behavior.||0
kvvszah6r096pm|Discrepancy in Error on Terminal|I wanted to write the overloaded assignment operator. I included the self assignment operator part of the code for testing purposes.. . Here is my test case for the self-assignment operator.. . When I make the test file in the local terminal (I test on a MacBook), I get this error:. . However, when I test it on CAEN, I do not receive an error:. . Should I ignore the error that I am getting on my local terminal and submit my code as it is?|13|0|private|If you are trying to test the assignment operator I would suggest trying to create a new list (ex. list2) with different elements and then try to use a similar statement as the line above by setting the new list = to the current list, as opposed to setting a list equal to itself.||1
kvvsjwzy7bk4wa|Everything working on CAEN and valgrind, autograder not taking it|"When I run valgrind myself my code shows no errors, and my List_tests.cpp compiles and runs fine on CAEN.  Despite this, Autograder says that ""No test cases were submitted"" and is failing me on valgrind.  My List_tests.cpp is compiling fine and while I have added new tests previously autograder was not having any issues with it.  Any ideas what's going wrong?. . Attached is the valgrind response that autograder is giving me, the valgrind response I get from CAEN and my List_tests.cpp results in autograder.. . Valgrind results on CAEN:. . Valgrind results on autograder:. . List_tests.cpp results on autograder:. "|102|0|active|The followup answer is correct. You should resolve the leaked memory issue that is happening in your program.||1
kvvsfolxu5d2zs|Private Templating Test Doesn&#39;t Compile|Hello! My partner and I are having an issue with our private templating test not compiling even though it did before prior to our most recent submits. We were wondering if we could get specific feedback based on our Autograder submits to get more insight on the issue because we're not sure where we went wrong. We haven't edited the template in any way so far. Our uniquenames are udoka and kirandk. Thank you!|10|0|private|It looks like you're trying to use == on a datum, which isn't guaranteed to exists, so your code doesn't compile when templated with some types. . . Also, please follow @6 to update your uniqname in your username for the future. ||0
kvvs7ruphqr79c|help :(|My linked list doesn't work :( can I implement a skip list instead? I think that might be easier|13|1|private|I'm sorry to hear that your linked list isn't working. I recommend you go to office hours as we will be able to help you a lot more there than on piazza. . . Unfortunately we won't be learning what skip lists are in this course, so you can't implement a skip list for this project.||1
kvvrs6hc5c84za|Failing pop_front assertion not empty, but the list isn&#39;t empty|I've been running my test cases just fine but now they're saying pop_front is failing the assertion of not empty. In this test case (test_pop_back_double) I'm not even calling pop_front, I'm calling pop_back so I'm not sure why this is happening. I also couted the size and the .empty() function and the size is correct and empty is 0 (false). Any help would be appreciated!. . |70|0|active| It could be a problem with your destructor||1
kvvrkto6d09js|Valgrind error with push_back|I've been testing out the valgrind command on my test cases and it prints out 5 cases of memory leakage. I've attached one of the errors below. They're all similar errors where the only line that changes is what function from the Test file it's coming from.. They all reference push_back(), which doesn't make sense to me since I don't believe this function should delete any objects. Since it is meant to add an object. Any thoughts?.  |50|0|active|the error is saying that a Node created with push_back never gets deleted. This means your error is probably either in one of your pop functions or clear or your destructor, depending on which test cases this is happening in. ||0
kvvrezgas0a6s7|Error: No test cases were submitted|I have seen other people posted the same question, about changing the public interface of List.h. However after I checked every potential cause (iterator constructor, different public interface name), I still couldn't figure out why|6|1|private|You created an Iterator variable on line 475 of List_tests.cpp but never use it.  This is what caused the compile error||1
kvvqxqind3qjp|Exit 2 Status on autograder for List_tests.cpp|Hi I'm having an error that a lot of other folks seem to be having. Basically I submitted my unit tests to the autograder and got that nasty exit 2 error. This implies that I'm interfacing with the public part of List class wrong which I don't think I am (I checked that a couple times), or I'm getting some kind of other compiler error. I delete using namespace from the top of my header file. Nothing. I tried working with the big three to make sure my implementation was fine. Everything compiles on valgrind, visual studio, CAEN. Just not the autograder. I'm really just kind of stuck and I think I need some help. . . |62|0|active|Looks like this was resolved in @3049||0
kvvqomjxcr4vd|Errors with pointers and dots|I'm getting a lot of errors concerning dots and ->s from the code written for erase and insert. I thought I would be able to use the dot operator to use next and prev because I declared friend class List under the private class for Iterators. Should I also declare new variables for new and prev under the private class for Iterator? Any help would be appreciated. . |8|0|private|Remember that next and prev are members of the Node struct, not the List or Iterator class. Think about how you can use the member node_ptr of the Iterator class here. ||0
kvvqmwcv6clet|List compile check error|I submitted my code to Autograder after extensively working on tests and code to try and make it work. I have 0 errors with the tests I have written, and Ubuntu runs List_tests.exe without issue. When I submitted to autograder I am getting List_compile_check.cpp errors in my error output. There's over 900 lines of error output and I have no idea how to process all the information from it. I realized part of the error was I forgot the & after bool for operator== and operator!=, but I can't tell if that was the only problem with my code compiling.. . EDIT: I've fixed some stuff, and now only have this as my error. I don't understand what the problem is with my code that is causing this error:. |9|0|private|Based on your latest autograder submit, it seems like you've figured this one out, so I'm marking as resolved||0
kvvqh3n4s9a5bo|Assignment operator type conversion|"Are we expected to do type conversions when calling the assignment operator between two lists?. For example if I have list1 that has 5 ints in it and list2 that has 3 characters in it, are we expected to be able to do list1 = list2?. trying out this test case for now, I get an ""No such type conversion"" error."|77|0|active|Same datum type. If list1 was initialized as a List<int>, it should only manage that type.||0
kvvpquv7nhy413|What&#39;s the Use of the end() Function?|If I'm thinking about this correctly/reading spec correctly, I can't use -- if I call something @ List<int>::Iterator iter = my_list.end(); For erase and insert, it would be better to just split it into a few if statements rather than just using front() and end(). If end called last->next, then it makes so much more sense than just one past the end. |103|0|active|Usually, the end() function is used in for loops so the loop knows when to end.. ex:. . List my_list;. // add elements to list. for (List::Iterator iter = my_list.begin(); iter != my_list.end(); ++iter) {}||0
kvvpjgqvngh1ho|Multiple Operators for Iterator in One Line|Should our code be able to support something like this?. . ++++--iter;|48|0|active|Yes, your code should be able to support this. A hint to making this possible is to return a reference to *this.||0
kvvpcre58vh16i|Do we need to overload != in the List class?|Here is the code from notes:. . IntList & IntList::operator=(const IntList &rhs) {.   if (this != &rhs) {.     pop_all();.     push_all(rhs);.   }.   return *this;. }. . I noticed here used != to compare two lists, but if we do not overload != how to make it work? Do we need to overload == and != to do so?|140|0|active|"The `if` statement at the top of this function compares _memory addresses_ of the lists, not the contents of the lists themselves (remember, `this` is a pointer to ""the current instance of the class"", its value is an address). We don't need to overload `==` to compare addresses, and this condition just checks that the list you are trying to assign to isn't the same list that you are assigning from."||1
kvvpchw5my87bx|Copy Constructor|Do we have to implement both shallow copy and deep copy ctors? I think if we don't implement them the code will still work fine? And if we do have to, how do the compiler know when should it use the shallow one and when should it use the deep one since both of them have the same parameter?|84|0|active|You only need to implement deep copy ctors.||0
kvvp4no6ucg6vb|copy_all function|I'm having trouble with my copy_all function and any help would be great.. I wrote a test case for the assignment operator. The code on line 114 calls the overloaded assignment operator which then calls the copy_all function. In the copy all function, the compiler starts at the for loop, skips the body of the for loop and exits the function (the debugger shows it goes to line 193 and skips down to line 196). This makes the copy list not have the same elements (or no elements). When comparing the size of list and copy, it fails since List has 5 elements, and copy has zero (as seen at the bottom left corner) because the code failed to copy over the elements.. Could anyone help me with this issue? . |6|0|private|"In your copy_all function, you're starting your for loop at Node *node_ptr = first, and ""first"" is a pointer to your current list. Essentially, you're copying everything from your current list. You want to copy the nodes from ""other."". . One way you could approach this is to use other.first instead of this.first."||0
kvvp36yjhnw1sg|CAEN doesn&#39;t do anything &amp; autograder says no test cases were submitted|"I can make a copy of project 4 on CAEN but it won't let me do anything else. It says ""no target to make clean. Stopped"" & other similar things. . . [jiayou@caen-vnc-mi10 ~]$ ls'Network Trash Folder'   Private   Public   Shared   p1-stats-copy   p4-copy[jiayou@caen-vnc-mi10 ~]$ cd p4-copy[jiayou@caen-vnc-mi10 p4-copy]$ make cleanmake: *** No rule to make target 'clean'.  Stop.[jiayou@caen-vnc-mi10 p4-copy]$ make testmake: *** No rule to make target 'test'.  Stop.[jiayou@caen-vnc-mi10 p4-copy]$ make syncmake: *** No rule to make target 'sync'.  Stop.[jiayou@caen-vnc-mi10 p4-copy]$. . Can I get some input on why autograder doesn't approve of my tests? Thank you! :)"|8|0|private|Looks like you were able to figure it out!||0
kvvoro7q6ff3um|Valgrind Error| . Originally I had a valgrind error on my push_front, but after I changed the function, I got a new error. Do I now have to change some of my other functions because of that? I know it's saying my deconstructor and clear, but I don't understand how my push_front would have affected that.|62|0|active|It seems like you’re trying to dereference a nullptr in your size function. Maybe the way that you push the first element in is not properly reassigning some variable?||0
kvvnv7twwys315|How do I Test Iterator(Node *p)?|As in, how do I get the node *p? We weren't supposed to make a getter/setter for list, so how do you find p? |70|0|active|If you're asking about how to check the value of a Iterator's `node_ptr` variable, you can't do this directly from outside of the `Iterator` class since it's declared as a private member. One option to check if `node_ptr` is being set correctly is to compare two Iterator's that you know _should_ have the same `node_ptr` values, and verify that they actually do.||0
kvvnqg57ugc553|Iterator private constructor isn&#39;t working for Iterator end()|"Me and my partner are getting an error where it's saying  ""error: no matching function for call to ‘List<int>::Iterator::Iterator()’"" but it should work but it's not working for some reason."|8|0|private|That error looks like your compiler cannot find the default constructor for Iterator.  Did you implement the Iterator default constructor and if you did, is it in the public section of the Iterator class?||1
kvvne6m0ulo2m4|How to write test cases for lists and compare two lists?|I'm trying to test the various push and pop functions, but I don't know how to compare the lists with the correct output. I tried comparing a list with an array or vector of expected output but neither are working for me. Additionally, I'm unsure of how to compare two lists to check that all their elements equal each other, while said comparison respects the public interface.|142|0|active|To check that two lists are equal element-wise, you can use an iterator to traverse the list, and at each node check that the value contained in the node equals the value you would expect.. . To traverse a list by iterator:. . ```. List my_list;. //. // add some data.... //. List::Iterator it = my_list.begin(); // create an beginning iterator. . for ( ; it != my_list.end(); ++it) {.   // access node datum by dereferencing 'it'. }. ```. . See the bottom of [this](https://eecs280staff.github.io/notes/18_Iterators.html#friend-declarations) section of the course notes for reference.||0
kvvndp01cid7of|list public tests don&#39;t compile in autograder|Hi, so list_public_tests & student list tests compile for me on my computer, but don't compile in autograder. Any idea why this could be happening? . . . . |78|1|active|That's weird that they compile for you locally. Are you using the makefile? This error should show up if you're using the makefile to compile locally. Basically, it's saying that your constructor initializer list is in the wrong order, it should be in the same order as the variables were declared in the class.||0
kvvnadqu6w53is|Insert function definition|"Should the insert function also work if an iterator is pointing to ""past the end"" (nullptr). . I am not sure if an iterator is ""valid"" if it's node_ptr is a nullptr"|5|0|private|"The insert function can work if an iterator is pointing ""past the end"" (nullptr). You would insert the node at the end of the list in this case."||0
kvvm165qvev1yr|Copy Ctor|The copy ctor should only work when declaring right?. . Like the following code shouldn't make a copy right?. . List_1 = List_2. . this shouldn't change list_1 to a copy of list_2 if they are already both already initialized right|57|0|active|yes, this won't call the copy ctor, it'll call the assignment operator, which we also need to overload. A lot of the functionality is the same except you also have to free everything that's already in `List_1`||0
kvvlbewhhmo1fw|Struggling with push_back() and push_front()|I'm getting segmentation faults when I try to use push_back() and push_front() on empty Lists because accessing last->next and first->prev require me to dereference first and last which are initially null pointers.. . @2999 says the following:. . I think you are mixing up the act of assigning to a pointer, and assigning to the object in memory that a pointer points to. When you call push_back() you need to do the former, and it doesn’t require de-referencing. Just assign the address of the new last node to the old last node’s next variable.. . . And while I feel like this directly relates to my problem, there's no way that I know of to access first and last's members without first dereferencing them, since they're pointers to objects and not the actual objects themselves*. Alternatively, I was thinking of just making it so first and last initially point to dummy Nodes that I would then delete on the first use of push_front() or push_back(), but is that violating some kind of representational invariant?. . Any help you can offer is greatly appreciated!. . * They're also not pointers to existing objects either, but...|93|0|active|In the example linked list during lecture, we implemented a special case for when there was an empty list. You may need a special case for when `first` and `last` are not dereferenceable||0
kvvkz7fzkg72xf|Autograder Quesiton|If my partner and I have different implementations for List.h and we get the same score on Autograder, will Autograder take the most recent one or the one that has the higher score after the private test cases?|51|0|active|From the [syllabus](https://eecs280staff.github.io/eecs280.org/syllabus.html#project-grading):. > Your final project score is a combination of public and private tests. We use the submission that received the combined best score. If multiple submissions share the best score, we grade the last.. . I think this means that it takes the one with the highest score after the private test cases||0
kvvkdjrd9dv59h|Do we need a default constructor for list?|My partner and I are having trouble with the default constructor working. Do we even need one for list?|50|0|active|Since there's no other constructor for `List`, the compiler will technically supply one, but I wouldn't recommend relying on it||1
kvvi5aqsj0x60j|&#43;&#43; operator|Is the ++ operator supposed to reset the previous node too? I'm having an issue in my tests where I increment the iterator to get one in the middle of the list, but in the process, the prev node becomes a null ptr. I don't know how to fix it.|101|0|active|The ++ operator should only change what the Iterator is referring to, so it shouldn't be changing anything about the nodes in the list.. . If the prev member variable of the node the Iterator points to after ++ is called is a nullptr and your ++ implementation isn't changing anything about the nodes, that might mean there's something wrong with the way you're creating those nodes in the first place.||0
kvvg3p97pqa3av|List_compile_check Correct Output|Which file is the correct output of list_compile_check.cpp?|43|0|active|I don't think there is a .correct file for that test. If it runs with no errors, it is working correctly.||0
kvvfjspfmjr4se|LeakSanitizer has encountered a fatal error.|. Whenever I run my tests in VS Code I get this error, but nothing shows up on autograder.|46|0|active|I'm guessing that it doesn't like you trying to debug an executable that was compiled with address sanitizer. If you remove the address sanitizer flags from your makefile, it should work. ||0
kvvfilxy3xv7d2|valgrind error|I ran valgrind and got the following result. . I think one of my test functions is leaking memory, but I don't know how to interpret the error message valgrind is giving me. . here's part of the error message:. . . . any help is greatly appreciated!!:)|89|0|active|'Invalid read' and 'invalid write' errors indicate that your program is trying to read or write to memory that it doesn't have ownership of. This can be caused by trying to dereference a dangling pointer or invalid iterator - this is memory that you have already freed by calling `delete`, so accessing it can produce undefined behavior. Try checking that your program doesn't accidentally do this,  the error messages seems to indicate that your `insert()` function is part of the problem.||0
kvvdxwrnxh44j7|make test|why won't make test run on my terminal?|5|0|private|Make sure that your api.cpp has a main function in it. (Or if you are not trying to compile api, run a different make command)||0
kvvdvgd96utea|error from valgrind, can someone help me understand this error and help me fix it|. ==89== 24 bytes in 1 blocks are definitely lost in loss record 2 of 11. ==89==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so). ==89==    by 0x4080C1: List<double>::push_back(double const&) (List.h:82). ==89==    by 0x4045C5: testBigThree_list() (List_tests.cpp:102). ==89==    by 0x4022C0: TestCase::run(bool) (unit_test_framework.h:420). ==89==    by 0x4029EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509). ==89==    by 0x4058AF: main (List_tests.cpp:258). ==89== . ==89== 24 bytes in 1 blocks are definitely lost in loss record 3 of 11. ==89==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so). ==89==    by 0x4076B2: List<int>::push_front(int const&) (List.h:61). ==89==    by 0x403B3B: testFront_Back() (List_tests.cpp:19). ==89==    by 0x4022C0: TestCase::run(bool) (unit_test_framework.h:420). ==89==    by 0x4029EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509). ==89==    by 0x4058AF: main (List_tests.cpp:258). ==89== . ==89== 24 bytes in 1 blocks are definitely lost in loss record 4 of 11. ==89==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so). ==89==    by 0x407AFF: List<char>::push_front(char const&) (List.h:70). ==89==    by 0x403E8A: testPop() (List_tests.cpp:51). ==89==    by 0x4022C0: TestCase::run(bool) (unit_test_framework.h:420). ==89==    by 0x4029EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509). ==89==    by 0x4058AF: main (List_tests.cpp:258). ==89== . ==89== 24 bytes in 1 blocks are definitely lost in loss record 5 of 11. ==89==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so). ==89==    by 0x407B6D: List<char>::push_back(char const&) (List.h:82). ==89==    by 0x403EB8: testPop() (List_tests.cpp:53). ==89==    by 0x4022C0: TestCase::run(bool) (unit_test_framework.h:420). ==89==    by 0x4029EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509). ==89==    by 0x4058AF: main (List_tests.cpp:258). ==89== . ==89== 48 (24 direct, 24 indirect) bytes in 1 blocks are definitely lost in loss record 6 of 11. ==89==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so). ==89==    by 0x407725: List<int>::push_front(int const&) (List.h:70). ==89==    by 0x404647: testInsert() (List_tests.cpp:108). ==89==    by 0x4022C0: TestCase::run(bool) (unit_test_framework.h:420). ==89==    by 0x4029EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509). ==89==    by 0x4058AF: main (List_tests.cpp:258). ==89== . ==89== 48 bytes in 1 blocks are definitely lost in loss record 7 of 11. ==89==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so). ==89==    by 0x407F24: List<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::push_back(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (List.h:82). ==89==    by 0x4043A1: testListClear() (List_tests.cpp:90). ==89==    by 0x4022C0: TestCase::run(bool) (unit_test_framework.h:420). ==89==    by 0x4029EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509). ==89==    by 0x4058AF: main (List_tests.cpp:258). ==89== . ==89== 206 (144 direct, 62 indirect) bytes in 3 blocks are definitely lost in loss record 9 of 11. ==89==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so). ==89==    by 0x407F24: List<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::push_back(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (List.h:82). ==89==    by 0x405336: Test_List_other() (List_tests.cpp:235). ==89==    by 0x4022C0: TestCase::run(bool) (unit_test_framework.h:420). ==89==    by 0x4029EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509). ==89==    by 0x4058AF: main (List_tests.cpp:258). ==89== . ==89== 240 bytes in 10 blocks are definitely lost in loss record 10 of 11. ==89==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so). ==89==    by 0x40750D: List<int>::push_back(int const&) (List.h:82). ==89==    by 0x404F54: Test_empty() (List_tests.cpp:207). ==89==    by 0x4022C0: TestCase::run(bool) (unit_test_framework.h:420). ==89==    by 0x4029EF: TestSuite::run_tests(int, char**) (unit_test_framework.h:509). ==89==    by 0x4058AF: main (List_tests.cpp:258). ==89== |67|0|active|It looks like your program is leaking memory by failing to delete dynamically-allocated variables before they go out of scope, particularly in your `push` functions. Make sure that all objects you create with new eventually get deleted.||0
kvvdtla2cli44m|Bus Error: 10 from test for copy contr|I initialized a List() to a copy of the a List however when I execute it, it gives me that error.|49|0|active|I'm not sure exactly what's going on, but most likely something is wrong with your copy constructor accessing illegal memory. ||0
kvvdltm1n1h4q8|Can&#39;t git push or fetch|I am having a problem where I cannot push or fetch for some reason. When I type git push in the terminal, it does not prompt the sign in screen, so the terminal is just frozen. I'm wondering if anyone has had this error or knows how to resolve this?. |41|0|active|Someone else was having this issue in my OH, and we worked around it by using the Ubuntu window rather than the integrated terminal. Can you try that and see if it works?||1
kvvcvrwzl081lq|Null testing compile error|Am I allowed to test this? I'm getting a compile error. I attached my test and the error below:. . . . . Thanks!|4|0|private|Marking resolved||0
kvvckc56bzg57u|pop_back error exception has occurred|We are getting an error with our pop_back function. Why can't we assign the new last node's next to nullptr, to show that it's at the end of the list? I thought adding the nullptr would stop us from going out of bounds. (After line 297, we have the line delete victim;|6|0|private|marking as resolved||1
kvvchqxxwrz1sa|terminal valgrind not running|Can't seem to run valgrind through my terminal because of this error|6|1|private|I'm pretty sure this was resolved in OH. If not, check out @7||0
kvvbmgil4dp135|A question about the iterator|If the iterator points to a node, when we delete that node, what will happen? The iterator is still pointing to the deleted node or it points to a null pointer now?. . For example, I have three nodes, and iterator is pointing to the last node. When I do the pop_back() command for the list, the last node will be deleted. In this case, the iterator still points to the deleted (not-existed) last node or points to a null pointer?|79|0|active|It is good practice to reassign an iterator to the nullptr after they are deleted in the case so we don't accidentally use it again after deletion. This would be using a dead object.||0
kvv9uourrpf2im|Valgrind --leak-check=full|When I run valgrind ./List_tests.exe, I get no errors, like below, but when I run --leak-check=full, I get these errors/leaked memory messages and says it aborts. Do I need to worry about these?. . . With valgrind ./List_tests.exe --leak-check=full. |68|0|active|you need to put the `--leak-check=full` flag before the name of the executable or else it'll send it to your program, which gets interpreted as a command line argument. Run valgrind like `valgrind --leak-check=full ./List_test.exe`||1
kvv97vwgzhj5k3|Running Valgrind|How am I supposed to run Valgrind on CAEN? This is the command I am entering but it is not working:. . valgrind ./List_tests.exe. |59|0|active|"That is the correct command, but if it's not working, try the following things:. Make sure you're actually ssh'ed into CAEN and not in a local terminal/command prompt.. Does List_tests work if you run it normally? (""./List_tests.exe"").. Also make sure you compiled List_tests first without any compile time errors (""make List_tests.exe"").. Make sure you're compiling the executable specifically for each OS (List_tests.exe compiled on MacOS or Windows won't work on Linux), and not just trying to run the same file. . Also make sure you're in your project directory before running valgrind(if you type ""ls"", you should see List_tests.exe as one of the files).. . Can you post a screenshot/more information on what commands you ran beforehand?"||0
kvv8u15guxd1l2|Should Using erase() on First or Last Node Crash Program?|Hello,. . Should using the erase() function on an non-dereferencable iterator crash the program, or should it just do nothing? I'm not sure whether to use an assert() or an if statement.. . One more question: the Iterator i parameter for the erase() function indicates the position of the Node we seek to remove, right? As in, Iterator i points to the Node marked for destruction at the time of the function call.. . Thanks for your help!. . |118|1|active|both an assert and an 'if' statement  work -- the requires clause mentions i is a dereferenceable iterator, so no private test is going to test you using an empty iterator. . . to your second question, yes -- the iterator parameter indicates the position from which you want to remove the node. ||0
kvv6rg4ebtj4|IncludePath error|Hi, . . I'm getting an error after i updated my vs code last night . Here's what it says: . What do i do? |9|0|private|Make sure the green box in the bottom left corner says WSL Ubuntu. If it doesn't, click on it and click reopen in WSL||0
kvv6ahum3ph62g|Testing Irreator begin()|How would we test our Irreator functions since they return pointers|107|0|active|I'd recommend using the iterator to traverse the list, and check to make sure each of the elements are what you expect and that you reach the end of the iterator when anticipated.||0
kvv5ld7w9b51u2|Project 4 pop_back, pop_front error|I am having an error that the next of last doesn't point to nullptr when I call pop_back, and the prev of first doesn't point to nullptr when I call pop_front.. . template<typename T>void List<T>::pop_front() {    assert(!empty());    Node* n = first;    first = first->next;    delete n;    //first->prev = nullptr;    --num_node;}. template<typename T>void List<T>::pop_back() {    assert(!empty());    Node* n = last;    last = last->prev;    delete n;    //last->next = nullptr;    --num_node;}. . I have tried implementing the second from the last line in both functions to make it work, but when I implement these lines, it has segmentation fault. Could you please help me to debug this error?. . When I ran it with debugger, I think there is a problem when exiting the test case, which I think is a destructor. Here are my clear function and destructor.. . template<typename T>void List<T>::clear() {    while(!empty()) {        pop_back();    }. }. . ~List<T>() {      clear();  }|8|0|private|The lines you have commented out look good to me since that's something you should be doing. There is a little more thinking you need to do with pop_front() and pop_back(), specifically for edge cases. Try drawing out a picture starting with 2 nodes (including all the next/prev pointers, first and last, and any pointer variables you create in your functions) and step through your clear() function - try to see if you're trying to dereference a nullptr somewhere. Hope this helps!||0
kvv4ylt3hzy2cs|Where to call new Node|Should I be creating a new Node in copy_all, clear, or erase? |88|0|active|Functions that add elements to the list should allocate nodes on the heap, and functions that remove elements from the list should remove nodes from the heap.||0
kvv4unl6fmp2y6|No Tests Running|Did I get a memory error when it said that a project exited with code -107374819? |48|0|active|such an error usually results from undefined behavior, which in the case of project 4 is most likely due to a valgrind error. that said, we would have to take a closer look at your code to know what the specific issue is. ||0
kvv4sspzu9h4tw|erase|. . I am trying to say in my if and else if statements that if the Iterator is pointing to the front of the list then the code just needs to call pop_front() and same thing for if Iterator is pointing to the last. I believe something is wrong with how I am trying to do this though because with my test cases for these it is not going in the statements just going to else. How could I change my notation in the if and else if so it will run through correctly?. |8|0|private|Look at some other Iterator functions that you've written that give you access to the first node in the list.||0
kvv4lbymsogs9|iterator/push_back question|"Since ""insert"" inserts to the left of the element iterator I is pointing at, that means we would never be able to use push_back (or insert something to the back of the list)? Since i has to be dereferenceable and valid within the list? Just want to make sure"|125|0|active|In my tests, I pass in an iterator pointing to one past the end to the `insert` member function, and simply insert the element like I would with `push_back`. This test isn't flagged as a false positive, so I assume that this is the expected behavior.||1
kvv3p0r682t5yv|Valgrind Error|I do not understand when Valgrind shows a memory leak and tells me to look at specific test cases that I wrote. Shouldn’t memory leak errors come from the functions I wrote? I do not understand if the errors are coming from my functions or test cases.|80|0|active|Valgrind is likely showing you that the leak originated by a function called in a test case that you wrote. You can trace the Valgrind output to figure out what function in List.h may be creating memory that's not being deleted properly somewhere else.||0
kvv3n7u7pg57hn|Valgrind Error still|. I've been trying to change my front_pop based off this valgrind issue, as I asked about this yesterday, but I'm still a little confused on where this error specifically is. |7|0|private|in your pop_back function, if there is only node, last = last->prev would set last = nullptr, and dereferencing last in the next line to get last->next would give you a valgrind error. similarly, in pop_front, first_next would set first = nullptr if you only have one node, and first->prev would be a valgrind error as you are dereferencing a null pointer. ||0
kvv3jr4yyfc3mb|Valgrind error p4|Hi, can someone give me some direction on where to look to solve this valgrind error and what kind of memory issue it is? |6|1|private|@3173||0
kvv2g05ysey4xm|Operator&#43;&#43; Overload issues|"Hi! I'm trying to test my end() function (specifically, moving backward from the null pointer ""past the end"" to reach the last value in the list). However, my program doesn't seem to be using the operator++ overload, and just sets a null pointer when the iterator's ++ is called. With the debugger, I can confirm that the overloaded operator++ is not called at all on line 391.. . Here's the end() in question:. . . . And the operator++ isn't loading for some reason, so I'll copy some of the code over manually:. . . Iterator& operator++() {.       Node *temptr = node_ptr;.       if (node_ptr).       {.         node_ptr = node_ptr->next;.         if (!node_ptr).         {.           node_ptr = new Node();.           node_ptr->prev = temptr;.         }.       }.       return *this;.     }. . Any idea what I'm doing wrong?. "|8|0|private|The reason your Iterator::operator++ isn't getting called is because you aren't doing ++ on an Iterator - you're doing it on an Iterator pointer (Iterator *), so you're really incrementing a pointer rather than an Iterator. You've got a pointer because you're creating the Iterator as dynamic memory - should we be using dynamic memory here?. . Also, what would the value of the node_ptr within the Iterator be for an end Iterator? Can we construct the end Iterator directly with this value, rather than incrementing it?||1
kvv27lmcu7752|&#39;No test cases were submitted&#39; even with no additional public members in List.h|I have submitted different variations of my List_tests.cpp to no avail getting the test cases to even be recognized.|8|1|private|Looks like you've defined a `get()` function as part of the public interface of the Iterator class, and are using that in your submitted test cases. That function shouldn't be part of the Iterator class's public interface, and because we don't compile your List tests with your List implementation, you're getting a compile error on the autograder where it doesn't know what the `get()` function is when you use it in your tests. I would make that function private and remove any calls to it from your test cases, and make sure you aren't adding or calling any additional functions that shouldn't be part of the List or Iterator interface (basically the starter functions, the Big 3, or the operators we suggest you create)||0
kvuoh369uh4476|assignment operator and the copy constructor.|For some reason when I try to use the overloaded assignment operator it calls the copy constructor instead.. . Also when either the assignment operator or the copy constructor are called (I commented out the copy constructor to force it to call the assignment operator), the this pointer and the passed in parameters get replaced by garbage values. . . If anyone could help me with either issue it would be appreciated.|86|0|active|The overloaded assignment operator is only called if you're overwriting an already existing value.. . ```cpp. List list;. . List list2 = list; // Calls copy constructor. List list3;. list3.push_back(1);. list3 = list2; // Calls overloaded assignment operator. ```||0
kvultp1eqxo2ok|Address Sanitizer slippage|Hi I could really use some help figuring out this bug. . When I use my assignment operator, the new list's size becomes some huge(and random) int like 2321321321 or 192323213. This is not caught on address sanitizer though and I have no idea how this would happen.. Thank you for your help!|7|0|private|You do not have to reset the size yourself in your assignment operator function. This will be taken care by the copy constructor. I see that you are calling push_back in copy_all(), which already increments len when a new node is pushed back.||1
kvukj8hm6181by|push_back valgrind error|. Does anyone know what causes this Valgrind error? thank you.|63|0|active|"Your program likely lets a dynamically-allocated variable go out of scope before it has been deleted. With no way to access it, that chunk of memory has been ""lost"", and that's what Valgrind is catching."||0
kvuk297pm67ye|Overloading == operator|For the implementation of the == operator and the != operator, are we supposed to be comparing an iterator to an iterator (as in the node pointer), or the datum of the iterator itself? Any help would be great thanks!|79|0|active|The `operator==(const Iterator rhs)` overload compares `node_ptr`s between Iterators||0
kvujwx9a5m1ga|Iterators Not Accessing Private Members|Whether it be the spec or the slides in lecture, it says that Iterator should be able to access private members of the class, but it isn't. I honestly can't see any places where I accidentally put a bracket either to break up the class. Could so explain why this is happening? |63|0|active|Have you declared `List` as a friend class of `Iterator` in the private section of the `Iterator` declaration?||1
kvui8it7hrr34n|Total Bugs in AG?|We need to catch 21 for full credit, but what is the total number possible on Autograder?|91|1|active|Unfortunately we don’t typically release the total number of potential bugs, but you can continue to submit more test cases to test your code!||0
kvui3xyxlfk5r|Project 4: Are loops allowed in linked lists?|So, can there be a loop in the linked list for Project 4, as indicated in the image below?. . . . In other words, can we assume that the prev pointer of first and next pointer of last is always nullptr?. . . As in, this would cause ambiguity in the prev pointer of the orange node; hence, I feel this should not be allowed; however, I just wanted to double check whether I am missing any cases or not.|78|0|active|There will never be loops in a linked list, otherwise it wouldn't be a linked list it'd be a graph.||0
kvuhuk19g9z5bc|Push_back issue|"I'm getting a bug when I call push_back for the third time in a row. The first two times I call it, it works fine, but the third time, the push_back function allocates memory that has already been allocated by the second call, even though I am using the ""new"" keyword. The thing I find strange about this is that the issue seems to only affect one specific test case. I have another test case where I call push_back three times in a row, and it works correctly there. The two functions have identical code leading up to the push_back calls, yet one works and one doesn't. Anyone know what's up with this? Is this too specific of a question for Piazza?"|73|0|active|I am curious as to why you set your ptr1 to nullptr at the end of your push_back function.||0
kvuhjn5qeip1ez|Valgrind error for Student List tests on student List|Could someone help me decipher this valgrind error? Let me know if I need to post the full log.. . |59|0|active|Sounds like you tried to update the data behind a deleted pointer. Basically you have the following scenario going on:. ```cpp. int *ptr = new int(5);. delete ptr;. *ptr = 6; // Can't do this, we freed the object pointed to by ptr. ```||0
kvuhaib7pdz53j|Same test cases, different results on different machines|I and my partner have identical list.h and list_tests.cpp files (he got my version from git). When we run the test cases, he gets an all pass while I consistently get a segfault. I should mention that we also pass all test cases on Autograder. What might be wrong on my end? |84|0|active|When you see inconsistent behavior between machines, its usually the result of undefined behavior due to invalid memory accesses. This is probably what's going on, since from your autograder's valgrind output, you're getting `Invalid write of size 8` when your List implementation is run on your test cases. Even though it might not be saying that for your inconsistent test case, its still a likely culprit of your weird behavior and is the first thing I would fix. Specifically it looks like an issue in pop_back()||1
kvuh6hfswi65j0|running api.exe|"Hi! When I try to run this part of the setup:. . . $ make api.exe. c++ -Wall -Werror -pedantic --std=c++11 -g api.cpp -o api.exe. $ ./api.exe. hello from main!. I'm getting this output in my terminal:. . (base) 0587422346:p4-web lo$ make api.exe. c++ -Wall -Werror -pedantic --std=c++11 -g api.cpp -o api.exe. Undefined symbols for architecture x86_64:.   ""TestSuite::incomplete"", referenced from:.       TestSuite::run_tests(int, char**) in api-930d4c.o.       TestSuite::TestSuite()::'lambda'()::operator()() const in api-930d4c.o.   ""TestSuite::instance"", referenced from:.       TestSuite::get() in api-930d4c.o. ld: symbol(s) not found for architecture x86_64. clang: error: linker command failed with exit code 1 (use -v to see invocation). make: *** [api.exe] Error 1. . I'm not sure if there's just a library I need to be including or something like that, but I am hoping to fix whatever the issue is so that it doesn't cause any problems later on when running tests and such on the project. Thanks!"|70|0|active|I think you might be getting this error if you have `unit_test_framework.h` #include'd in your api.cpp file. Could you check whether that's the case and try removing it if it is there? There shouldn't be any problems with your List.h and List_tests.cpp files, but you should run `make List_compile_check.exe` and `make List_tests.exe` to make sure of that.. . Just wanted to make sure that you're aware that the api.cpp is optional for this project and not graded - you're totally free to work on it if you like though! ||0
kvugd7dhq0x4zw|Could any teacher please see my list compile check?|It shows a lot of errors but I don't know why.  Thank you!|10|0|private|There seems to be an issue with your pop_front and pop_back function. I also can't seem to find your copy constructor. I would also recommend keeping track of a private counter variable to keep track of the number of nodes in your list. ||0
kvufr3yur1v3ks|copy constuctor of list|can we do the following?. List<T>=i;. List<T> j(i);|70|0|active|The first thing there isn't valid syntax - you need to give the variable a name. The second one is valid assuming that `i` is of type `List`. It simply constructs `j` using the copy constructor of `List`.||0
kvuffnwbncx5gw|Test cases for Iterator functions|How are we supposed to write test cases for the Iterator functions without being able to access the iterator constructor that takes a node pointer as an argument?|105|0|active|You should call the `begin()` member function of `List` and then increment/decrement the iterator as needed.||0
kvufdoynj3oag|Dead Pointer?|"Trying to test push_front, have slightly edited it in many different ways. I think there is a dead pointer somewhere but really have no clue where/what it could be. I think I also have the same problem on push_back, pop_front, and pop_back.. . My default constructor. . push_front. . test case I'm trying. . edit: common errors include seg faults and "". malloc: *** error for object 0x7feb2c5040b0: pointer being freed was not allocated"""|9|0|private|When your list is empty, you have not initialized the to_be_pushed previous or next.||1
kvufcu0lnrju8|the update of iterator begin()|when we set an iterator to the begin() of an empty list such as that the iterator would be nullptr, after adding elements, do we expect the iterator automatically point to the first element or do we have to call iterator=list.begin() again tp update that?|66|0|active|no, you would need to call `list.begin()` again||0
kvuf1ebtf1r66u|push_back issue|IDE is throwing an unhandled exception for 'read access violation' of datum in my node ptr initialization. . . Node* n = new Node{ ______, ______, ______ };. . this format doesn't cause an issue in push_front however. |92|0|active|There's nothing wrong with that line specifically, so maybe it's the values you're creating the node with that are the issue? ||1
kvuei4pykm63aa|test end()|how are we supposed to test the end() functions since it is pointing to nullptr?|96|0|active|You can test that iterating through your list works properly (which is the main use for `end()`)||0
kvue8eb2dfq78t|Valgrind Error with Assignment Operator|Hi! In a test case for my assignment operator, I'm getting a Valgrind error:. ==79== 24 bytes in 1 blocks are definitely lost in loss record 1 of 2. ==79== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so). . The only reason I think this might happen is because my assignment operator creates a new list that is a copy and does not have the ability to delete the original list before assignment, but how would I change/fix that?. |88|0|active|Your assignment operator should not create any new lists nor use the `new` keyword, it should just copy all the data from the list on the right-hand side to the list on the left-hand side.||0
kvudvpp4rqz7f3|Default decrement not working|. All of my Iterator operation overloads are not working, not even the default decrementor. How do I implement these operation overloads? Right now I have the definitions inside of the public class definition. Should I stub them and write the definitions below the class like we did for List? And if that is the case how come the decrementor definition is inside of the class? Someone please point me in the right direction.|61|0|active|Where you put the definition (inside vs. outside the class) doesn't matter. What does matter is that for `Iterator` we're only implementing the prefix increment and decrement operators, meaning you can do `--it` and `++it` but you **cannot** do `it++` or `it--`.||0
kvudrl5h3a37mu|-- on a end pointer|If a iterator it is pointing at the end of the list (a nullptr), is it possible to get back to the last element by doing --it?|77|0|active|No, the requires clause for `operator--` states that the iterator must be dereferenceable, and the end iterator is not dereferenceable.||0
kvudp09e6i43fj|Error in pop_back()|I have an error where a pointer is being freed that was not allocated, but I am not sure what I am doing wrong in this function for this error to happen.. . Screen_Shot_2021-11-10_at_10.12.05_PM.png|9|0|private|Your pop_back seems okay, I think the error that you should focus on is valgrind timing out on one of your test cases (`empty_false`) because it's a relatively short test case so it's worth figuring out why it's just not ending.. . If you look at that test case, you really only call a few functions - just push_front and the List destructor (which calls clear() which in turn calls pop_back() which is why you're seeing pop_back come up in your valgrind error output). Pop_back seems okay, so it's probably push_front you want to check out - specifically the following lines:. ```. first =p;. p->next = first;. p->prev = first;. ```. You're setting first to be both it's next and previous neighbor - is this problematic/recursive and a possible cause for the time-out when you try and delete all of the nodes by traversing the list? ||0
kvudlpwafg34lf|operator&#43;&#43; not recognized when testing function|". This is the code for one of my tests for operator++ in Iterator. For some reason, the IDE is not recognizing the operator, even though I implemented it. Is it something to do with how I am incrementing the iterator ""it""? . I cannot think of a different way to increment the iterator; any help is appreciated.. Thanks!!"|6|0|private|The ++ operator you implement is prefix increment, not postfix. Try moving the ++ before!||0
kvucoetvu13kh|List Compile Check - no known conversion from List::Iterator|"We are getting so many errors with our List compile check file. We have the operators and the other functions like begin() and end() written in the List.h Iterator class, and they aren't giving any specific errors.. . The terminal statements all say that there is ""no known conversion."" Iter is not a boolean, and we understand that the boolean is checking if iter = iter2, so how do we get this to compile? Where in our code should we go to try to fix these bugs?. . Thank you!. . . "|124|0|active|Resolved in followups||1
kvucccqowj84s0|Valgrind issue|I know it's a memory leakage, but I'm not sure where it's located.. |70|0|active|It seems to be telling you that the error's occurring inside your `insert` implementation. You might not be stitching the list together correctly after you make the new node.||0
kvuc14136xe224|P-4 False Positives|"I'm writing test cases, and the Autograder says that some of them return false positives, but looking at my test case, I don't see how a correct implementation of List.h could result in one of my asserts returning an error.. . . This is one of the test cases that Autograder says returns a false positive, but I don't see how a correct implementation would. ""it"" is set to a nullpointer, therefore when I insert, it acts the same as doing push_back, inserting an element before ""past the end"". Then I check using a for loop if the inserts worked correctly."|9|0|private|Your test case looks fine to me, except for the last line where you explicitly call the destructor. See the faq post on destructors: @2779. Basically you shouldn't and don't need to call the destructor yourself because it gets called automatically when the test case ends and the variables go out of scope - shouldn't because your destructor will end up being called twice, once when you call it and again when its implicitly called. You should remove all explicit destructor calls from your test cases, which should hopefully fix most of these false positives||0
kvubudkaf6z49u|Double free error with pop_back|"When running the test for pop_back, I'm getting an error ""double free detected in tcache 2"". I'm only calling delete once in the function on the node I create. What could be causing the issue?. "|7|0|private|Remember that the List destructor also gets run at the end of the test, so it's possible the double delete is happening from there. I think the root cause of the double delete is from your pop_back implementation though - when you set the last pointer to last->prev (the second to last node before you delete), are all pointers on all nodes still valid? So first, last, and next/prev pointers on any nodes that have been affected by your update.. . I think it's really helpful to draw a picture with all the nodes, pointers, and first/last and go through your functions line-by-line to make sure all pointers are getting updated properly. Hope this helps!||0
kvubnm9rhhf6jx|valgrind error in student list tests on student list|. Hi I need help understanding what this error message means. I checked line 222 and it's a for loop so I don't know what could be wrong with it?. |7|0|private|The important line is `Invalid read of size 8` - it basically means you're trying to access memory that you shouldn't be, which is usually something like dereferencing an invalid pointer (a pointer that doesn't point to valid/allocated memory). In the stack trace, which is all that output printed below the first line, the error is actually stemming from line 214 of List.h, where you do `node_ptr->next;` - it likely means that node_ptr is not a valid pointer at this point.. . I think the underlying issue has to do with your test `test_iterator_erase_insert` - remember that when you erase an iterator it becomes invalid, so attempting to access it or update it using ++ (such as in a for loop) after erasing it would mean using an invalid iterator. Hope that helps! ||0
kvubcj63tvzf2|Copy constructor from empty list|Should we consider copying from an empty list when writing the copy constructor? |71|0|active|I don't think there's any indication that copying an empty list would break the interface, so you probably should||0
kvub3v5x7b320t|Valgrind Error|Hey guys, . I wonder what does this Valgrind error mean? What kind of error is that, and where should I make changes? . . ==79== Invalid read of size 42==79== at 0x4092DA: bool safe_equals_helper<int, int>(int const&, int const&) (unit_test_framework.h:293)3==79== by 0x4087C5: safe_equals<int&, int, void>::equals(int&, int const&) (unit_test_framework.h:323)4==79== by 0x407738: void assert_equal<int&, int>(int&, int&&, int, char const*) (unit_test_framework.h:333)5==79== by 0x4041EF: test06_copy_change_list2() (List_tests.cpp:112)6==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)7==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)8==79== by 0x4057AC: main (List_tests.cpp:344)9==79== Address 0x5abd120 is 16 bytes inside a block of size 24 free'd10==79== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)11==79== by 0x40797F: List<int>::pop_back() (List.h:297)12==79== by 0x404197: test06_copy_change_list2() (List_tests.cpp:110)13==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)14==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)15==79== by 0x4057AC: main (List_tests.cpp:344)16==79== Block was alloc'd at17==79== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)18==79== by 0x4075F1: List<int>::push_back(int const&) (List.h:247)19==79== by 0x404120: test06_copy_change_list2() (List_tests.cpp:104)20==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)21==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)22==79== by 0x4057AC: main (List_tests.cpp:344)23==79==24==79== Invalid read of size 425==79== at 0x4092DA: bool safe_equals_helper<int, int>(int const&, int const&) (unit_test_framework.h:293)26==79== by 0x4087C5: safe_equals<int&, int, void>::equals(int&, int const&) (unit_test_framework.h:323)27==79== by 0x407738: void assert_equal<int&, int>(int&, int&&, int, char const*) (unit_test_framework.h:333)28==79== by 0x4043F5: test07_copy_change_list1() (List_tests.cpp:134)29==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)30==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)31==79== by 0x4057AC: main (List_tests.cpp:344)32==79== Address 0x5abd360 is 16 bytes inside a block of size 24 free'd33==79== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)34==79== by 0x40797F: List<int>::pop_back() (List.h:297)35==79== by 0x40439D: test07_copy_change_list1() (List_tests.cpp:132)36==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)37==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)38==79== by 0x4057AC: main (List_tests.cpp:344)39==79== Block was alloc'd at40==79== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)41==79== by 0x4075F1: List<int>::push_back(int const&) (List.h:247)42==79== by 0x404326: test07_copy_change_list1() (List_tests.cpp:126)43==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)44==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)45==79== by 0x4057AC: main (List_tests.cpp:344)46==79==47==79== Invalid read of size 448==79== at 0x4092DA: bool safe_equals_helper<int, int>(int const&, int const&) (unit_test_framework.h:293)49==79== by 0x4087C5: safe_equals<int&, int, void>::equals(int&, int const&) (unit_test_framework.h:323)50==79== by 0x407738: void assert_equal<int&, int>(int&, int&&, int, char const*) (unit_test_framework.h:333)51==79== by 0x4046F3: test09_assignment_change_list2() (List_tests.cpp:167)52==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)53==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)54==79== by 0x4057AC: main (List_tests.cpp:344)55==79== Address 0x5abd600 is 16 bytes inside a block of size 24 free'd56==79== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)57==79== by 0x40797F: List<int>::pop_back() (List.h:297)58==79== by 0x40469B: test09_assignment_change_list2() (List_tests.cpp:165)59==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)60==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)61==79== by 0x4057AC: main (List_tests.cpp:344)62==79== Block was alloc'd at63==79== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)64==79== by 0x4075F1: List<int>::push_back(int const&) (List.h:247)65==79== by 0x4045E4: test09_assignment_change_list2() (List_tests.cpp:156)66==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)67==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)68==79== by 0x4057AC: main (List_tests.cpp:344)69==79==70==79== Invalid read of size 471==79== at 0x4092DA: bool safe_equals_helper<int, int>(int const&, int const&) (unit_test_framework.h:293)72==79== by 0x4087C5: safe_equals<int&, int, void>::equals(int&, int const&) (unit_test_framework.h:323)73==79== by 0x407738: void assert_equal<int&, int>(int&, int&&, int, char const*) (unit_test_framework.h:333)74==79== by 0x404939: test10_assignment_change_list1() (List_tests.cpp:192)75==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)76==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)77==79== by 0x4057AC: main (List_tests.cpp:344)78==79== Address 0x5abd900 is 16 bytes inside a block of size 24 free'd79==79== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)80==79== by 0x40797F: List<int>::pop_back() (List.h:297)81==79== by 0x4048E1: test10_assignment_change_list1() (List_tests.cpp:190)82==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)83==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)84==79== by 0x4057AC: main (List_tests.cpp:344)85==79== Block was alloc'd at86==79== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)87==79== by 0x4075F1: List<int>::push_back(int const&) (List.h:247)88==79== by 0x40482A: test10_assignment_change_list1() (List_tests.cpp:181)89==79== by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)90==79== by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)91==79== by 0x4057AC: main (List_tests.cpp:344)92==79==|112|0|active|"it looks like in a bunch of different test cases, you are attempting to access memory that has already been freed (""invalid read""). It says that the memory was allocated with new in `push_back` and was freed with `delete` in `pop_back`. Then, when you try to compare it using `ASSERT_EQUALS`, it can't compare it because the integer doesn't exist anymore. See if you're popping something that you shouldn't be somewhere in your `List` code, or if you made a mistake in your test cases and are trying to check the value of an element you popped out of the `List`"||1
kvuapb6dmyy563|Self-assignment error|I keep getting this error when I try to do . list_1 = list_1;. . List_tests.cpp:446:12: error: explicitly assigning value of variable of type 'List<int>' to itself [-Werror,-Wself-assign-overloaded]    list_1 = list_1;    ~~~~~~ ^ ~~~~~~1 error generated.make: *** [List_tests.exe] Error 1. . I have the operator= function checking for self assignment but I don't know if I'm doing it correctly.|79|0|active|from googling the error, it seems like Clang gives a warning whenever you self-assign a custom class (since that's something you usually don't want to do). I don't think gcc has this particular warning, so it should compile on autograder and CAEN. Maybe try commenting that test out for now and then test it on CAEN/autograder at the end?. . edit: also, self assignment checks should be pretty much the same for any class, so you can just check yours against an example in the lecture notes/slides||1
kvualp9c4mz4jp|where to implement the functions|I am really confused about where should I implement the functions. I think I finished all the functions and constructors and I write a lot test cases. Non of them passed. Where should I place those implemented functions? Outside of the list class but within the same file list.h?. . (the //list marks the closing bracket of list class). };//List. . template<typename T>. bool List<T>::empty() const {.     return first == nullptr;. }. . Please explain to me why are we doing this instead of a new cpp file. Thanks!. |64|0|active|There's an explanation in the lecture notes [here](https://eecs280staff.github.io/notes/12_Containers_II.html#compiling-templates). Basically, the way a compiler deals with templates is that it basically copy-pastes the template and replaces all instances of `T` with the typename provided. In order to do this, it needs the full templated definition for the function, so it all needs to be in a header file||1
kvu9pgdlgd16li|Weird Valgrind issue|. My code has passed every test except for this. So there are no more memory leaks but there are still 2 errors? . . . if I add the -s flag, I get this:. . so it says there are 127 allocs but only 50 free. The previous version of this code was fine, the only thing I added was changing the type from int to string so I am not sure where the error could have occurred. . . |49|0|active|It looks like the problem is valgrind is passing -s as a command line argument to List_tests.exe, which is then throwing an exception because it doesn't know what to do with -s. You should put the -s flag after `valgrind` and before the .exe name like `valgrind -s ./List_tests.exe`||0
kvu9ff7hd72|Valgrind Error|. How would I be able to resolve this valgrind error, I see it says there is a problem with my stack overflow.|75|0|active|I noticed that in your empty() function, you're doing: if (nullptr) {}, which will always result in false (you'll never enter your if statement).||1
kvu9eodwjts553|Test case segmentation error confusion|Hi, im a bit confused when testing my code;. . When I debug my test cases, everything is fine, see attached:. . . However, when I use the; make List_tests.exe , ./List_tests.exe, I get a segementation error:. . . . There are no changes to the code in between these two cases,. . Why is it that using the debugger everything works perfectly, but through the other method I am getting errors?|60|0|active|It could be that the compiler is optimizing away a copy that isn't being optimized when you run it with a debugger? Try using some print statements in your copy ctor to get a better sense of where the error is occurring||1
kvu93416io1wi|Private Iterator Constructor - use of undeclared identifier error|Why are we getting an error that p is undeclared? We declared it on the line right before it was used. . . (We based our private constructor off of what we did in the class lectures so I'm not sure where we went wrong.) |5|0|private|You have a semicolon at the end of line 155 that's not supposed to be there.||1
kvu8u726alc1d4|Erase function test, erase at end|I wrote a test case to see if my code works well when erasing an element at the end of a list. It runs perfectly against my list functions. But the autograder shows that it is a false positive. What is wrong with my test case? Thank you so much!. . Below is my test case:. .  . TEST(erase_end){.     List<int> list1;.     list1.push_back(1);.     list1.push_back(2);.     list1.push_back(3);.     // list1 should be {1,2,3} now .     .     typename List<int>::Iterator end = list1.end();.     list1.erase(end);.     // list1 should be  {1,2} now .     ASSERT_EQUAL(list1.back(), 2);. }|5|0|private|The iterator of the element you are trying to delete must be pointing to the element. In this case, your iterator is not pointing to '3' because end() returns an iterator one past the last element.. . One approach you can do to erase '3' is to initialize an iterator to begin(), then increment the iterator twice.||0
kvu8oqsh18v3pd|erase function test|I am writing a test case for my erase() function that tests deleting the last element in the list. . . I initialize a list contains {1,2,3}. Then I erase the last element. The list should be {1,2}. However the autograder shows that this test case is a false positive.. . Do I understand the erase function correctly? Or if there may be something wrong with my test case? There is no error in the tests when running against my list functions.  Thanks!|138|0|active|The iterator of the element you are trying to delete must be pointing to the element. In this case, your iterator is not pointing to '3' because end() returns an iterator one past the last element.. . One approach you can do to erase '3' is to initialize an iterator to begin(), then increment the iterator twice.||1
kvu83qfjryv4mi|Autograder error, no test cases submitted|"Uniquename: grantwms. . When submitting my code to the autograder, it says that ""No test cases were submitted"" when I actually have 33.. What's going on? Can someone help explain the issue?"|4|0|private|In your test_iterator_ctors() test, you declared an iterator called it2 that you never use in the rest of the function. This is causing a compile error on autograder.||0
kvu78zm4db928z|Solved.|Solved.|7|0|private|Solved.||0
kvu70daobf854o|Clear() function|For the clear function should we use Iterators to traverse through the list? I want to respect the interface as much as possible but I keep coming up with errors, would it be possible to use a pop function instead?. |71|0|active|Calling one of the `pop()` functions repeatedly is valid. Doing that will still give you an empty list.||0
kvu6qprdj9qk7|Autograder compiles but no output|. All of my tests compile, but there's no output? |51|0|active|If you look at your Valgrind output below you can see the output of the public tests. ||0
kvu6pr00a3b2ic|Style Check|Would removing the comments on projects have an effect on style checks?|60|0|active|If you have really long comments also the auto grader could flag those as long lines. To fix that just put comments on multiple lines. ||0
kvu6obcsz614am|Templating Test *still* fails to compile|I asked about this in @2945 but it didn't help solve my problem. I went through all my code and nowhere do I perform any operations to modify datum. I submitted to Autograder with a score of 42/42, but the template test still doesn't compile. Really don't know what to do at this point.|11|0|private|It looks like the issue is coming from your iterator == operator. In iterator, what should we be comparing to check if the iterator is the same? To clarify a little more, let us go with your current definition you have in your code:. . Let's say we have one iterator that points to a node at the front of a list that has value 100, and another iterator pointing to the middle of a complete other list to a node that also has a value 100. Under your code, this would return true. Is this the behavior you want?||0
kvu65bnod6k2ww|17 duplicate symbols|. Does this error come from how many files there are when I'm running tests? Will that effect if I put it in the autograder?|39|0|active|Make sure you're not trying to run more than one main in your build (test files contain mains).||0
kvu5daoomdm638|End() Testing|How can you test if the below Iterator points to a nullptr? . . List<int>::Iterator iter(my_list.end()); . . . |73|0|active|You can compare it to another iterator that you know evaluates to nullptr.||0
kvu57ei0ozx2a4|Xcode Error|I. . I'm trying to find where this error is in my code, because in my actual .h file it's not showing any errors.|34|0|active|Marking resolved.||1
kvu4a0gv6a25ip|Working with partners for Project 4|Hi, . My name is Chaitanya and I wanted to work with 2 people for Project 4. Firstly, I was wondering if more than 2 people can work in a group for P4 and P5, because I was planning to join a group that already has 2 people. Also, for autograder we've already submitted stuff, so I was wondering if it could be manually changed on autograder to add me to the group. That's what happened for P3, since I had already submitted to autograder, but after getting a partner, an instructor changed it manually so I could add my partner to my autograder submissions. . Btw, their uniqnames are: cullenye and jackyc. Thank you. |22|0|private|Partnerships in EECS 280 are for two people working together. Groups of 3 or more are not allowed, and per the syllabus, sharing code outside of a partnership is considered an honor code violation.. . I'm not sure if I understand all the details of the situation as you're describing it, but the students who are currently registered in a partnership are allowed to work together and submit the same code. You would not be allowed to turn in that code, or to use it to derive your own solution.. . If you have questions, it may be best to follow up with any of the course professors via email (we don't always check piazza as frequently as the course staff do).||1
kvu3oqbc7zs49u|&#39;does not name a type&#39; error|. what do these two different errors mean|40|0|active|This is almost certainly caused by a syntax issues earlier in your code - these errors are basically nonsense. Make sure to address the very first error the compiler gives you since it may fix subsequent errors.||0
kvu31hdqwun75j|Pop_front assert failed|Hi, I am currently working on my test cases and I'm running into a problem with my pop_front function. When I run my test it appears that the list in which I'm calling the function is empty, when it clearly isn't. Here is a picture of my pop_front function and the test I'm trying to run. I would appreciate any help.. |5|0|private|The problem is probably in your push_back() function. Make sure you are incrementing your counter that keeps track of how many nodes are in your list every time you push_back(). . . Also, you have some errors in your pop_front() function. You need to set your new first element's prev pointer to nullptr. You also need to decrement your node counter that keeps track of how many nodes are in the list.||0
kvu2bqukkbg6jf|dereferencable|how do you check if the iterator is dereferenceable?|113|0|active|an iterator is only dereferenceable if it refers to a valid list/node. one way to check this is by using breakpoints to see the underlying contents of an iterator. if you get a valgrind error due to dereferencing a 'null' iterator, you can run your code with valgrind (syntax: valgrind ./*name of file*.exe to better understand where in your code this error is happening. ||0
kvu1j0zd5c42ko|error: no matching constructor for initialization of &#39;TestRegisterer&#39; (when compiling list tests)|I am getting this strange error when trying to compile my list tests. I tried to exit vs code as well as restarting my computer per the advice of a gsi, but neither worked. Please let me know if anyone knows how to fix this.. |97|0|active|Resolved in OH||0
kvu1i6o5cbd5gw|Testing copy constructor of List|Is it a good idea to test the copy constructor by making a TEST(...) in which I define a function that takes in a List object, since that would be one scenario in which the copy constructor is used (passing in a List object by value) ? It feels weird to define a function within a TEST case to test for this copy constructor behavior.|81|0|active|I'd say a test like that may be out of the scope of the bugs we're looking for. ||1
kvu0y6dhgh06n7|iterator --|In my tests, I'm creating an Iterator and setting it equal to mylist.end() and then calling --iter to have the iterator point to the last node in mylist, which is throwing an error. Is this a problem with my operator-- or is that not supposed to work based on how the code is set up? (I fixed the issue by using mylist.begin() instead, just wondering if I have a problem in my operator function)|105|0|active|This is just how the code is set up. The `++` and `--` overloads require that the Iterator they are applied to be de-referencable, and since deferencing `nullptr` is undefined behavior, they can't be called on end iterators.||0
kvu09fzn3hf251|clear|So does clear work like pop_all, or do we also delete the nodes, which pop_all doesn't do.|5|0|private|Whenever you remove a node from your list, you should be deleting it (using the delete keyword).||0
kvtzw00ku683a7|valgrind error in autograder|Could someone help me understand this output message? I know it's referring to a memory leak, but does it give any information as to where?. . |91|0|active|Check List.h line 83||1
kvtz6l12kdu4f4|Valgrind error|Hi, my partner and I got this Valgrind error. We went to Office Hour several times but we cannot solve it.. Here's the code in our test:. . And here's our push front:. . By the way, we did not use the new keyword in our test.|15|0|private|Oh sorry, I was writing out this answer but it looks like you solved it! I'll just post it here anyways:. . Looking at your code, there's a few things you should look at, specifically with insert and erase:. 1. You shouldn't be updating the position of the iterator inside either of these functions. 2. You can't compare an Iterator directly to nullptr since its an object, not a pointer. . Hope that helps, but nice job figuring out regardless!||2
kvtxxfkrij42mv|List Constructor|For the list default constructor, I know what to set every private member variable to except datum, I know a straight answer can't be given but can I get an idea on how to initialize datum in the default constructor?|68|0|active|Remember that `datum` isn't a member variable of `List`, but rather `Node`. The only variables that `List` has are `first` and  `last`.||1
kvtxbdnk7qf4du|erase function|so if we delete a node, do we set node_ptr to nullptr? Also, if an element is deleted in the middle of a list, don't we have to stitch the list back together? for example, if node_ptr was between node 1 and node 2, wouldn't we have to reassign node1.next = node2 and node1.previous = node1?|127|0|active|You do not need to set `node_ptr` in the iterator to `nullptr` after erasing - it's implied that the iterator is invalidated. And yes, you will need to stitch the list back together if the erasure occurs in the middle.||0
kvtvjms5ryo2ay|Size Error|. I saw a couple other posts about size, and I know the RME mentions using a private member variable. I made a private member variable list size to keep track of it, but it's still giving me errors.|5|0|private|size is a const function, meaning you can't modify member variables like listsize and first||0
kvtups5fhu2za|problem about erase function|In erase() funciton, I am a kind of confused that whether we need to set the iterator.node_ptr to point to a new node after we remove the certain node.|101|0|active|You no not. When you call `erase` on an iterator, that iterator (and all iterators pointing to that node) are invalidated.||0
kvtu7fjyvq96xr|Erasing last element|Is the only way to erase the last element of the list to make an iterator pointing to the front and incrementing to the end? To my understanding, you can't erase from the back because list.end() points to the nullptr.|123|0|active|The list has a pop_back() function that we implement that will perform the action you're describing. We're responsible for implementing it, but it doesn't necessarily require an iterator.||0
kvts03muk1sjh|Exit 2|Hi, I met the exit 2 error again. could you help me to check what compile error I got?|5|0|private|Looks like you're using an Iterator function called `node()` that shouldn't exist in the public Iterator interface. Just a reminder, you should go through each public function in your List/Iterator implementation and make sure it was either included in the starter files or suggested in a comment, rather than submitting to the autograder||0
kvtrdmoxp531rv|Test Error|If i have the following code for a test:. List<int> l1; List<int>::Iterator itr;. itr = l1.end();. l1.pushback(100);. l1.pushback(200);. . if I did . cout << *itr;should this give me a value and if so how would this be because the end is a nullpointer|102|0|active|An end iterator is not de-referencable. `push_back()` should not modify an iterator's position in a list, so in your example de-referencing `itr` would cause an error, not return a value.||0
kvtr46a0h28hi|Error on same line no matter what|I am getting a segfault on line 136 in my program regardless of what is on that line:|40|0|active|Try make clean and re-make the .exe. The compiler won't update for changes you make, in code or in whitespace, without an updated .exe.||1
kvtqzan1dwr6m0|Project 4 compile error|"Hi, I am trying to get my List.h to compile, but I keep getting this error, and I do not understand what it is telling me I think that there is an error in my opperator== function, but I do not know what it is. The == operator is used in my =! operator function, so it is probably causing the errors in that as well. . . List_compile_check.cpp: In function ‘int main()’:List_compile_check.cpp:45:30: error: passing ‘const List<int>::Iterator’ as ‘this’ argument discards qualifiers [-fpermissive]           45 |     b = iter3 == my_list.end();      |                              ^In file included from List_compile_check.cpp:3:List.h:111:10: note:   in call to ‘bool List<T>::Iterator::operator==(List<T>::Iterator&) [with T = int]’  111 |     bool operator==(List<T>::Iterator &rhs){      |          ^~~~~~~~List_compile_check.cpp:45:29: error: cannot bind non-const lvalue reference of type ‘List<int>::Iterator&’ to an rvalue of type ‘List<int>::Iterator’   45 |     b = iter3 == my_list.end();      |                  ~~~~~~~~~~~^~In file included from List_compile_check.cpp:3:List.h:111:40: note:   initializing argument 1 of ‘bool List<T>::Iterator::operator==(List<T>::Iterator&) [with T = int]’  111 |     bool operator==(List<T>::Iterator &rhs){      |                     ~~~~~~~~~~~~~~~~~~~^~~List_compile_check.cpp:46:26: error: binding reference of type ‘List<int>::Iterator&’ to ‘const List<int>::Iterator’ discards qualifiers   46 |     b = my_list.end() == iter3;      |                          ^~~~~In file included from List_compile_check.cpp:3:List.h:111:40: note:   initializing argument 1 of ‘bool List<T>::Iterator::operator==(List<T>::Iterator&) [with T = int]’  111 |     bool operator==(List<T>::Iterator &rhs){      |                     ~~~~~~~~~~~~~~~~~~~^~~List_compile_check.cpp:51:30: error: passing ‘const List<int>::Iterator’ as ‘this’ argument discards qualifiers [-fpermissive]           51 |     b = iter3 != my_list.end();      |                              ^In file included from List_compile_check.cpp:3:List.h:116:10: note:   in call to ‘bool List<T>::Iterator::operator!=(List<T>::Iterator) [with T = int]’  116 |     bool operator!=(List<T>::Iterator rhs){      |          ^~~~~~~~make: *** [Makefile:39: List_compile_check.exe] Error 1"|87|0|active|Change your `operator==` to be declared as follows:. . ```cpp. bool operator==(const List::Iterator &rhs) const. ```. The reference you pass in should be const, and the member function should be const. The same goes for `operator!=`.||0
kvtqincvpqb138|Autograder List Test Templating|I notice there's a section on the autograder that is grayed out and is called list test templating, what is this testing?|71|0|active|see instructor answer @2945||0
kvtqbql5ee01ui|List_tests.cpp error exit status 2|"Hi, I'm writing test cases for project 4 and wrote a few tests and submitted it to the autograder, however the autograder says ""No test cases were submitted."" and displays exit status 2. I'm stuck and don't know how to solve this issue. "|178|0|active|resolved in followups||3
kvtqbpz0cpf1td|Valgrind Error|I have never used valgrind so I am going through the tutorial to set it up now thus I am trying to run it on my Project 1 directory. However, I am running into this error that is not letting me use valgrind. I am not sure how to resolve it and was hoping for some guidance. . . |6|0|private|Remember that you need to be running Valgrind on CAEN, so make sure you go through the CAEN tutorial first.||1
kvto3pwt3wa4rf|Unintented creation of prev pointer|Hi! I'm running into a very unusual problem when trying to implement my insert() function, particularly with the List_compile_check.cpp.. . Here's the snippet of testing code (added assert() statements are mine):. . . . And here's my insert() function:. . . . Currently, the insert() function seems to be working as intended. At the end of the function, the list, which was once empty, now contains a single element of 42, with null pointers to prev and next. This element is both the first and last.. . . . However, once this function finishes running and you return to List_compile_check.exe, the variables in my_list are different.. . . . For some reason, the Node now has a prev pointer. If you're curious, the prev pointer has two null pointers and a datum of 0. However, I don't understand how or why this pointer is changing. No other code has run here- this is the Variables list when the debugger is at line 38, before the begin() function is called. So why is the my_list in List_compile_check so different from the one shown within List.h during the insert() function?. . Since I very consistently check whether a prev or next pointer exists to affirm whether the Iterator is at the first or last index of the list, this appearance of a magical pointer is either causing a lot of errors, or is the symptom of another issue causing a lot of errors. I'd really appreciate any help.. . Edit: I submitted my most recent files to the autograder, if it would be helpful for you to take a look at it there.|11|0|private|Not exactly sure either why the prev pointer on first is getting updated here in your debugger, but there's a few things you might consider fixing first with insert. . One thing has to do with the effects of insert - see this post on what should happen to the iterator after you call insert on it: @2948. . The second thing has to do with inserting on the nullptr. In your implementation, you push_front if the iterator is pointing to nullptr, but more generally an iterator that points to nullptr is an iterator to just past the end - does it make sense to push_front in that case?||2
kvto3mfugb353v|end|what's the purpose of letting end() point at one past the end instead of pointing at the last node |84|1|active|"end() is basically used like the Iterator version of nullptr. since we can use nullptr as a ""sentinel"" value, or a way to check that something is valid, we use end() in the same way. it's just a semantic/design choice made by C++, and we follow it because all Iterators—whether for std::vector or for our List—should act the same!"||0
kvtnrmhfcr1xa|Address Sanitizer issue in Erase function|My partner and I were trying to test our erase function, specifically to erase a value in the middle of the list (deleting the ends of the list currently works) but we keep getting some form of the following error. What should we be looking for? We made sure to delete the node_ptr after we were done linking the previous and next nodes together. . . |103|0|active|"""Member access within null pointer"" indicates that you are trying to access prev/next/datum of a null pointer. usually this happens when you forget to check if something is null before you access it. adding some asserts where you expect values to be null or not null could help you find where things are going wrong!"||0
kvtmvkvhbdq6xi|deleting a node|When you delete a node what should the next, prev, and datum values be. Because if I delete my first node for example, and I step through the code, the values of node are still there and do not change. Does that mean it is not getting deleted?. . . . Specifically the first image is before calling the erase() function, and the second image is after I call erase(). I do not know why node_ptr remains unchanged, whether it has something to do with erase being passed by value. . . |109|0|active|when you delete a Node pointer, you should set the value of that pointer to nullptr||1
kvtlpifkgha2c2|&#43;&#43; goes to nullptr when running List_compile_check|I'm not sure what is wrong with my implementation of the * and ++ operators. When I run the compile check, it gets to line 56 then tries to dereference the nullptr, but I'm pretty sure it is not supposed to be the nullptr there. It fails the assert(node_ptr) in operator*(). . |6|0|private|iter should be pointing to the second node in the list at that time. Try walking through with your debugger to ensure that iter has the proper value and determine where it goes off track. It could be that a push back or insert didn't connect the second node properly to the first one, so the iterator can't traverse properly.||0
kvtlerg5y5y6zg|what get deleted when I use delete|If I delete a Node, would its prev and next also get deleted?. . (For example, say I have two objects in my list. I create a new Node victim, and I set it equal to first, which has a next that points to last. If I delete victim, would last also get deleted?). . Thanks!|127|0|active|Deleting a Node destroys its member variables, including `next` and `prev`, but not the objects they may point to.. . I think `delete` can only act through one level of indirection. If you call it on an address, the compiler goes to that memory location and just destroys what's there. If there are pointers stored in the memory getting deleted, it doesn't follow them to others addresses and also destroy what's there too. For example,. . ```. int* ptr = new int(5);. int** ptrptr = &ptr; // in memory: ptrptr ----> ptr ----> 5. . delete ptrptr; // ERROR: delete acts on the address pointed to by ptrptr, which contains a pointer that wasn't created using new. . delete *ptrptr; // OK: delete acts on ptr, which points to a dynamically-allocated int. ```||0
kvtie7ekg7w5g2|pop_front can&#39;t delete|Hi, my code ran into the error below. . . but when i tried to debug by stepping through everything seemed to work fine; until I get to the point of delete victim and the error occurs.  . I think all the variables (first, last, and their prev and next) are correct. Does anyone know what's causing the issue? Thanks a lot!!|7|0|private|This could be caused by a double delete. Ensure you're not deleting the new node in push front, back, or insert!@6, so we can search your code on the autograder if you can't resolve this.||1
kvt62uszfct723|Why are tests run alphabetically instead of the order they&#39;re written in?|Seems like it would make more sense to run tests for the most important functions first to make sure they work before you test functions that rely on them working properly. Like, I get that you can just comment out tests, but it's annoying :(|76|0|active|I believe it has to do with how the testing framework finds the tests, and alphabetical is just the default.||1
kvt5qhnmi2t7h5|No Test Cases Submitted error|Hi, on the autograder its saying I didn't submit any List Tests and has exit status 2.  Did not modify the public List interface except for adding default ctor and the big three, my id is rohung if anyone can look it up on the autograder, would like to know why it's not working.|101|0|active|This is because you're trying to compare iterators in line 237 of List_tests.cpp, but you can't do that because ASSERT_EQUAL doesn't know how to compare those types. I would recommend dereferencing them to compare (if that works in this situation).||0
kvt5a567th24sb|node_ptr weird issue|"My node_ptr private member variable declaration is underlined in green because ""Function definition for 'end' not found."" However, my end() is written and doesn't throw any errors itself. I am confused. I don't understand how end() would cause an issue with the variable itself even IF it wasn't implemented. "|78|0|active|You may have defined end() in the wrong part of your list.h file, or failed to scope resolve it. If it's causing errors in your tests, that would be another indicator to worry about, but if they run fine on your machine and caen, it could be a quirk of your ide.||0
kvt50qloqkd7gl|Iterator operator &#43;&#43; segmetaion fault 11|"I overloaded the ++ operator for Iterator with it changing null_ptr, however when it actually tries to run ""++iter"" in the public compile test. It displays a segmetation fault 11. . I'm assuming it's trying to access a value that does not exist, however I do not see why it would not be able to."|86|0|active|I would recommend running your code on Valgrind to see the errors, because they give line numbers and additional details that aren't seen locally!||0
kvt370l1ptb3e0|Testing private member functions|How are we supposed to test the private member functions of the List and Iterator classes if we can't access them from the List_tests.cpp file?|73|0|active|You're not meant to test the private member functions, you just implicitly test them by using the public interface.||0
kvt2fg2cr1m2ly|Error Test|. I was a curious why I was not able to call these functions even though I pound included them.|4|0|private|Remember that push_front takes in an argument (e.g. a number like you have for push_back). In addition, you need to tell it what list you want to add it to, by doing: lists.push_back(2). I would recommend looking back at the lecture slides for how to use lists, and let me know if you have additional questions!||1
kvt27i9ziri14r|Obtaining datum from middle of list|I have noticed while writing test cases that it might be useful to have the datum of an element in the middle of the list accessible. I don't think that there is a way to do this with the iterator functions we are given. Should I create a function to do so, or am I incorrect in this assesment?|111|1|active|"You are correct that there is no way to do this directly. The only way to ""get"" an Iterator that is associated with some list is by calling `begin()` or `end()` on that list, which point to the first and last nodes, respectively.. . Accessing middle elements with an Iterator is still possible though. Just create a first-element Iterator, repeatedly increment it until it points to the node you want to access, and then de-reference it."||1
kvt16v2mnnz5sj|Iterator variable|Should we add a Iterator variable as a private member variable to the List class?|86|0|active|To add to the student response in the follow up, the iterator is a public interface to work with your list. We don't have any internal iterators, but we give the user of our library the ability to instantiate an iterator if they'd like.||1
kvt0ozqzi4v1kp|Git status wont work|Hello  I keep getting this error and I'm having some trouble fixing it, does anyone have any tips on whats wrong? . |36|0|active|It's saying that the folder you're in is not a git repository, so make sure you're in the right folder. ||0
kvszuj1gonv68z|Exit 2|Hi, could you help me to check what compile error I got?. |5|0|private|It looks like you're trying to use the function is_valid, but it isn't defined anywhere - is this a function you implemented?||0
kvsznl4to6067e|Error squiggles|I am simply not getting any error squiggles in my .h file like I would a .cpp file. Is there any way I can fix this? I don't even get error squiggles for missing semi-colons.|44|0|active|Depending on your ide, @2856 may help.||0
kvszg3155ivk6|No template name &#39;List&#39;|. Anybody know how to fix this error? |47|0|active|It's a bit tricky to tell what's going wrong. Some things to try are to ensure you have the typename at the top of your list class, that you haven't accidentally edited any includes, and that you're scope resolving for functions that are implemented outside your class. If those don't work, stop by office hours, or submit to the autograder so we can look at the rest of your code (@6 add your uniqname, please).||0
kvsz9ojwel1ui|List_tests.exe Not Showing everything?|Hi, when I run my List_texts.exe function in terminal, I keep getting this result:. . I have written way more than these 3 tests, so I am very confused what went wrong.. Any help is appreciated; please let me know if you need to see anything else to figure out what went wrong!|33|0|active|If you have a segfault, or something else which causes your program to abort, then your tests will stop running after that occurs.||0
kvsyj13o7vt649|Insert and erase error|I keep on getting a segment fault error when doing insert and erase at the first element of the list and I cannot find what is wrong with my implementation.  I appreciate any advice. . . . . . . . |5|0|private|Ensure that push_front is setting the new nodes prev to nullptr, since that's what your insert is depending on to determine if you're at the front.||0
kvsydv7m11l3az|pop_back-double free|"I was testing my pop-back function i kept on getting a runtime error saying: ""free(): double free detected in tcache 2"" and I could not solve why since I don't think I am missing any values. The // indicates where pop_back was called. It was not there when I was testing it. Thanks in advance. . . . . . "|7|0|private|Make sure you're not accidentally calling delete on the new node you add in push front, back, and insert. This would cause a double free with pop back since the node has been deallocated already.||0
kvsxprs0aoq23e|Compile Error with the assignment constructor signature|". We are getting an error with the assignment constructor signature. Any help here would be appreciated :). . Error Messages:. overloaded function ""List<T>::List"" is not a type name. 'operator=' must be a member function"|92|0|active|"You have the scope resolution operator (::) in the wrong spot. You want:. . List<T>& List<T>::operator=. . The way to remember this is to ask yourself whether the name you are specifying was declared inside a class or not.. . Is ""List"" declared inside a class? No, it is a class, so the compiler can find the declaration without you listing a class name before it.. . Is ""operator="" definied inside a class? Yes, you declared it inside of the List class, so you should stick ""List<T>::"" before its use elsewhere. That tells the compiler where to look."||0
kvsxpf7sltt7gh|use of non-static data member|Would someone be able to explain this error to me? This is code from inside the iterator increment and decrement functions. Is the iterator not allowed to access the list private variables? I added a friend declaration of list inside the iterator private section.. . |47|0|active|Even though `Iterator` is declared inside of `List`, you're not allowed to access the member variables of `List` from within iterator, because in practice an individual instance of an iterator is not tied to the list it came from.||0
kvsxjeulr3u2zk|Why is IDE keep showing me this?||57|1|active|did you forget to implement the private constructor for Iterator?||0
kvsxg7dtqzt3d6|insert with a null iterator|If you insert an object to a blank list, should you update the iterator to point to the new and only node on the list? Or should it point to the end space (1 after the node)? . . I am curious because when I insert 2 things to a blank list, then I don't know if the iterator should be at the end or to the first new node (this changes what order the nodes are added bc they're inserted to the space before the iterator). . . This is also confusing because if the iterator is not reassigned, I can not do --iterator to move backwards. |170|0|active|The student answer has some good discussion on the topic, but to answer your question: no, you should not update the iterator to point at the new node in the list, the iterator should remain an end iterator (actually, you couldn't change it even if you wanted to, since insert() and erase() take in Iterators by value). ||1
kvsv96ulfzg3y9|Project 4 in a nutshell (not a question)|I think I made Valgrind upset :/. |98|10|active|||1
kvsuxdhagor1k4|Valgrind Issues and False positives|"Can someone check my last two submissions in the autograder? For the last one, it is saying that my test cases are showing false positives, although I went through what the actual results should be and they should be the same as what my tests are predicting.. . For my second to last submission, I don't understand what the valgrind error is under ""Student List tests on student List"".. . Any help would be appreciated!"|8|0|private|"Looks like the two problematic tests are `test_iterators_insert_general_and_edge` and `test_iterators_erase_general_and_edge` - do these tests pass when you run them locally? I would trace through them again and draw a picture with all the nodes, pointers, and iterators that you create and update them as you step through your test cases making sure to keep track of every single pointer. For `test_iterators_insert_general_and_edge`, are you sure that you're inserting 76 at the start of the list? Is iter still pointing to the start of your list at that point of the test? And for `test_iterators_erase_general_and_edge`, make sure you're not mixing up iterators between lists - this is one reason to cut down on the complexity of your test cases and make them bite-sized snippets of code that only do a few operations on the minimum number of variables needed to test the behavior.. . Regarding your valgrind error, the main part of it is:. ```. 168 bytes in 7 blocks are definitely lost in loss record 1 of 3. ```. You should interpret this as saying ""you've definitely leaked memory somewhere"" - the rest of the error shows the stack trace of where that dynamic memory was allocated (in the push_back and push_front functions) but that's only the source of where the memory that was leaked came from - it's not telling you exactly where the memory got leaked, which is what you need to solve. It at least tells you which test cases to look in, `test_list_assignment_operator_not_shallow` and `test_clear`"||0
kvsujy5lnle2z3|testing iterators|I'm a bit confused on how to test the iterator functions. From what I understand, you have to make use of the .begin() function, but then what? |161|0|active|You could construct a list with a few elements in it using `push_back`, then make an iterator, and assert that each element the iterator finds is equal to what you'd expect. You can also make sure that incrementing a copy of an iterator no longer makes it equal to the original value, etc.||0
kvsufh2gtdudg|Valgrind Insert|I seem to be having troubles with a memory leak in regards to my insert function. I use if/else statements to determine whether the node should be inserted at the end, beginning, or somewhere in between and create a new node within each possibility. I use a destructor for list that clears the entire list so I am a little confused on why I am not deleting something in the list. The error occurs when I insert a node at the end of a list.|5|0|private|If we're looking at the valgrind output on your most recent autograder submit, it's actually a little misleading. Valgrind's just saying your program is leaking memory, and that memory was first allocated in your insert function (so it's pointing to the source of the memory that was leaked, but not exactly where it got leaked). So the error isn't necessarily saying there's an issue in your insert function, although in this case I believe the issue is within that function.. . When you insert a Node at the end of the list, are you making sure to tie up all of the next/prev nodes to each other, between the old end of the list and the new node?||1
kvsu07yx3085i0|Where do we implement the Big Three?|Are we supposed to implement the Big Three inside the class or outside of the class, or is it up to us? |5|0|private|It's up to you.||0
kvst8k9wwjv2w7|insert question|I just want to make sure, should the insert function work for insert an element to the end of the list, just when the iterator is a nullpointer?|147|0|active|Yes, `insert()` should be able to add an element to the list if it is called with any valid iterator associated with a list (including an end iterator).||0
kvssvydker45qr|Constructing an iterator in test file|How would you construct an iterator at a specific position in the test file. I'm trying to create an iterator which has its node look at the last element of the list. I believe the only way you can do that is through the begin() and end() function, but the end function returns a past the end pointer. So technically does that mean I can only declare it with the begin() function?|77|1|active|I think that's the right idea. Because `begin()` and `end()` are the only two functions in the `List` interface that return an iterator, and `end()` returns iterators that you can't de-reference, if you want to work with an iterator that you are able to increment (and therefore one that is de-referencable), you have to start with a beginning iterator. ||0
kvssji6yoex5oj|iterator&#43;&#43; bug &#34;exception has occurred&#34;|I'm having trouble debugging this function. As you can see from the variables, it seems like my assertion should pass, because iter is equal to the last node in list. Anyone know what this error means?. . . |63|0|active|"list.end() should return an iterator that points ""one past"" the end of your list. From the pictures, it seems like the variable ""iter"" is pointing to a valid node in your list, not one past the last node, and so the assertion will fail."||0
kvsqjg9ss3236j|last-&gt;prev seems to just initialize to null|my pop_front is working because i can set a node to first->next, but my pop_back is not working. When I use the debugger tools it looks like the next nodes hold addresses, but the prev pointers only hold null. Not sure how to fix this.. |114|1|active|See follow ups.||1
kvsp0ibq1wt26b|List Private Templating Test not compiling|For some reason the List Private Templating Test isn't compiling for me. Does anyone know why this might be happening? By comparing to my older autograder submissions, I think the error is coming up in the erase function, but I'm not sure why it's not compiling. |20|0|private|See this post about why it might not be compiling: @2945 - the general idea is that when you compile a program that uses a templated container and inserts some type into it, your compiler generates an entirely new version of your templated code with the T's replaced with that specific type - importantly, it does this at compile time. So, when you write the templated code, you can do type specific operations on T, and its only at compile time when you try and use a type that's incompatible with those type specific operations that you'd get a compile error. This is all to say that you should avoid doing any type specific operations on T in order to have a completely general template.. . Marking this private just to give you some specific advice based on your autograder - you're totally right that it has to do with your erase function. In general, when you do:. ```. int x = 3;. assert(x). ``` . An implicit conversion happens from int to bool, but this implicit conversion isn't defined for every single type. In other words, I would find a different way to check whether this iterator is dereferenceable in erase. ||0
kvsov2mj8ky3bq|Testing Destructor|How am I supposed to test the destructor if it is something that is called after the end of the program?|137|2|active|If it's not working the way it's supposed to, valgrind will catch it and the test will fail as far as the autograder is concerned.||1
kvsnsjzf97c75g|copy_all|Why is our copy_all function in our private variables in list.h, how do we test for it if it's a private variable?|117|0|active|You don't have the option of testing `copy_all()` directly. I think your best strategy is to check that any List member functions or constructors in which you call it produce the correct behavior.||0
kvsnah6e5a172o|Segmentation fault 11|"Below is my current code for the push_back function. I have tried several different iterations but I always get a segmentation fault 11 error at the line indicated below. I really don't understand where this is coming from, as I still got it when I used the code provided in lecture, with minor modifications to incorporate prev. Thanks. . template<typename T>. void List<T>::push_back(const T &datum) {. Node *p = new Node;. p->datum = datum;. p->next = nullptr;. p->prev = nullptr;. if (empty()) { first = last = p; }. else {. //std::cout << ""break"" << std::endl;. last->next = p; //where error occurs. last = p;. . }. }"|7|0|private|Looks like a good structure for the most part, but I would consider drawing a picture of the linked list with all the nodes and pointers (first/last and next/prev for each node) to make sure you're setting everything you're supposed to be - I think you might be missing setting some pointers here to properly link up the new node with the rest of the list.. . As far as the segfault goes, it seems like the issue isn't related directly to push_back. Instead, I think you're getting a segfault on that line because you're trying to dereference an invalid pointer, in this case last (by doing `last->next`). Meaning last is already an invalid/nullptr by the time you get to this function and it probably didn't get properly set before this point, so you should look in every function up to this point to see why last is invalid. Hope this helps!||0
kvsn6sd7jnr5cm|return first element|for function of front() does this return the datum of that element, or the node it's self?|74|0|active|It returns a reference to the datum of the first node.||0
kvsmpfautoe641|Error|. . While running tests cases I get this error. Even when I am not using pop_front in tests cases I still get the error.. . Edit: it is when the list destructor is called that the error pops up because of pop_front being used in the list destructor.|9|0|private|If first = nullptr, then first->prev attempts to dereference a nullptr which is causing this error.. . However, in the pop_front function, do we want to create any new nodes?||1
kvsmn7x83p351|insert() edge cases|I am working on my test cases for insert and I was wondering how to insert an element if the iterator is a nullptr due to an empty list (such as assigning it = list.begin() on an empty list) versus how to insert an element if the iterator is a nullptr due to it being at the end of a filled list (such that it = list.end()). I would think in the first case I should insert the elements to the beginning of the list as to insert Nodes in front of the specified position and in the second case I should insert elements to the back of the list as to insert Nodes in front of the specified position. However, the iterator would be nullptr in both cases (unless I am not understanding something correctly), so how can I differentiate between where to insert these element?. . EDIT: answered in office hours|190|0|active|resolved in OH||1
kvsmcgg5ijz3tp|Tips for catching more bugs|Anyone have any useful tips on catching more bugs? I have 4 more bugs to catch and have gone through the RMEs numerous time to think of potential edge cases. Any tips?|173|3|active|There are lots of edge cases with small lists of zero, one, or two elements. Also, think about how different functions interact with one another. What happens if you push front and then pop back? What happens if you insert something, decrement an iterator, and then use that iterator to erase something?||0
kvslyldsma8580|Breaking the Interface of Iterator?|Is it breaking the interface if I use Iterator i->node_ptr outside of the Iterator class?|87|0|active|We defined List to be a friend class of Iterator, so it would not be breaking the interface when List accesses the private member variables of the Iterator class. This link contains a helpful explanation.||0
kvslouew5zs6o6|List_tests Assignment|"For the assignment operator, when I test if it works when we assign list into the same list (i.e. list1 = list1), I get an error in my terminal saying. ""explicitly assigning value of variable of type 'List<int>' to itself"". Should we test this, and if so, how do I deal with this error?"|174|0|active|That compiler error is just a warning that becomes an error because of the Werror flag. If you want to test this case, try something like this:. . . List<int> list1;. // insert code here to add to list1. List<int> list2;. List<int>* list_ptr = &list1;. list2 = *list_ptr;. . ||2
kvsliqeam3t45f|Iterator copy constructor|When writing the copy constructor for the iterator, should we link the new Node's next and prev with that of the other? or should it be entirely separated from the original other node?|161|1|active|I don't think `Iterator` needs a custom (deep) copy constructor to work correctly. Although they can play a role in dynamic memory when inserting or erasing list nodes, Iterators themselves don't really require the allocation or freeing of memory to exist. A shallow copy, which will set the new Iterator's `node_ptr` to the same value as the Iterator you copy from, should be sufficient, and not produce unwanted behavior.. . Take the following example:. . ```. List my_list;. . //. // add some elements to the list.... //. . List::Iterator it1 = my_list.begin(); // it1 points at the first element in my_list. List::Iterator it2(it1); // it2 is a copy of it1, their node_ptrs are equal. . it1++; // increment it1, it2 *still* points to the first element of my_list. ```||0
kvsinh0k1qu1ff|dereference operator|In the iterator class should the overloaded * operator return a node or a node pointer?|94|1|active|The overloaded * operator should return the datum of the node pointed to by the iterator. The return type and function signature should look like this:. . T & operator*(). The return type of the function should be T, where T is the type of the datum that the nodes in the linked list hold.||0
kvsgso7h87myl|copy constructor list|when making the copy constructor for list should we be still be setting the first and last to null or should we be setting it to the other lists first and last?|153|0|active|You don't want to set them to the first and last of the other list, that's performing a shallow copy, not a deep copy. It may be a good idea to start with the list in an empty state, and copy over the elements from the other list one-by-one into the new list.||1
kvsgqfkmjfg3dl|Double free|"I am getting the following error when running one of my test cases: ""free(): double free detected in tcache 2"". The test case involves the copy constructor: . . . TEST(test_copy_ctor){.    List<int> testList;.    testList.push_back(1);.    testList.push_back(2);.    testList.push_back(3);.    testList.push_back(4);.    List<int> copy_list(testList);.    ASSERT_TRUE(copy_list.front()==1);. }. . . I've been tracing the code of the copy constructor, and I still am unable to figure out how to fix this error. This is the trace of the code: . . //COPY CONSTRUCTOR. . . template<typename T>. List<T>::List(T &other).   : first(nullptr), last(nullptr), listSize(0) {.     copy_all(other);    //copies nodes from other. }. . . . //COPY_ALL FUNCTION. void copy_all(const List<T> &other){. .     //traverses through and pushes back node with data given by other List.     assert(empty());.     for(Node *np = other.first; np; np = np->next){.       push_back(np->datum);.     }.   }. . . . . //EFFECTS:  inserts datum into the back of the list. template<typename T>. void List<T>::push_back(const T &datum){.   Node *p = new Node;.   p->datum = datum;.   p->next = nullptr;.   if(empty()){        //if list is empty.     first = p;.     last = p;.     p->prev = nullptr;.   }.   else{             //if list is not empty.     last->next = p;.     p->prev = last;.     last = p;.   }.   listSize++;. }. . . . Am I doing something wrong in my copy code?. . "|4|0|private|Its hard to say without a debugger active, this question is better suited for OH, or can you provide some specific reasons you think you have an issue in your code. ||1
kvsgliqcunw73e|Operator overloading syntax|I've been struggling with the syntax for operator overloading. In particular, I'm trying to get the List_compile_check.exe to work, but I still have the red squiggles and VS Code isn't giving me any indication of what's wrong. I assume that I'm making some mistake with the syntax, but I don't know where to look.. . Here's my code:. . . . And even though I'm sure you can imagine, here's the List_compile_check code for example:. . |8|0|private|You might be able to get more helpful feedback from your compiler by trying to compile List_compile_check.cpp - I would try to use that as your source of truth in general, since your IDE isn't always great in every situation at identifying issues and telling you what's wrong. . . For the most part, it looks like you might be missing consts on some of your Iterator operator overloads, where the iterator itself shouldn't be modified (that would be a const right after the overload definition). Also, I think you want to implement the prefix ++ operator rather than the postfix - if you have (int) as a parameter to your operator++, it'll be overload the postfix operator instead. Looks like you're almost there though, so hope this helps!||1
kvsgkaqvdr9473|Project 4 gitlab|Hello, i am having troubles with connecting to gitlab both through the  https://gitlab.eecs.umich.edu/ link and through push or pull in vscode. Is the website down?|56|0|active|Seems to be up now. ||1
kvsfy9eywsesg|says No Test Cases Submitted|When submitting to Autograder, it says I didn't submit any List Tests and has exit status 2. I did not modify the public List interface except for adding default ctor and the big three. . |248|0|active|"@6, To help answer your question we sometimes look things up, which often requires a uniqname. To save time, and thus allow us to answer your questions more quickly,please make a small setup change to Piazza. Go to the upper right corner, next to your name, and click on the gear there. Select Account/Email settings. On the screen that appears, after your ""Full Name"", add your uniqname in parentheses as shown below."||7
kvsfsi4q1r26ck|calling copy constructor killed|. . . I passed the tlist by reference but it killed. . Thx for help. |99|0|active|Remember that for the copy constructor, we don't necessarily want to copy the pointers, we want to copy all the data so that we have to copies of the same data that aren't linked together. I think the reason your program is getting killed is that this version of the copy constructor is causing a double-free when the copied list dtor is calles.||1
kvsfqk40iaq6xg|seg fault on student test|. I keep getting a segmentation fault. Is there anything wrong with this test case? I can't seem to figure out whats wrong in my list.h. . I am not getting a seg fault in the compile check which basically has the exact same thing.. If I comment out the my_list.push_front(42) it works. . . . List(const List &other) : list_size(other.size()), first(nullptr), last(nullptr) {.   copy_all(other);. }. . . . . TEST(copy_ctor) {.     List<int> my_list;.     my_list.push_front(42);.     List<int> my_list1(my_list);.     ASSERT_FALSE(my_list1.empty());.     ASSERT_EQUAL(my_list1.size(), 1);. }. |7|0|private|On thing that I noticed about your push_front implementation is that it doesn't set the Node *last to anything, which means Node *last will always point to nullptr whenever you use push_front.||0
kvsdvi8yr5m6ad|No test cases were submitted autograder error|Whenever I submit my List_tests.cpp I just get the error No test cases were submitted with exit status 2. My tests all pass when I run them via the command prompt and there are no valgrind errors. How can I fix this problem?|88|1|active|Please follow @6, otherwise we cannot look you up on the autograder. ||1
kvsdfzp1ne5zl|pop_front address sanitizer error|Hi, I am getting an address sanitizer error on my pop_front function on line 288 that I can't seem to debug. Any tips or help would be appreciated|7|0|private|You do not ever delete anything if length is 1. ||1
kvsaifbmfg4y4|Valgrind Error: `GLIBCXX_3.4.26&#39; not found|Not really sure what's going on with this error. I tried a solution from a previous post @1373, but it didn't help.. . |71|0|active|Did you recompile List_public_test.exe after you did the module load? It seemed to have worked for this student: @2951||1
kvsab9d7er046f|Confused why test is getting false positive?|. I'm pretty sure it has something to do with the erase (loop?) because I changed 'test_iterator_erase_insert' to add the code from 'test_iterator_erase' to confirm what I thought the problem was. But I'm not sure what I'm doing wrong??. . |6|0|private|I believe the issue has to do with invalidating the iterator when you erase, which is causing problems with the `ASSERT_TRUE` on line 203 in some way on the autograder. Whenever you erase an iterator, you're erasing the underlying node - however you would need information from that node when you increment the iterator in the loop (in order to go to the next node). So I think we're running into undefined behavior. I would consider another way you can test erase without trying to use an invalidated iterator ||0
kvsa3urat4r33w|default constructor for iterator|Do we have to provide a default constructor for iterator like Iterator(){ptr_node(nullptr)} or it is enough to only use the one in the private interface?|126|0|active|You need to provide a public default constructor.||0
kvs9xo907m15qt|Test copy_all()|Hello,. . Am I supposed to test copy_all directly (this function is declared private, so it's not part of the interface; when testing, we are testing interface, I suppose)?. . Thank you!|5|0|private|No, copy_all() is a tool to do a deep copy of a list.||0
kvs9rvzmj9b50q|What does this valgrind error mean?|I'm not sure what this valgrind error means. I don't think there's an issue with my back() function, but I could be wrong. Could someone help me out?. . |125|0|active|"You can interpret `invalid read of size 4` as saying ""You're trying to acccess 4 bytes of memory somewhere that you're not supposed to"" - the size/number of bytes could be helpful in figuring out what's going on, but the main issue is that you're accessing memory somewhere that you shouldn't be. The important part of the next chunk of text is `Access not within mapped region at address 0x10` which is just reiterating that you're accessing memory that you shouldn't be.. . I would examine all the operations you're doing in test_back() to see whether you're dereferencing an invalid pointer somewhere, since that would be a pretty likely cause of this error. One situation could be dereferencing a Node pointer that you deleted - the pointer still has the old address of the object on the Heap (so you can dereference it), it's just not a valid address to access since that object has been deleted"||0
kvs9nh15b6s34b|private member variables|Am I allowed to add private member variable to the list class? I can't find anything that says one way or the other|56|0|active|@2828||0
kvs9fz2l5na69n|Compile Errors|. . . I've been having some issues with these. What do these errors mean? I know they tell us if our code compiles, but I don't know how to specifically fix them. Some of the errors go away as I change code, but I'm not sure which functions to focus on to fix these.|6|0|private|It looks like you've defined the List constructor, assignment operator, and destructor as private - make sure that wherever you'd defined them in your List class, they're underneath `public:` so you can access them outside of the class. Most of the List member functions such as empty() and size() are public, while the Node class and member functions are all private, if that helps identify where you should put these functions so that they're public||1
kvs73yjqjn02gb|List destructor issues|Hi!. . I'm writing tests for the List class and, for some reason, the destructor is being called at a point (line 82) and I can't figure out why.. . . . I can provide the solutions to my other functions but I believe the problem is here. After line 82, the program reaches a segmentation fault. When I debugged, I found that the List destructor is being called after 82 and before 84- but I really have no idea why that would be happening. The back() function doesn't declare any local variables, it just returns the back Node's datum, so why would the destructor be called here?|7|0|private|I'm not sure exactly why you're seeing the destructor being run, but my guess its happening after the segfault (where your program is potentially cleaning up all of that memory after the error). I would be more suspicious of a_list.back() - you mention you're just getting last's datum, but are you sure that last is a valid pointer at this point in your test case? Could that be a nullptr?||0
kvs64l2wlb62jl|copy_all function help|When we are writing copy all and other similar functions, how would we access the datum for each node from the other list in order to copy them over?|155|1|active|"Try using the push all function described in ""the big three"" lecture slides(lecture 16). "||1
kvrqfkcth0f3v3|help with push back|Hello, I am having trouble with the push back function. I feel like I am covering both the empty and element filled cases but keep getting a segmentation fault on the case where I try to add the first element to the list. Could I get some assistance on where I am going wrong? It would be appreciated.. . |7|0|private|Your logic looks good to me - have you tried stepping through with a debugger and seeing exactly which line things are going wrong at? It's possible something else is going wrong, maybe in your empty() function or somewhere else entirely, and your debugger can help you figure out where||0
kvrnl0jv94l5ah|Operator -- const error|I'm getting an error because Operator-- is marked as const, and also trying to modify node_ptr, with       node_ptr = node_ptr->prev;. I haven't changed it, and it also says that I can't change it in the spec. What am I supposed to do here?|99|0|active|The unchanged function signature I had from the starter file is. ```. Iterator &operator--() {}. ```. . Are you sure you didn't change anything?||1
kvrn3er2pph43f|valgrind errors|I'm consistently getting valgrind errors for this particular iterator test case and it seems to be with my push_back and pop_front functions. This problem doesn't appear for the other test cases, so I'm guessing there is something wrong with my iterator class. I was advised in office hours to make a private post regarding this problem. I have attached a screenshot of the valgrind error and any help would be greatly appreciated.. . |4|0|private|"Make sure for every ""new"" you use, you also pair it with a ""delete"""||0
kvrmkeh07go252|push_back issues|I'm currently debugging List_compile_check because I was getting a segfault in push_back, and I noticed that when I create a new Node in push_back it gives it the same address as the node already in the list (first), which I'm pretty sure is causing some problems. Does this have to do with adding a delete in push_front (as that's called right before push_back in this case), or is there some other reason? |77|0|private|Making this post private, per @6 please don't publicly post large chunks of code on piazza (even though it is essentially the code from lecture) - implementation specific questions should also generally be private or handled office hours.. . As far as your push_back implementation goes, remember that the linked list from lecture is singly linked (pointers only going one way) while the linked list in this project is doubly linked (pointers going both ways). It looks like you're only handling the next pointers, but Node's also have prev pointers that you need to handle too. If the segfault is happening at last->next = n, then you can be pretty sure that the last pointer isn't set properly there (meaning it's either nullptr or invalid) - in your test case, you should figure out why it's invalid at this point based on the previous operations leading up to this push_back. Hope that helps! I also recommend drawing pictures of the linked list with all the pointers so you're remembering which pointers need to be updated.||1
kvrmfeey1zu3hp|The end function|I am kind of confused as to what the end function should return, is it an iterator pointing to the last element or an iterator pointing to one past the last element, which is a nullptr?|102|0|active|one past the last element||0
kvrlwrkb9wt5af|Private Templating Test|Hi my code compiles fine and I have found all bugs and what not. Is it possible you can let me know why the Private templating test failed.. My uniqname is dmalis. |7|0|private|Take a look at this post which talks about the private templating test: @2945 - basically, make sure you aren't doing any type specific operations on any variables of type T. I would follow some of the recommendations from that post regarding test cases too ||1
kvrlfefgshi4r3|Undeclared identifier|I have list.h included and I have tried trouble shooting every other option but I don't understand why I am getting this error maybe I am just calling the iterator wrong.. . . |68|0|active|The `Iterator` class is declared inside the `List` class, so you need the type to be `List::Iterator`, where `T` is whatever type `dmt` is||0
kvrl7hy7xiq36r|Testing error: tests not working|Hello, I was having an issue with my tests and have not been able to fix it. I am not quite sure what is wrong. Can I please have some assistance with this? . . Here is the private post with my code and the errors. . . . |7|0|private|Resolved in this post! @3007||1
kvrkn9aplud5iw|Deleting Node from erase()|"In my erase() function, after reassigning all other necessary pointers to their new values, my last step is to delete the Node itself. I'm trying to use delete i.node_ptr; to do so, but I am getting an error that says ""pointer being freed was not allocated"". Am I supposed to use delete i.node_ptr; to delete the Node, or is there some other way that won't give me this error?"|216|0|active|Is this error coming from a public test or your own? If `i` is a valid, dereferenceable `Iterator` (as the REQUIRES clause says), you should be able to use `delete` the way you did. It's also possible you may be running into an edge case with the front or back of the `List`||0
kvrk4i1uvo1758|Valgrind errors push_front and push_back|. . We have already implemented a destructor for list and iterator and are wondering where these memory leaks could be coming from.|141|0|active|Your destructor probably only deletes `Node` objects that are still in the `List`. Maybe you aren't properly deleting them in your pop and erase functions?||0
kvrk1yxa6gw42v|using ASSERT_EQUAL|. . . I'm getting this error in my testing when I try to use the ASSERT_EQUAL or ASSERT_TRUE statement. I'm trying to test the front and back elements of pop_front() and it seems to only pass when I use assert(). When I use, ASSERT_TRUE or EQUAL, I get this bad access error in my pop_front function. I already put break points in to ensure the error is not coming from pop_front(), and it looks like it is coming from the ASSERT because when I step into it,it then leads me into the bad access error.|5|0|private|Looks like I fixed the error||0
kvrj8hxktdwzg|free(): double free detected in tcache 2|Hi! This is a bit of a long post, but not a complicated question. I hope. So, my partner and I are currently writing tests for p4. When I try to run a test on insert, I'm getting this error:. .  . . The test itself is as follows: (And I've found exactly which line is causing this error, it's been commented). . TEST(test_insert_basic) {.     List<int> my_list;.     my_list.push_front(42); // 42.     my_list.push_back(43); // 42, 43.     my_list.push_back(50); // 42, 43, 50. .     // iter location represented w/ ().     List<int>::Iterator iter = my_list.begin(); // (42), 43, 50.     ++iter; // 42, (43), 50.     .     my_list.insert(iter, 100); // 42, 100, (43), 50 (THIS IS WHAT IS CAUSING THE ERROR). .     ASSERT_EQUAL(my_list.size(), 4);. .     --iter; // 42, (100), 43, 50.     ASSERT_EQUAL(*iter, 100);. }. And our code for insert is. . void insert(Iterator i, const T& datum) {.         if (i == first) {.             push_front(datum);.         }.         else { .             Node* p = new Node;.             Node* a = i.node_ptr;.             p->datum = datum;.             a->prev->next = p;.             p->next = a;.             p->prev = a->prev;.             a->prev = p;.             delete a;.             ++list_size;.         }.         .     }. I turned to Google when I first saw this error, and I saw in one case, that the person who had this had failed to make the big 3. (At least, the copy ctor and assignment operator. Also note, this was not the same project. It was a random array function somebody was asking about on stackoverflow.) Our iterator class doesn't have those, but based on the name of this private case...  I now imagine we'll be implementing them.If you'd be able to look over this test+function to help determine if there's another reason as to why it's failing, that'd be great! We made a chunky iterator-based test that I'm now splitting into lots of small ones, since we got a false positive on our autograder submit. (That's a whole other can of worms though, since we commented exactly what should be happening step by step. Didn't expect false positives.)If it is indeed a Big 3 error, any tips for working on those with iterator would be awesome. Our List's Big 3 is in snug, but Iterator's is a bit daunting.Thank you!|4|0|private|Think about whether we should be deleting anything in insert||0
kvrj4l92xn66jf|Do iterator tests count towards the list bugs we must find?|I have only 11/21 bugs found, what functions count towards the bug count? I spent a lot of time testing the iterator operators but I only found one more bug. |234|0|active|Iterator tests are needed to get 21/21. Like in previous projects, you should test all functions that you made including every iterator operator, insert, erase, begin, end, and even the default constructor. Same goes for the list functions.||0
kvriz7is2psw1|Error when trying to use size variable and function, am not sure how to solve the issue|‘int List<T>::size’ conflicts with a previous declaration. . This is the error that comes up when I try to use the size variable. I am not sure how to fix it as I already separated the function size from the class and am using function stubs outside the class for the functionality.. . Any help would be appreciated!|75|0|active|I assume your problem is that you're trying to keep track of the size of the list with a member variable called `size`. The problem is that there's already a member function called `size`, so you have the same name for two different things. You should call the member variable something else, like `num_elements`||0
kvrixyobm2rzg|Iterator ctor that takes in Node* pointer|"My partner and I had the same error as @2932 and implemented an Iterator ctor that takes in a Node* as per @2932_f1 , but it hasn't fixed the issue and we're stumped and would appreciate any hints.. . Our ctor is. . Iterator(List<T>::Node *p);. . . The error code:. . Undefined symbols for architecture x86_64:.   ""List<int>::Iterator::Iterator(List<int>::Node*)"", referenced from:.       List<int>::begin() const in List_compile_check-f476e8.o.   ""List<int>::List()"", referenced from:.       _main in List_compile_check-f476e8.o. ld: symbol(s) not found for architecture x86_64"|6|0|private|Try removing List<int>::Node *p and saying just Node *p instead. If that doesn't fix the issue, feel free to followup.||1
kvri66haebf2cy|autograder test case exit status: 2|. . Hi, we have some trouble related to the testing case. I do not know how to solve this problem|77|2|active|"A common error is that you have modified the public interface of List (ex: you made a public helper function in the List class). While this might compile on your machine and caen, autograder doesn't accept this. It says under ""Requirements and restrictions"" in the spec that you're not allowed to modify the public implementation of List."||1
kvrhuo1jyvg2zx|What is the point of the list compile tests?|Are the list compile test supposed to work after all of list.h is done?|74|1|active|Yes, including your implementation of `Iterator`.||0
kvrhjiya85t5c3|Help with push_back|When I try to access last->next for last->next = p in push_back I get this error. runtime error: member access within null pointer of type 'struct Node'. Any help would be appreciated.|98|0|active|Student answer is almost correct, though I think they meant last rather than next. ||1
kvrgundrnbk6tq|How do we know an iterator is valid for a empty list|I was writing insert and met some problem. If we create an empty list and insert element into it by iterator. . For example,. .     List<int> tlist;.     List<int>::Iterator i = tlist.begin();. iterator i is the begin of an empty list, so it is a nullptr. In the insert function, how can I know that the iterator is valid?. . |128|1|active|"The RME requires that ""i is a valid iterator associated with this list."" You do not have to worry about whether or not the iterator is valid. You just have to know that it will be nullptr if you're trying to insert into an empty list."||0
kvrggf1itjl2jj|insert() at end of List|Should the insert() function be able to insert an element at the end of a list? If we are able to insert at the end of the list, is there an way that we could use -- to move to an earlier part of the list (I would think not because the assert statement ensures the node_ptr isn't a nullptr)?|141|1|active|Because the `operator--()` overload requires that the Iterator it gets applied to be de-referencable, using it to decrement an end iterator, whose `node_ptr` will equal the null pointer, is not an option.. . I think your basic idea is correct,though. `insert()` will need to check for and potentially execute differently when passed an end iterator, because it can't just de-reference and re-assign some node member variables in that case.||0
kvrfss9059q52s|List Default Constructor|If we create a default constructor for List, are we allowed to make it public? I made mine private so it wouldn't change the public interface, but then it became inaccessible from the test files.|144|0|active|Adding default constructor to the public `List` interface is allowed, I think the starter files specify that this is allowed around line ~50.||0
kvrfspxusnm541|Private member variable declarations|hello, I am having an error in the autograder with my first, last, and size private member variables. The autograder says that the code does not have the member variables as a part of List, but they are there in my code. Could I have some help with this?. |7|0|private|I think I answered this in your other piazza post: @3007 Let me know if you have any questions though!||0
kvrew3iot3z4pn|#includes Erroring|Error: Activating the Pull Requests and Issues extension failed. Please make sure you have git installed.. . git version on Ubuntu: git version 2.25.1. . I am having an error that is preventing me from being able to use the #includes. I am not sure how I can fix this, or what is causing it. I have linked my file below.. It is preventing me from being able to run the list.h file. if it is an error in my IDE how can I fix this? . . List.h. |7|0|private|"Based on the error you gave, it doesn't seem like an issue with your code/any #includes - it looks more like an issue with a git extension you're using (I think with VSCode, if that's your IDE?). It's a little hard to debug through Piazza, so I'd recommend going to office hours. . . If it's preventing you from working on the project entirely, one option might be to reinstall the extension (which you can do from the extensions page by clicking the button on the left-side of VSCode that looks like a bunch of squares and looking up ""github issues""). Or, you can uninstall it entirely if that's not working, and use git from the command line"||0
kvresjb3v228r|General Question|Can erase be called on an empty list?|146|1|active|One of the requirements of the erase function is that the iterator i passed in as an argument must be dereferencable.  So erase cannot be called on an empty list.. . The insert function has no such requirement.  So insert can be called on an empty list||1
kvrdb8eity28e|Project 4 - Paper Code|Dear EECS 280 Instructors, . . My computer has swollen battery for a while now and the battery is still expanding. I try to fix it about 2 weeks ago. I went to IT Campus and after they check the serial number they can't order any replacement battery because the computer is manufactured and bought outside the US. I also try to rent the campus computer and I am currently on the waitlist for a week with no news.. . I try to find the battery on eBay last week according to the recommendation from my EECS 280 lab GSI and I also went on IT Campus again for help buying the battery on my own but I haven't found luck to find the exact battery for the computer. . . At first, the battery just made the keyboard go upward but now it has expanded, crack the base, and the base is near to falling off. I ordered a new computer already but they are not coming soon. . . I am very scared to use my computer now because I have heard from multiple people (including my family) and read about the swollen battery exploding. I am currently cannot both charging the computer and doing work because it might increase the risk. I don't know what my computer limits it but I hope I can use it before my new computer arrives. Currently, I am mostly working on on-campus computers and it has decreased my work efficiency. . . I want to ask if I can work on project 4 code on paper? . . Thank you!. Best regards, . Nam|21|0|private|Hi Nam, sorry to hear about your issues with your computer.. . I think continuing to work on campus computers is your best bet until your new computer arrives. If you boot into Linux on a CAEN machine, all the software you need is preinstalled (they should have VS Code, along with the g++ compiler and Valgrind). Let us know if you run into any problems or have any questions using the CAEN machines.. . We grade everything using the autograder, so unfortunately hand-written code is not an option.||0
kvrcuwolp6k1oq|Tests having errors, not able to run|Hello, I am having errors in my testing file. My compiler gives me errors for having undefined Test words, by I do have my unit test framework file in my folder and included in my List_tests.cpp. Can I please receive some assistance with this? It would be appreciated.. . |144|0|active|Looks like your List_tests.cpp file compiles fine on the autograder, based on your most recent submit, so I'm guessing it's just a weird IDE issue. You could try restarting your IDE to see if that helps, or just ignore the errors - your source of truth should be whether you can compile your program from the command line/autograder, since your IDE isn't perfect at determining all errors. I would try attending office hours too, its a little hard to tell what's going on just based on a screenshot of part of your IDE.. . Your List.h file does have compile errors though, so I would try fixing that first at least. Looks like you've implemented List directly in the class - remember that your compiler is going to compile this class from top to bottom, so depending on where you've declared your member variables for the first time, you might run into issues where even though you've defined them, the compiler hasn't seen them yet. Hope that helps!||1
kvrcdbosvni673|Autograder compile error on tests.cpp &#34;exit status: 2&#34;|Hi, the autograder report a compile error on List_tests.cpp. Autograder reported this compile error after we add 4 new tests. But the new tests.cpp is running well on my computer and CAEN. Even the valgrind on my conputer and CAEN doesn't report any warning or error. I am quite confused.... . |110|1|active|Looks like you've added a function called nodeptr() to the Iterator interface and are using that in your List tests, however your tests aren't compiled with your List implementation so the compilation is failing. Remember that you aren't allowed to modify the public interface for these files (meaning changing any of the given public functions, or adding any new public functions)||1
kvra05spbk121g|error during push_back in copy_all function|does anyone know what this error means ? thanks . . List.h:157:23: runtime error: member access within misaligned address 0xbebebebebebebebe for type 'List<int>::Node', which requires 8 byte alignment. 0xbebebebebebebebe: note: pointer points here. <memory cannot be printed>. SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior List.h:157:23 in . List.h:157:17: runtime error: reference binding to misaligned address 0xbebebebebebebece for type 'const int', which requires 4 byte alignment. 0xbebebebebebebece: note: pointer points here. <memory cannot be printed>. SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior List.h:157:17 in . AddressSanitizer:DEADLYSIGNAL. =================================================================. ==58121==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x00010fe83b49 bp 0x7ffedfda88a0 sp 0x7ffedfda87e0 T0). ==58121==The signal is caused by a READ memory access.. ==58121==Hint: this fault was caused by a dereference of a high value address (see registers below).  Dissassemble the provided pc to learn which register value was used..     #0 0x10fe83b48 in List<int>::push_back(int const&) List.h:63.     #1 0x10fe85a8e in List<int>::copy_all(List<int> const&) List.h:157.     #2 0x10fe858ce in List<int>::List(List<int> const&) List.h:130.     #3 0x10fe8570c in List<int>::List(List<int> const&) List.h:129.     #4 0x10fe6960e in test_list_copy_ctor() List_tests.cpp:144.     #5 0x10fe57f29 in TestCase::run(bool) unit_test_framework.h:420.     #6 0x10fe5b2b1 in TestSuite::run_tests(int, char**) unit_test_framework.h:509.     #7 0x10fe69c3e in main List_tests.cpp:172.     #8 0x7fff203b9620 in start (libdyld.dylib:x86_64+0x15620). |168|0|active|It looks like the errory might be coming from trying to access a junk memory address. Check to make sure you aren't accidentally de-referencing a dangling pointer or iterator.||1
kvr9sqqyxaq3br|It says &#34;No test cases submitted&#34;|"I submitted the file ""List_tests.cpp"" along with my ""List.h"". Then, I got this from autograder, which was pretty odd. It was from Nov 8, 12:30 PM. If this was an error, I'd appreciate it if I can get my attempt back. Thank you! "|67|0|active|You did submit test cases, but your Your List_tests.cpp file has compile errors.||1
kvr90zieaew1jf|Unknown Valgrind Error|"I am getting the following valgrind error in autograder but am not sure why it is saying that bytes are lost. It seems to point to the ""new"" keyword in my push_back function, however if I'm not mistaken that is necessary in the function.. . Could someone point me in the direction to understanding/fixing this valgrind error? Thanks in advance.. . Valgrind_p4.png"|10|0|private|As far as understanding the valgrind error goes, the bytes lost means you're leaking memory. It's just pointing you to where that leaked memory was allocated (sort of the source of the leak) but not where its ultimately getting leaked. So the error is really just saying you're leaking memory at some point somewhere after those push_backs in test_insert - hope that helps a little for interpreting valgrind errors!||2
kvr8ncuqf502dp|Iterator Public Interface|When we overload the operators for the Iterator class, are allowed to make the overloaded operators public, or do we have to keep them private so the public interface of List doesn't change?|123|1|active|Iterator operator overloads should be declared as public members of `Iterator`. I think the restriction on modifying List's public interface only applies to class members that are namespaced directly to `List`, not ones that are part of the Iterator sub-class.||0
kvr7lgmfkee19p|valgrind error|I got the error message on the valgrind test. But I have no idea what's wrong with my test cases. Any advice will be helpful, thank you.. . ==88== 24 bytes in 1 blocks are definitely lost in loss record 1 of 72==88== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)3==88== by 0x40889F: List<bool>::push_back(bool const&) (List.h:259)4==88== by 0x404CF5: test_empty() (List_tests.cpp:206)5==88== by 0x4021F0: TestCase::run(bool) (unit_test_framework.h:420)6==88== by 0x40291F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)7==88== by 0x405AEB: main (List_tests.cpp:311)8==88==9==88== 48 bytes in 1 blocks are definitely lost in loss record 2 of 710==88== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)11==88== by 0x4080F8: List<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::push_front(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (List.h:240)12==88== by 0x403FF0: test_push_front2() (List_tests.cpp:94)13==88== by 0x4021F0: TestCase::run(bool) (unit_test_framework.h:420)14==88== by 0x40291F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)15==88== by 0x405AEB: main (List_tests.cpp:311)16==88==17==88== 48 bytes in 2 blocks are definitely lost in loss record 3 of 718==88== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)19==88== by 0x407DDD: List<int>::push_front(int const&) (List.h:240)20==88== by 0x403DC9: test_push_front() (List_tests.cpp:77)21==88== by 0x4021F0: TestCase::run(bool) (unit_test_framework.h:420)22==88== by 0x40291F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)23==88== by 0x405AEB: main (List_tests.cpp:311)24==88==25==88== 48 bytes in 2 blocks are definitely lost in loss record 4 of 726==88== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)27==88== by 0x407C93: List<int>::push_back(int const&) (List.h:259)28==88== by 0x40463F: test_push_front_and_back() (List_tests.cpp:135)29==88== by 0x4021F0: TestCase::run(bool) (unit_test_framework.h:420)30==88== by 0x40291F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)31==88== by 0x405AEB: main (List_tests.cpp:311)32==88==33==88== 240 bytes in 5 blocks are definitely lost in loss record 5 of 734==88== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)35==88== by 0x408584: List<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::push_back(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (List.h:259)36==88== by 0x405703: test_pop_back() (List_tests.cpp:289)37==88== by 0x4021F0: TestCase::run(bool) (unit_test_framework.h:420)38==88== by 0x40291F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)39==88== by 0x405AEB: main (List_tests.cpp:311)40==88==41==88== 288 bytes in 12 blocks are definitely lost in loss record 6 of 742==88== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)43==88== by 0x407C93: List<int>::push_back(int const&) (List.h:259)44==88== by 0x4052FA: test_clear() (List_tests.cpp:264)45==88== by 0x4021F0: TestCase::run(bool) (unit_test_framework.h:420)46==88== by 0x40291F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)47==88== by 0x405AEB: main (List_tests.cpp:311)48==88==49|158|0|active|"The important part of this error is the first sentence:. ```. 24 bytes in 1 blocks are definitely lost. ``` . You should interpret this as ""this much memory is being leaked"". The rest of the error goes on to tell you exactly where this leak is starting from (but not the exact spot where it's getting leaked/you're losing the pointer to the memory on the heap). I would look in your test case test_empty() and look at any functions that get called after push_back() to make sure you're properly deleting nodes when you need to, before you set their pointers to null. It's possibly you're leaking memory in any one of those functions (even push_back itself). Don't forget to consider the destructor too, since that gets implicitly called at the end of the test."||1
kvr7azbj3i25g9|Question P4|Hello,. . I have a question: I literally do not know how to implement these functions: I got the clue that The ampersand says that there needs to be a pointer, as this is the pointers functions. right?. . . . |11|0|private|Hey Nayan, that's a really good guess! But in this case, these are regular functions and the ampersand actually means you're returning a reference rather than a regular value, so it's actually part of the return type - returning a reference is very similar to passing by reference in function parameters, you're just returning a reference to a variable that can be changed outside the function. So for these functions, they should have the same return type as their definition in the List class, which looks like:. ```. T & front();. T & back();. ```. Where `T &` is the return type. You don't need to add an extra * anywhere in the function, because again these are just regular functions (with a slightly different looking return type). Hope that helps!||0
kvr6pvkv49f7cw|push_back() syntax struggle|In this function, we have to change the next ptr for the (formerly) last node to be pointing to the node we added to the end, but how do we do this, since isn't next for the last element a null pointer so we aren't able to dereference it? |104|0|active|I think you are mixing up the act of assigning to a pointer, and assigning to the object in memory that a pointer points to. When you call `push_back()` you need to do the former, and it doesn't require de-referencing. Just assign the address of the new last node to the old last node's `next` variable.||0
kvr6pgnwiub1tm|Project 4 Question About Size|"Hello, in the private section of the Iterator class, it specifies that you can add any additional necessary member variables. However, it does not specify whether or not you can add member variables to the private section of the list class. So, when it says to ""keep track of the size with a private member variable"" in the hint for the size function in list.h, does this mean we are allowed to add variables into the private section of the list class?"|92|0|active|@2828||0
kvr5peafb713cd|List_tests with non-int input|Are we supposed to write tests for string, char, double, etc or just int? All of our int tests are passing but I can't even put a string into our list functions. It is saying the issue is in makefile. |64|1|active|You should be able to put any type you can think of inside your list, however you should have written your code so that it's not necessary to explicitly test this. It seems pretty strange that you're getting an error when you try to put something other than an `int` in your list, so I would recommend making another post with that error so that can get sorted out.||0
kvr3nslx3y12po|List.end()|When trying to insert an int to the end of my list using traversal by iterator, I'm incrementing my iterator until it != list.end() but this is causing my iterator to be a nullptr and causing undefined behavior when trying to insert it. Is there a way to use list.end() properly so that I can reach the end of my list and insert an int?|131|1|active|You're correct that trying to de-reference an end iterator is going to cause undefined behavior. One way around this could be to implement `end()` such that it checks if an end iterator has been passed in, and inserts the datum via a different procedure if this is the case (since de-referencing isn't an option).||0
kvr0olsap152e|Iterator Class|do we need a deconstructor for the iterator class?|148|0|active|No. Generally speaking, as long as you don’t use dynamic memory (like creating new Nodes with “new” in the List class), you’re good with the default destructor. ||0
kvr0fwz8jhk794|erase() function invalidating iterators|I am testing my erase function. I know that erase() can invalidate other iterators, but I am not sure if the behavior/error that occurs is supposed to happen here.. . List<int> list_1;. list_1.push_back(1);. list_1.push_back(2);. list_1.push_back(3);. . . List<int>::Iterator iter_front = list_1.begin();. List<int>::Iterator iter_middle = ++list_1.begin(); //can't use ++iter_front. List<int>::Iterator iter_last = ++++list_1.begin(); //can't use ++iter_middle . . . . . list_1.erase(iter_front); //list 1 = 2 3. list_1.erase(iter_middle); //list 1 = 3. list_1.erase(iter_last); //list 1 = empty. . . . Initially, I tried initialize the iterators to what is commented. I can't understand why there is a memory leak when using ++iter_front and ++iter_middle, but ++list_1.begin(),etc .. still works. Is my code supposed to work like this? I can use ++ on my other iterator tests.. |13|1|private|Remember that the ++ operator changes the iterator, so in your commented out example:. ```. List::Iterator iter_front = list_1.begin();. List::Iterator iter_middle = ++iter_front;. List::Iterator iter_last = ++iter_middle;. ```. When you assign iter_middle, the ++iter_front increments iter_front, then copies that value to iter_middle. So now, iter_middle and iter_front have the same value. Then, when you assign iter_last, the ++iter_middle increments iter_middle and copies that value to iter_last.. . So altogether at the end, iter_front actually points to the second element in this list, and iter_middle and iter_last both point to the last element - when you delete all 3 iterators, you get a double-delete on the last element which is where the problem happens. If you step through this example with a debugger, you'll can see this process happening and notice that the error only happens on the last delete on iter_last.. . The reason using list_1.begin() everywhere works is because that returns a new iterator each time.. . Hope this explanation helps!. . ||0
kvqy0w9syjt1vd|Where to put the functions of list?|Would I need to take off the old function stubs, and implement it right under the Class list ?|104|0|active|You can implement them within the class definition or outside of the class. Depending on which you choose, your function signature will change slightly. All implementations need to be in a header file because we are using templates.||0
kvqxh8u5fi335b|Deleting Nodes|I'm still confused about how to actually delete Nodes through the erase and pop functions. Do I just need to delete all  pointers to the Node to delete the Node? Do I also need to delete the next and prev Node pointers in the Node I'm trying to delete? Do I then also need to delete the next pointer of the previous Node? Do I also need to delete the datum in the Node I'm deleting? I'm generally just confused about what to delete and what it means to delete a Node and any help would be greatly appreciated.|173|0|active|"Think of our doubly-linked list as a chain. When you delete a Node, there are 3 main steps. You must delete the Node itself (which was allocated on the heap with the new keyword), you must stitch the existing parts of the chain back together, and you must maintain the invariant that the list is ""bookended"" by nullptrs.. . The order of these three steps is dependent on which function you are calling and what the current state of the list is."||0
kvqwt3robel3gt|end() on two different iterator|Hello,. . I am skeptical about comparing two iterators from two different list instances, iter1 and iter2. If both iterators are generated by calling end(), isn't that would be true if we compare iter1 == iter2? In that case, doesn't it violate the required clause? How can we get around it?. . Thank you!|14|1|private|That's a good point! For this project that behavior is acceptable, although its a worthwhile discussion to have as the designer of the container what the right thing to do is when you compare iterators between two different containers. And it looks like something that is talked about when it comes to c++ standard containers: https://stackoverflow.com/questions/2549957/comparing-two-end-iterators||0
kvqw9igqm316u4|Struggling to initialize Lists|I made a default constructor and want to run a test case to see if it works. I've tried many different ways to initialize it and seem to get an error every time.. . Here is my default constructor. . And my test case. . I'm confused why line 18 isn't a proper initialization of a List. I tried deleting typename and replacing T with a type like int or double but then I get a compiler error.. |11|0|private|When you delete typename and replace T with int, what compile error do you get? This is the right way to initialize a list, but you probably have another error.||1
kvqw2624lf663|Erase function|What should happen to the node ptr in the erase function after the node it is pointing to has been erased, should it be set to a nullptr?|158|0|active|Generally this is considered good practice. It minimizes the chance of undefined behavior as it almost guarantees that your program will crash if it accidentally tries to de-reference the dangling iterator.||0
kvqt8l7h6dx6ic|What Happens if Your Iterator Goes Out of Bounds?|Can't find anything in spec and wondering if I should make a member variable which compares it to the size member variable that you make in List. |127|1|active|If you structured your code properly, the last item in your linked list should have next set to the null pointer, so once your iterator goes past that, it is simply equal to the null pointer.||0
kvqssr1hrtl61m|Iterator constructor syntax|"Hi! I've been getting an error on my constructors for the Iterator when compiling. I think it's a simple problem of not understanding the syntax required. Here's my current code:. . . . And the errors I'm getting:. . . . Note: I have the ""List<T>::"" before each Iterator constructor, as well as the ""const List<T>::Iterator& i"" in the copy constructor because the console told me to. Originally, the copy constructor was something like Iterator (Iterator i) : ... {...}"", which threw its own error. I don't entirely understand this syntax, either. Would you be able to explain how this declaration is supposed to work?. . Thanks in advance!"|11|0|private|The way you had it before was correct, if you're implementing these functions directly inside the class, you do not need the List<T>::||0
kvqphw2ry1v4ee|No default constructor for List class?|"I'm noticing that there's not a default constructor for the List class - are we not meant to have one since we arent supposed to edit the public interface of List? Also, the comments in List.h suggest having a private member variable for the list size - does adding this variable count as ""editing the public interface"" or not since its a private variable?"|178|0|active|"Student answer is correct, though I'd like to clear up what they mean by ""doesn't need."" While it's true that List doesn't need an explicit default constructor to compile, it may be best to have one if it makes the state of member variables more clear. You should use the information provided in the student answer to determine whether you think List should have a default constructor for your implementation to work correctly.. . No, adding a private member variable doesn't count as ""editing the public interface"" since, as you said, it's a private variable.  "||0
kvq65qi9zb12cv|Several questions around the Big Three|I am not sure when to add the Big Three. I heard someone say that the Big Three should be added when dynamic variable is declared (in this project, like Node * my_node = new Node; ). While I didn't do the assignment operator (operator=()) for the list class, the compiler did one for me when doing List compile checks. I am confused. I want to elaborate my question down here:. . 1. Is the copy constructor same as assignment operator in the List class? There is a copy_all private functions in the List class so I guess I can use that as my copy constructor? But what about the assignment operator?. 2. Does Iterator class also need the Big Three? I used a dynamic variable in the insert() function, does that mean that I will need the Big Three for Iterator too?. 3. If I am not sure about when to add the Big Three, can I just add them in both classes in this project?|241|0|active|1. No, it's slightly different since with the assignment operator you need to deal with cleaning up old memory. You can (and should) use `copy_all` in both the constructor and assignment operator.. 2. I think part of the project is determining whether or not `Iterator` needs the big three. When someone says to add the big three when a dynamic variable is declared, they're saying that when a class takes on the responsibility of managing a resource, you need the big three. `Iterator` isn't really responsible for managing dynamically allocated memory. Also, note that the `insert` function takes an `Iterator` as a parameter, but is outside the `Iterator` class.. 3. As long as you always implement them correctly, it does not matter if you add them in a case where you don't strictly need to.||0
kvq45si4s8m6nb|help for push_back function|can anyone help me to  make sure that my thinking is correct:. . for push_back function:. if the list is not empty(there is at least one node in List). we need to do following things:. 1.set last node's next to point to new node. 2.set new node's prev to point the the original node pointed by last. -----up to now the node has been doubly linked to list. . . 3.set last pointing to new node. last = new_node;. . |67|0|private|Marking this question as private. For any implementation specific details, please direct your questions to OH or a private piazza post.||1
kvq2smiy2se15|valgrind error grading|For each private case, are we directly deducted points in the case of valgrind errors? I understand that a valgrind error may lead to an incorrect answer, but if the output is correct and there is a valgrind error, will be penalized?|103|0|active|You won't be penalized for valgrind errors, but try to fix the errors as they could lead to failing private test cases in the future.||0
kvq2b25ff0i5lk|Push_back|"When implementing push_back, do we need to do  both ""last->next = new_node"" and ""new_node->prev = last""? Or only one of them? "|100|0|active|You would need to make both of those updates. We are implementing a doubly-linked list, so each node will contain pointers to its backward and forward neighbors.. . Also, if you perform the updates in the order you listed them, be careful not to change the value of your List's `last` pointer until after both changes. If you were to update `last` and set it to the new node in between re-assignments, `new_node->prev = last` would set the new node's `prev` pointer to point at itself.||0
kvq22xsqoyt7i|If we are adding a Node to the linked list, do we need to set its next to be nullptr?|If we are adding a Node to the linked list, do we need to set its next and prev to be nullptr?|119|0|active|To add a node to a linked list you have to connect it to other nodes by assigning the correct values to its `next` and `prev` variables. Exactly what values you set them to will depend on where in the list you're inserting the node and how many elements the list has.. . In the case of adding a node to an already-populated list, if you set the new nodes `next` and `prev` members to the null pointer, it will have no linkage to the other list elements, so it hasn't really been added at all.||0
kvq1v0hdea22af|the desturctor|While I was debugging on my compile.CPP, I found out that some of the variables are destroyed before the main progam ends like how my list2 is gone as shown in the figure below. I thought everything will be out of scope and destroyed after the main program is finish. I am kind of confused about this.|132|0|active|I can't say exactly what's happening based on the information you provided. Your visual debugger might just hide the local variable since it knows that it's not used again later in the function, or maybe the compiler decided to call the destructor early because it thought it would make your program faster (although I think this is highly unlikely). I would only be concerned about this if your debugger isn't showing the variable when it is still going to be used later. If that's the case, make sure that you `make clean` and rebuild your project before debugging it again.||0
kvq17n7i5g93bq|List Destructor|When I run my pop tests to delete nodes within the linked list, I get a double free error. I think this is happening because in my destructor I call my clear function which also calls pop_front. What is the default behavior of a destructor cause I feel like that is all I need?|185|0|active|You're correct that the error is because of your destructor and clear function. Calling pop_front in in your clear function is correct, but you might want to think of another way to pop_front everything in your list. Right now, you have a for loop that increments an iterator through the list as you pop_front, but once you pop_front your first element, that iterator becomes invalid, and that's causing the double free error.. . Hint: You don't need a for loop to accomplish this. A while loop may be better.||0
kvpznnt4kl07h|valgrind error in student list tests on student list|I am getting this valgrind error in my Student list tests on student list. I wasnt getting this error before hand but after I wrote more test cases this happened. Does anyone have any information on why this would be happening. . |132|0|active|The error might be in your erase function. One thing that I noticed is that you're not decrementing your length variable, and that might be causing some things to be messed up in the future because the length variable is not accurate anymore.||0
kvpz1zwedr96on|iterator operators|I'm having trouble understanding the following two errors. Am I passing in the wrong parameter types?. . . . |11|0|private|You don't have overloaded functions for ++ and -- implemented. You must implement those first before using ++ and -- on your list.||1
kvpypotub533ar|Error Confusion|"Can someone explain what this means and look at my autograder submission. I am confused thank you.. List_compile_check.cpp: In function ‘int main()’:List_compile_check.cpp:45:30: error: passing ‘const List<int>::Iterator’ as ‘this’ argument discards qualifiers [-fpermissive]   45 |     b = iter3 == my_list.end();      |                              ^In file included from List_compile_check.cpp:3:List.h:188:10: note:   in call to ‘bool List<T>::Iterator::operator==(List<T>::Iterator) [with T = int]’  188 |     bool operator==(Iterator rhs) {      |          ^~~~~~~~List_compile_check.cpp:51:30: error: passing ‘const List<int>::Iterator’ as ‘this’ argument discards qualifiers [-fpermissive]   51 |     b = iter3 != my_list.end();      |                              ^In file included from List_compile_check.cpp:3:List.h:184:10: note:   in call to ‘bool List<T>::Iterator::operator!=(List<T>::Iterator) [with T = int]’  184 |     bool operator!=(Iterator rhs) {      |          ^~~~~~~~make: *** [Makefile:39: List_compile_check.exe] Error 1"|6|0|private|In your operator== and operator!= functions, your iterator parameter must be passed in as a const. Also, your function should be const. Your function signature should look something like this: . . bool operator==(const Iterator rhs) const {.    // your code. }||0
kvpx3xfafac336|Which functions to test|Which functions is the autograder checking our tests on? All of them or maybe not the operator ones?|94|0|active|"Per @2779, ""You should write tests for every function that you can."""||0
kvpvfsqy8wd47|Student List tests valgrind errors|My student list tests compile and give me good results. It is just that I have many valgrind errors. Correct me if I am wrong, but for the first one, is it saying that there is a problem with the operator++() function? That's odd, as it seems to work perfectly, and I copied the same syntax of the operator--() function that was given to us.. . Any advice is helpful.. . . ==100== Invalid read of size 8==100==    at 0x4080FE: List<int>::Iterator::operator++() (List.h:242)==100==    by 0x404B38: test_erase() (List_tests.cpp:206)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100==  Address 0x5abca20 is 0 bytes inside a block of size 24 free'd==100==    at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==100==    by 0x407CA5: List<int>::pop_front() (List.h:142)==100==    by 0x407FA7: List<int>::erase(List<int>::Iterator) (List.h:292)==100==    by 0x404B04: test_erase() (List_tests.cpp:204)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100==  Block was alloc'd at==100==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==100==    by 0x407A4D: List<int>::push_front(int const&) (List.h:89)==100==    by 0x404AE1: test_erase() (List_tests.cpp:200)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100== ==100== Invalid read of size 8==100==    at 0x4080FE: List<int>::Iterator::operator++() (List.h:242)==100==    by 0x404B7F: test_erase() (List_tests.cpp:208)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100==  Address 0x5abc9c0 is 0 bytes inside a block of size 24 free'd==100==    at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==100==    by 0x407CA5: List<int>::pop_front() (List.h:142)==100==    by 0x407FA7: List<int>::erase(List<int>::Iterator) (List.h:292)==100==    by 0x404B4B: test_erase() (List_tests.cpp:206)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100==  Block was alloc'd at==100==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==100==    by 0x407A4D: List<int>::push_front(int const&) (List.h:89)==100==    by 0x404AC7: test_erase() (List_tests.cpp:199)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100== ==100== Invalid read of size 8==100==    at 0x4080FE: List<int>::Iterator::operator++() (List.h:242)==100==    by 0x404BC6: test_erase() (List_tests.cpp:210)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100==  Address 0x5abc960 is 0 bytes inside a block of size 24 free'd==100==    at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==100==    by 0x407CA5: List<int>::pop_front() (List.h:142)==100==    by 0x407FA7: List<int>::erase(List<int>::Iterator) (List.h:292)==100==    by 0x404B92: test_erase() (List_tests.cpp:208)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100==  Block was alloc'd at==100==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==100==    by 0x407A4D: List<int>::push_front(int const&) (List.h:89)==100==    by 0x404AAD: test_erase() (List_tests.cpp:198)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100== ==100== Invalid read of size 8==100==    at 0x4080FE: List<int>::Iterator::operator++() (List.h:242)==100==    by 0x404C0D: test_erase() (List_tests.cpp:212)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100==  Address 0x5abc900 is 0 bytes inside a block of size 24 free'd==100==    at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==100==    by 0x407CA5: List<int>::pop_front() (List.h:142)==100==    by 0x407FA7: List<int>::erase(List<int>::Iterator) (List.h:292)==100==    by 0x404BD9: test_erase() (List_tests.cpp:210)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100==  Block was alloc'd at==100==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==100==    by 0x407A4D: List<int>::push_front(int const&) (List.h:89)==100==    by 0x404A93: test_erase() (List_tests.cpp:197)==100==    by 0x402170: TestCase::run(bool) (unit_test_framework.h:420)==100==    by 0x40289F: TestSuite::run_tests(int, char**) (unit_test_framework.h:509)==100==    by 0x4056B0: main (List_tests.cpp:324)==100== |178|1|active|"Student answer is correct, but to elaborate more:. . You are correct, valgrind is saying there are errors related to operator++, meaning in that function (at line 242) you are reading from some memory incorrectly. . . However, this doesn't necessarily mean your operator++ is incorrect. Looking at the rest of the output, valgrind says that this function is reading from memory that you had previously called delete on (""Address 0x5abc960 is 0 bytes inside a block of size 24 free'd""), and this delete was called when erase was used (""by 0x407FA7: List<int>::erase(List<int>::Iterator) (List.h:292)""). . Remember that erase can invalidate iterators. So based on this output, I would guess that you are using an invalid iterator in your tests.. . "||0
kvpv5iou3ua3d9|assert empty fail|In my test, I push back a element to an empty linked list, then pop the element, assert it is empty but it fails. What could be the problem from??. Thx for help. |109|0|active|I would say make sure you’re actually deleting the Node with the “delete” keyword and that you’re reassigning all necessary pointers (first, last, next, prev) accordingly to whatever case you’re dealing with||0
kvpsed93fo567f|Testing with iterators|I am confused on how to test using iterators. The constructor with a node ptr as the argument is a private member. How can we construct a list with an iterator associated with that list?|247|0|active|That would require calling `some_list.begin()` or `some_list.end()`. Although the Iterator constructor that accepts a node pointer as an argument is private to Iterator, declaring List to be a friend class of Iterator allows List functions to call that constructor and pass in the appropriate `first` or `last` node pointer to initialize and return a begin or end iterator.||1
kvpsai5ahdq651|Issue compiling List tests|. . I seem to have an issue when compiling the my test cases, where the above error occurs. I'm guessing its because we haven't defined the == operator for the List class. So can I write said operator for the class, or would that interfere with the autograder checks?|112|0|active|You should not write an == operator for List. You should compare every element manually instead. ||0
kvps8775ulc3ft|Compile errors|I keep getting a bunch of compile errors when I try to run List_public_test.exe through my terminal. I have no issues when I run it through xcode and when I run it through the terminal on my partners computer there are no errors. We have the same code but Im not sure why I would be getting errors and he is not.|120|0|active|Some compilers will complain about things that others will ignore (e.g. one compiler/IDE might automatically include a library when you didn't explicitly include it, while another just generates a compiler error). It's also possible that a file is missing on one machine, something isn't configured correctly, or just that the two pieces of code are out of sync.. . I would need to see the specific errors to say more.||1
kvpq29zkm5g56o|How much content will project 4 cover?|I have been sick and haven't finished all the lecture recordings, so how much would project 4 cover? Will the content of deep copies and big three or the iterator be covered? Thanks.|177|0|active|Project 4 involves both The Big 3 (copy constructor, copy assignment operator, destructor) and Iterators.||0
kvppo8fzfk245z|Bad access error|Bad_Access.png. I am getting this bad access error on my pop front function. I understand what a bad access error is but I don't get why I am getting the error here. Does anyone know whats wrong here?|9|0|private|You're not decrementing the length variable in your if statement, so the Bad Access error might occur later because the length variable isn't accurate anymore.||1
kvppmn38nfo56e|malloc: *** error for object 0x7fe3ee504080: pointer being freed was not allocated|"I was testing the ""insert"" and ""erase"" functions using an iterator, and I'm getting this error (in the title line) on the ""delete victim"" line in my pop_front() function. I think it has something to do with the fact that I call pop_front() in my List destructor, but I don't know where the problem is. I included the images of the test where this problem comes up. It might also have something to do with my Iterator Big 3, although this error was happening before I implemented them. Any guidance for how I can fix this memory issue would be greatly appreciated. Thank you!. . . "|12|0|private|marking as resolved||2
kvppcvjey1i7fn|P4 student unit tests cannot be graded|I have submitted multiple times, but none of my unit test cases are graded.. . . . . Also, for one time that I passed the student list tests on student list, the autograder still cannot detect my test cases.. |93|0|active|Make sure that you are only using methods from the given List interface when writing your tests.. Even if you define function `List.foo()` on your own List, the implementations your test cases are run against on the autograder will not have an implementation of `List.foo()`.||0
kvpo03kt5ej65r|Test Case logically makes sense, getting false positive|Hi! I have a few test cases that I submitted (a test case with one value) and my test case works on my code and logically when I look at it, it is asserting the correct thing. However, when submitted to autograder it says there is a false positive / error.  Any advice I can get to help with this because I stepped through my code and everything looks correct. My uniqname is fdelmoli|17|0|private|marking as resolved||3
kvpnsz5jez54r4|List_compile_check output operator error|"For my List_compile_check.cpp I receive the error ""no operator ""<<"" matches these operands"". I have already implemented the dereference, ++, !=, and == operators. Do I need to implement a overloaded output operator to fix this or is there something else I am missing?"|107|0|active|Your implementation for the *operator is incorrect. Check your return type vs. what you're actually returning.||0
kvpnldvxv1w2hw|Assert with nullptr|Is assert(node_ptr) supposed to cause an error if the ptr is a nullptr? This is seemingly what is happening in my tests. |83|0|active|Yes, any pointer value that is not a nullptr evaluates to true, while a nullptr has a value of 0, which is equivalent to false.||0
kvpmfm53pcm4yh|Question about erase|In the iterator erase function, should the node_ptr be re-assigned to another position in the list after the assigned list member is deleted?  i.e. should it be set to the member before or after the deleted member, or just left alone?|153|0|active|What you do with an iterator after deleting the node it points to is deliberately left unspecified in the `erase()` RME, I think. One option is to do nothing, and let the iterator become something like a dangling pointer. Another approach that is considered good practise is to set the iterator's `node_ptr` to the null pointer. In this case, accidentally de-referencing the iterator will almost always be detected, either by the compiler or any `assert` statements you decide to include, and result in an error. This at least guards against undefined behavior that may occur when you de-reference a memory address that used to contain a node, but now may be used for something else.||0
kvplkzqt8dz54h|when will a destructor be activated?|when will a destructor be activated?|131|1|active|"Destructors are called when an object goes out of scope. So in your tests, the destructor for any List objects you create will be called when one of your test functions terminates. . EDIT: To elaborate, the above is true assuming that the object was created locally (which is probably what you are doing in all of your tests). However, if the object was created dynamically, then the destructor gets called when you ""delete"" the object. If it's a global or static object, the destructor is called right as the program ends. The general answer is that the destructor gets called when the lifetime of the object ends."||1
kvpjzxxodne43n|Iterator Copy Constructor and Assignment Operator|I am aware that we need to test the Iterator’s default contractor. But do we also need to test the Iterator’s copy constructor and assignment operator?|168|0|active|Yes, its good to test all functions you write. ||0
kvphoj16vtl69u|Problems Debugging Destructor|When I only call push back and fill both the first and last pointer with the same value and address. I then call my destructor and what I assume is undefined behavior caused by deleting victim happens. The address of next points to a location other than null yet it is empty causing my program to exit. I don't know where to go from here and I was hoping for some assistance. Is this even an edge case I need to worry about.|182|0|active|Not exactly sure what your problem is, but are you manually calling your destructor? If so, you shouldn't be doing this because the destructor is called automatically when the object goes out of scope (i.e. if you manually call the destructor, there will be a double delete).||1
kvpdfsuuhcg5zn|Regrade Request|I am wondering when we are getting the result of regrade requests back?|106|4|active|See follow up below||1
kvosuh1b6pa2jd|Erase and Insert|Why are erase and insert functions declared outside of the iterator class? How are supposed to access the node_ptr member value of the iterator inside those functions?|238|0|active|Even though they accept Iterators as arguments, `erase()` and `insert()` are both meant to be called on Lists, and so they get declared along with the rest of the public functions that make up List's interface. The only reason they aren't declared right next to the other public List functions is that they refer to Iterators, which have to be declared first so that the compiler knows what the Iterator typename refers to.. . `node_ptr` is private to Iterator, so ordinarily it wouldn't be available to direct access from outside the Iterator namespace. To get around this we specify List as a friend class of Iterator, which gives List functions direct access to private Iterator variables (i.e. a line like `some_iterator.node_ptr` somewhere inside a _List_ method will still compile).||0
kvoppgbnnne68g|List.h public interface|"When you guys say ""Do not change the public interface of List"" does that mean not to change the function signatures. . . Can we add the implementation within the class, or does it have to be outside of the class?"|103|0|active|That's just talking about function signatures, you can add your implementation within the class.||0
kvoox1dv446735|Valgrind errors|Hello, I was wondering if someone could look at my latest submission because I am confused on why I am failing the List tests. I proceeded to run my code through Valgrind but it spit out the same errors as Autograder and I am having trouble understanding them. Any help would be appreciated... thanks in advance! |82|0|active|Hm based on your latest submissions, it looks like your List implementation is failing to compile, before its able to run through valgrind.. . One of the issues has to do with member initializer lists - the order you initialize member variables in a member initializer list has to be the order those variables were declared. Take a look at this post with a similar error from project 3: @2327. . The other issue has to do the order of evaluation: https://en.cppreference.com/w/cpp/language/eval_order - basically, avoid doing multiple assignments in a single line like a = b = c since you can get undefined behavior depending on what you're assigning. There are specific line numbers in the autograder compile error that can guide you to exactly where the issue is||1
kvooek60hvo5nz|CAEN error not working|"Hello, I keep getting this error in CAEN and am confused on how to fix it. I tried the ""module load gcc/7.1.0"" as I saw on another piazza post and it did not work. Can I please receive some help with this? It would be very appreciated. Thank you.. . "|56|0|active|Resolved!||1
kvom4o27on3o3|Deleting Nodes in pop and erase|"I'm confused about how to delete the does in pop_back(), pop_front(), and erase(). If I'm not mistaken, something like delete first; would only delete the pointer to the first Node in the list, but when I try to write delete *first; I get an error that says ""Cannot delete expression of type 'List<double>::Node'.  How should I go about deleting Nodes for these three functions?"|153|0|active|You're on the right track, but I think your syntax is off. You want to delete a Node pointer so you shouldn't need to dereference it.||0
kvol07eu3wa1xn|//REQUIRES: i is a valid iterator associated with this list|Hello,. . For erase() and insert(), how am I supposed to check if input violates require clauses by assert()?. . Thank you!. . |10|0|private|What values/data are changing between Iterators, that we can use to tell of an Iterator is valid or not? Once you've identified that and are thinking about what to check, think about what it means to be a valid iterator - its pretty similar to being a valid pointer to an array, although there are some slight differences that you'll need to think about. . . As a hint/reminder, take a closer look at the wording of the require clauses for erase and insert - they're not exactly the same, so I would think about why!||1
kvojmebsp3y5kk|Clarification for insert() Iterator|Is the Iterator that is passed into insert() supposed to update the Iterator's node_ptr to point to the new Node created by insert(), or should the Iterator point to the same Node, before and after a new Node was inserted? If the first option, how would I go about doing that?|172|1|active|"That's a really good question, you can interpret the EFFECTS comment for the insert function:. ```. //EFFECTS: inserts datum before the element at the specified position.. ```. as saying ""just stick the node right before this iterator"", sort of meaning implicitly that the iterator will still point to where it did before"||1
kvohkx3ugsq6ne|undefined reference to Node* in begin() and end()|Here's the error message I'm getting. What does undefined reference mean, and is this a problem with the methods or a problem with another method that we wrote?|115|0|active|Undefined reference means you're trying to using something that hasn't already been defined before. I would look deeper into these error messages, because it has some pretty useful information - in this case, it's pointing you to lines 187 and 192 of your List.h file, and its saying that it can't find the Iterator constructor that you're trying to use on those lines (that's what the `List::Iterator::Iterator(List::Node*)` part is - a constructor). Make sure that you're implemented this constructor for the Iterator class, that takes in a Node* pointer.||0
kvog05fp3d29t|Extra Qulaification Error|I get the following errors when I declare the operator functions inside the iterator class. Note that when I write at the bottom of the file without having these declarations it does not compile.. . |65|0|active|The extra namespace tags (`List::Iterator`, `List::Iterator::` are only necessary when you implement member functions outside of the class body, the compiler is probably getting tripped up because you include them.||0
kvofp1tln8i6ee|Templating Test failed to compile?|What does this error on autograder mean? I'm pretty sure I did all the template headers right.. . |178|1|active|We don’t really know the specifics of private tests, but my guess is that this test case is the autograder making sure your List implementation works for any type it puts in the templated parameter. So, for any other students having this issue, make sure you’re not using the templated type T in a type specific way - in other words, make sure you’re not using type specific operations on T such as T + 2 which would only work for ints. In your case, I would also take a look at the error output generated for this failed test case, since its pretty helpful in identifying what the issue is. . The reason we need to do this is kind of interesting and has to do with how templates actually work in C++ - when you compile a program that uses a template, your c++ compiler generates and compiles a bunch of copies of the templated code on an as-needed basis depending on the types you’re using with that template. What that means is you can actually get away with using type specific operations when writing templated code, so long as you only compile programs with types that support those operations. That’s the reason you should test your List implementation with a bunch of different types, including custom class types.. . This is not super related but maybe also interesting, but other languages, such as Haskell and Java, handle templating differently where you’re forbidden from doing any type specific operations at all and you need to work with the templated type purely generically. This sort of gets into a deeper discussion of ad-hoc polymorphism (what c++ templating is actually like) vs parametric polymorphism. ||1
kvodgvw64dq2ct|Testing functions in List class implementation error|Hello,. . I keep getting this error when trying to run by List_tests.cpp. I have implemented the list functions but not the Iterator functions. I am confused how to fix this problem.. . Here is a picture of my error:. . |86|0|active|"Looks like the important part of the error is where it says ""undefined reference to \`main'"" meaning your .cpp file doesn't have a main. Make sure that you have the line `TEST_MAIN()` in your List_tests.cpp file - it should be in there from the starter code, but its possible it accidentally got commented out or deleted"||0
kvod92p6zmc250|List_compile_check.cpp|"Hi,. . I've been trying to test my version of list.h using List_compile_check.cpp, however, I was unable to run List_compile_check.cpp as I was getting syntax errors, even though I have not edited List_compile_check.cpp. Does anyone know why I might be getting these errors? . . For your information, I've already implemented the == and != operator on List.h. The error says: no suitable conversion function from ""List<int>::Iterator"" to ""bool"" exists.. . Thank you. "|104|0|active|"While I wouldn't know for sure without seeing how you declared your operator== and operator!= functions, the error implies that your implementation of those operators is trying to return an Iterator type when the compiler is expecting a bool. So, I would make sure that your function declaration starts with ""bool"", since that is the necessary return type of those operators.. . This link might be of some use: https://eecs280staff.github.io/notes/18_Iterators.html#id2. "||0
kvobazhlzti6iq|&#39;=&#39; operator|My partner and I are working on our code and we have an error with the '=' operator. Do we have to overload the operator? Any help would be appreciated!. . |8|0|private|"I believe it's a problem with the types. `currentNode` has type `Node *`, so when you dereference it, you get a `Node`. So on line 186, we're trying to assign datum, which has type `const T&`, to a `Node` which is a problem. Remember that ""the value"" of a Node is just one of the Node's member variables, like prev and next"||0
kvob1hjhvjr502|erase()|Is it necessary to use the delete keyword on the Iterator node_ptr, or can you just leave it there in memory?|5|0|private|The erase function is supposed to remove a node completely from the linked list. Is it a problem if we do that by just removing that node from the pointer chain, and leaving its memory on the heap? Is anything else going to access that dynamic memory later?||1
kvob0wqvkw431m|erase() at list.end()|Should erasing the element at list.end() remove the last element or should this not be supported since list.end() does not actually point to an element in the list?|120|0|active|For erase(), the requires is:  //REQUIRES: i is a valid, dereferenceable iterator associated with this list. . list.end() returns an iterator pointing to nullptr, which is not dereferenceable, so you should not be able to call erase() at list.end() per the requires.. . Hope this helps!||0
kvoa1g7mo7r4k1|P4 question|Hello,. . Do we need to implement these functions below in order for this to work? if yes, how could I start with this? I asked this because these are the non-function, (like there is no void, or int, or bool) and therefore, I'm guessing that there are no functions to create for the front, and back, right? Or am I wrong?. . |8|0|private|Yes, you will need to implement those functions. It's a little confusing to look at but remember when we're working with templates such as `template `, everywhere you see T, you can think of it as a type like int or bool. In this case, front() and back() both return a reference to a variable of type T - so that's `T &`. I would read the comments above the functions to understand what exactly you need to return for each function||0
kvo9vb73wwb5dk|List compile check errors|DISREGARD - I realized that I somehow put the functions inside of the Iterator class when they weren't supposed to be. I didn't delete the entire question in case someone else had the same issue.. . Hello!. . I've implemented most functions in List.h, but when I run the list compile check I get this:. . . begin() is defined within the Iterator class, not the list class, and the spec as well as the bottom of the .h file say not to alter the public interface of the classes. Are outer classes (List in this case) supposed to be able to call inner classes' (Iterator in this case) member functions like above? . . Thanks!|103|0|active|Solved.||0
kvo99d0we41130|Iterator Big 3|How do i know if the Iterator class requires me to implement the big 3?|10|0|private|The Big 3 are usually necessary when the class creates and manages dynamic memory, so I would ask yourself whether that's the case for the Iterator class. I would also review the lecture that introduces the Big 3 just to get more comfortable with why and when we need it ||1
kvo98k6owxo5mb|Visual Studio update problem with opening remotely|Recently I updated Visual Studio and now I cannot open my project remotely through WSL. It gives me a Seg fault when I try and open it in the terminal and it won't open my project or even let me close visual studio. I've attached screenshots below. Any help would be greatly appreciated because I am very confused.. . |81|0|active|That's pretty odd - just a shot in the dark based on this stack overflow post: [https://stackoverflow.com/questions/58720243/vs-code-server-for-wsl-closed-unexpectedly](https://stackoverflow.com/questions/58720243/vs-code-server-for-wsl-closed-unexpectedly) but we could try restarting wsl:. . 1. Close all WSL/VSCode windows. 2. Open a Powershell terminal (you can search up powershell in your windows search bar and it should show up). 3. Run the following to close wsl: `wsl --shutdown`. 4. Open wsl again (which should boot up wsl again) and run `code .`  to see if it segfaults again. . Hopefully this works, but if not feel free to followup!||1
kvo7zzv910748c|Edge case with insertion|"What is the expected behavior of the following code?. ```cpp. List list;. auto it = list.begin();. list.push_back(1);. cout << *it << endl;. ```. . Would it be valid to dereference `it` on the last line? The RME for `push_back` does not mention invalidating any iterators. Since `it` starts by pointing to the beginning of the list, which is empty, and then we push to the back of the list, shouldn't `it` then point to that newly added element in order to remain ""valid?"""|185|1|active|"it should not be dereferenceable. When doing that same example with a vector<int>'s iterator, running this throws the error ""attempt to dereference a singular iterator"". When it is created, it is created as a ""singular iterator"" since the list is empty, not as a traditional iterator pointing to the first element; it's basically the iterator equivalent of an uninitialized pointer. . . In this sense, the RME for push_back is also technically still correct in this case; it is never invalidated (meaning it was useful before and now is not) because it was never valid in the first place.. . Note: The behavior I described above is what a vector's iterator does; ours would probably make no distinction between a singular iterator and a past-the-end iterator. In any case, it should definitely not need to magically point to the first element in this scenario.. . Also, I just learned this off of the Internet within the last 10 minutes since I don't think this is in the scope of 280; if someone finds that I'm missing some details, please edit!"||0
kvo6xeukpw25l7|How to set up test cases|I can't figure out how to set up test cases for List because it is a templated class. If I include template <typename T> before the Test case then it says that there is no matching constructor. If I put template <typename T> inside the test case, Xcode gives an expected expression error. I don't know how to format these.|106|0|active|In the project 4 specs here: https://eecs280staff.github.io/p4-web/#code-structure, we're shown that . . I used this information, and the information below it, to create a Student struct with the necessary pieces of data, then created a list of Student objects. I wrote tests specifically for the list when it's using Student objects.. . In an environment outside of this class, you'd probably want to write comprehensive tests for more than just a single data type when working with a template, like Double, Int, different kind of Structs, etc to make sure you've implemented it correctly for those types as well and nothing Weird is happening.. . Hope this helps!||0
kvo6n2wj2jq1q5|iterator.end() clarification|Would the following code compile under project 4 definitions . note:  assume there is some list named list1 that is non-empty. ```. . List::Iterator iter = list1.end();. --iter;. cout << *iter << endl;. ```. would iter be expected to print out the datum in last or would this not compile?|122|2|active|"It would compile but it would fail because the requires clause for `operator--` states that the iterator must be dereferenceable, however the iterator pointing to ""one past the end"" is not dereferenceable."||0
kvo5kborgn93a8|Linker command error|"I get the following error when I run my list compile check and don't know where to start debugging.. . Undefined symbols for architecture x86_64:  ""List<int>::Iterator::Iterator(List<int>::Node*)"", referenced from:      List<int>::begin() const in List_compile_check-8ed57d.old: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation)make: *** [List_compile_check.exe] Error 1. . Some help would be appreciated, thanks!"|111|0|active|I assume you are using xcode. If so, check your build phases and remove or add the files you want run in this particular instance.. . Click on the xcode project file > go to build phases > add/remove as necessary in compile sources||1
kvo5h6rwr0vxj|version control|Hello,. . I hit a snag while setting up the version control. I am not able to push function stubs to the remote repo.. . . What's wrong with it?. . Thank you!|6|0|private|"instead of using ""git push -u origin main"" do ""git push -u origin master"". I believe gitlab changed the default branch name from main to master, so this should solve the issue."||1
kvo5gycxtpk4t0|using delete keyword for erase()|Hi!. My partner and I are having trouble with the erase() function. We keep getting this error when we attempt to delete the pointer to the iterator i, that is called in erase(i). We assumed we needed to use the delete keyword because this pointer was created with new when the iterator was constructed. We did this similarly in pop_back and pop_front without any issues. Any help as to where we are going wrong here?|146|0|active|This looks like a case of a double free or freeing a pointer which wasn't created via `new`, check to make sure you're deleting the correct pointer and that you're not accidentally doing it more than once.||0
kvo54z6k69u49p|Questions about member pointers in node and insert in iterator|Just to confirm my understanding, the previous pointer in node would be a null pointer in the first node right?. . And the insert function adds a node right before the node pointed to by the iterator provided, doesn't it? and if the provided iterator is a null pointer then should I insert a node at the front or back of the list?|114|0|active|"An iterator that is associated with some list and whose `node_ptr` member variable is the null pointer corresponds to a ""past-the-end iterator"". Even though it doesn't actually point to a node, we say that it's previous node neighbor is the last element of the list.. . So, passing such an iterator to `insert()` will add an element right before ""one past the end"", which is just the end of the list."||0
kvo4yuzpsf97a8|General project clarification|"In the spec there's a section called ""Office hours queue specification"". Is this part required for credit or would we only complete this as part of api.cpp if we choose to complete api.cpp? "|62|0|active|Only if you choose to complete api.cpp!||0
kvo4p4wh4t5er|Out of line declaraion|Does anyone know why I am getting this error for the Iterator functions? I am writing those functions at the bottom of the file outside the class.. . |55|0|active|"That looks like the correct function signature. Did you include the corresponding function declaration inside your Iterator class' public members section? If you are going to implement functions outside of the List / Iterator class, I think you need to declare them above your implementation in the class body (instructor clarification on this point would be welcome), so that the compiler ""knows"" what member function your implementation references."||0
kvo2g1kdt0s6iy|What Should List_Compile_Check.cpp Output on line 56|. I'm trying to fix a bug I'm running into, but because I don't know what this line should output I'm feeling stuck.|69|0|active|I would avoid using the compile check to test the behavior of your List implementation - instead, try writing test cases that test similar behavior as what you're seeing in the compile check. This would help you get started on your test cases and have smaller, more-easy-to-debug tests that you don't have to decipher.. . In this case though, tracing through what the compile check is doing, line 56 should print 42. Hope that helps!||0
kvo28ynpkw42zh|Testing iterator constructors?|My partner and I are currently missing 3 bugs on Autograder. We are not testing constructors of the iterator class because they are private. Should we consider the iterator constructors when writing test cases? How would we go about writing test cases for that?|142|0|active|"Only the Iterator constructor that takes a Node pointer as an argument should be private. The explicit default constructor (the one that takes no arguments) should be public, since we need to be able to create a ""default"" Iterator object outside of List.. . Because the Node struct is private to List, we wouldn't be able to call the Iterator constructor that takes a Node pointer outside of List class anyway, which is another motivation for this constructor to be private but friended.. . These notes should help too: https://eecs280staff.github.io/notes/18_Iterators.html#creating-iterators. . Now that we know the default Iterator constructor should be public, you should be able to write a few test cases for it!. . Hope this helps!"||0
kvo1z1wzmal6ev|Valgrind not Updating|When trying to run valgrind for lists_tests, it isn't updating meaning it's not picking up on the new test cases I wrote. How do I fix this?|59|0|active|Make sure to sync the new changes to CAEN, and make sure you are in the correct directory (if you synced your local code to a folder named p4-copy, make sure you are in the p4-copy folder on CAEN).||0
kvo0iagls0y66k|confusion about insert and erase|should insert work on an empty list? should erase be able to erase the front or last element?. . if so, should they just call the list functions pop/push_front/back?|180|0|active|Yes you should be able to insert into an empty list and erase any node within the list. I think those functions you mentioned could be very helpful when writing the different cases for erase and insert||1
kvnz882ou9d4qx|end()|for the Iterator end() function, is it ok to just assign Iterator(nullptr)?|98|1|active|"That's what I did! Though I simply wrote ""return Interator();"" since that will initialize an iterator pointing to nullptr.. . In the future, some implementations might not always use nullptr, it will be whatever you choose to represent the end of the list, but in this project we're using nullptr as the sentinel value. . . I'm not sure why you wouldn't want to use nullptr in all implementations since it's so useful, but it's a small detail to be aware of!"||0
kvnyaqiv2o66xe|[function] is private within this context error|I have declared List a friend class in Iterator. However, when I try to compile it still throws errors that all of Iterator's functions were declared private.. . I'm not sure what the issue is.. . |86|0|active|The List needs to be a friend class so it can access private members of Iterator, but that doesn't mean there should be no public members of Iterator. Other classes still want to be able to just Iterator public members, so make sure not to make everything private!||0
kvnxt5gf3s53e2|test case for invalidate iterators|Do we have to consider the condition of invalidating iterators when we are writing our test cases?|98|0|active|You can't really test whether or not an iterator is invalidated by another function call, however you can't use an invalidated iterator in your tests otherwise that will register as a valgrind error and thus a false positive.||0
kvnxq7s93vb4jc|add fucntions|Just to make sure, we are allowed to add private members for List and but only the big three and constructor for the public interface for List right? And for Iterator, we can add any functions for its public interface, right?|121|0|active|You can add whatever private members you want. For the iterator, you're only supposed to add the big three if necessary and only implement the following public operators: `++` (prefix), `*`, `==` and `!=` as well as a default constructor.||0
kvnx3llrdyh1o|Iterators general question about declaration|According to the lecture notes, iterators are declared in the following way:. . . I thought that objects of a class had to be declared by a name, for example: Triangle t1(3, 4, 5);. Why aren't iterators declared like this: . Iterator iterator_name(first);. My partner and I tried to do that above method, and we got some errors.|67|0|active|You're right about how objects of a class are normally created, they're usually given a name. The reason there's no name in the begin function is that the iterator being returned is a temporary value that immediately gets returned, so it doesn't need a name. If you plan to use the iterator within your function, you should give it a name. ||0
kvncq5j0z1536e|Question P 4|Hello,. . I have a question: I'm having trouble with implementing the Clear, Copy all, End, Erase, and Insert functions. Any help is greatly appreciated, on where to start.|7|0|private|Is there something in particular you are struggling with? I would recommend drawing out examples of each of these operations and thinking about potential edge cases. Linked lists are very visual data structures, so drawings usual help me when I have to solve any problems related to them.||1
kvnaxml299w2bf|List tests valgrind error|Hi, for one of my list test that I wrote, I created a list of five integers and I was trying to traverse the iterator in a for loop and track the count. I did it just like what is done in the lecture slides.. . but the number of count was four after the for-loop ends. In Valgrind, it gives me error report like this. I was wondering what is the problem. Any help would be appreciated!. . |85|0|active|Something on line 251 is uninitialized! It's up to you to track down what it is. ||0
kvn81452uwa6mo|Checking iterator validity|I'm working on Iterator erase() and I'm getting getting stuck trying to figure out how to check if an iterator is valid and dereferenceable or not. Does anybody have any suggestions about how to get started with this?|125|0|active|I'm addition to the student answer, keep in mind that you don't have to assert the requires clause, it's just a suggestion. If it's something that's difficult to assert, you don't have to do it. ||1
kvn7sr0mhfp4aw|How to initialize datum|I was wondering how you are supposed to initialize datum in Node_init(). Since datum is a templated class I wasn't sure. |5|0|private|In your Node object, you have datum as one of the variables. Every time you create a new Node, you should be initializing the datum member variable with the value being passed in (you’ll see these in functions like push front/back). Let me know if you’d like further clarification!||1
kvn7nit3s6l76v|return type of the overloaded operators for iteralt|". Iterator& operator--() {.     assert(node_ptr);.     node_ptr = node_ptr->prev;.     return *this; // Never understood this. }	. I don't understand why the return type is Iterator&. What does having a type of iterator even mean. . . Also, for clarification, does the ""this"" keyword just refer to the instance of a specific class? If so, does ""this"" refer to a node in this case? "|111|0|active|"An Iterator is a type in the same way many other ADTs are: it is a programmer-defined collection of member variables / functions (consider examples from past projects like `Player`, `Matrix`, etc.), with a given type name. Returning ADTs from functions is a valid behavior (like how P3's `Player_factory()` function returned a `Player` type, albeit by pointer).. . Because the `operator--()` overload is defined as a member of the `Iterator` class, it is meant to be applied to an Iterator type. The return type `Iterator&` indicates that it also _returns_ an Iterator type by reference, in this particular case by returning `*this`, which is ""the iterator pointed to by the `this` pointer"". The result is that applying the decrement operator to an iterator moves its `node_ptr` member variable one node back in the list, and you get back the same iterator with the updated `node_ptr`.. . One consequence of this Iterator member function / Iterator return type combination is that you can chain together decrement operators. Here is an example with the increment operator, which implements the same behavior:. . ```. List my_list;. //. // ...some code that adds data to the list. //. Iterator iter = my_list.begin(); // iter points to the first element in my_list. . // valid increment - iter advances one node. iter++;. . // valid increment - expression in parentheses advances iter one node and returns the same iterator, to which the second ++ is applied, advancing iter one more node. (iter++)++;. ```. . Regarding your question about the `this` pointer, its value is the memory address of the instance of the ADT you are calling a particular method on. For this function, it points to the Iterator that is having the decrement operator applied to it."||0
kvn7epc0nei27y|Big 3 implementations|Is this all there is to implement the big 3 plus the default ctor os am I missing something? Also, am I using the List<T> template parameter correctly?|7|0|private|We don't confirm the correctness of individual functions for you, you'll have to write test cases for that. Looks like you're using the template parameter correctly, though your operator= should probably return a List<T> &||0
kvn5t9qsdtm2my|The Big 3|Am I able to implement my big 3 functions for the doubly linked list inside the list class in the public section? Or do i have to declare it there and implement it below|96|0|active|You can implement them inside the List class public section. Implementing them outside is possible too, it just requires adding the appropriate namespace and template tags to each function.||0
kvn2tg18cjm1qi|clear()|Does clear() remove all of the nodes from the list or remove all the datum from each node in the list?|111|1|active|It removes all the nodes from the list!  Remember to appropriately take care of all dynamic memory when you are deleting them||0
kvn13ilef9t5ao|P4 - Insert Clarification|. I couldn't find anywhere in the spec what to do if our iterator was the null pointer, so my partner and I assumed that if you had the null pointer being passed into insert you would be looking at the last value of the linked list, however, technically if you initialized an Iterator and just didn't set it to any value, with our implementation it would always push back the iterator, which could be seen as a bug, but I am unsure what the proper way to handle this would be. |9|0|private|Passing a nullptr iterator is equivalent to the iterator returned by end(), so yes the newly inserted element should be at the end of the list.||0
kvmzy25cty01fg|Undefined symbols for architecture arm64|I keep getting this error and I'm not sure why. Can anyone help with this?. . |77|0|active|resolved||1
kvmzdtx8l0i29q|What is being returned in the front and back functions?|"The RME for the front function says ""Returns the first element in the list by reference"". Is this returning the pointer to the node or is it returning the datum inside the node?"|88|0|active|Front and Back both return type T, which indicates that you should be returning an actual value of type T. Think about what part of the Node has a value associated with it of type T.||0
kvmvzqdf6h111x|Re-use of code|Are we allowed to re-use any code from lecture notes or lecture slides that may help us in project 4?|9|0|private|Yes you may||0
kvmtfoqp3343o4|invalidated iterators|Is it alright to have invalidated iterators if we are aware of them or should we try to avoid invalidating them?|87|0|active|As long as you aren’t using them directly (ex. dereferencing them) then it should be ok||0
kvmixp7v67g49d|Project 4 api.cpp optional help|Hi everyone! If you are looking into doing api.cpp and would like some extra resources to help you out, here are the project 4 introduction slides that focus on api.cpp. Once again, api.cpp is COMPLETELY OPTIONAL, but those of you looking to do it can look to those slides.|430|0|active|||0
kvmih853iicia|Help with push_back|My push_back function is causing a seg fault when I test with List_compile_check(). I am not sure why, I tried to follow the way push_back is implemented in the lecture slides. Here is the picture of my code and the error. |13|0|private|It's saying you have an invalid write of size 8 on line 235, which is the last->next = back line. What that means is that for some reason, setting last->next is invalid. That might be because last is invalid at that point, for some reason. I'd step through with your debugger to see what might be going wrong at that line. ||1
kvmh71nm8896a4|invalidate the iteraors|For the pop functions, do we have to consider conditions that may invalidate the iterator in our implementation of the function?|159|0|active|My two cents, but I don't think so. It's true that the `pop()` functions could invalidate an iterator that points to the first or last list element. But because they don't accept iterators as an argument or require de-referencing one, the `pop()` functions don't really need to be concerned with iterator invalidation.. . Verifying that an iterator is valid seems more relevant to functions that actually de-reference them, like `insert()` and `erase()`.||0
kvlul5sfser5lx|Error in Autograder|Hi, I am not sure what this error in autograder means because it seems to be pointing at lines that were written in the starter code? . . |85|0|active|These errors are derived from List.h looks like line, 88, 81, and 212. So try looking there first. ||0
kvlt1rc1kn4736|Valgrind error|What does this valgrind error mean?|8|0|private|Looks like you have some leaky memory when running tests, specifically in your push_back function. Take a look there and ensure you aren't losing any nodes (your prev and next pointers are set correctly). Additionally, its worth taking a look into your pop_front or pop_back function (whichever one you used in your destructor) to ensure you are deleting the nodes properly as well.||0
kvlrgbb1kpx3bz|Question P4|Hello, Is the push_back function correct compared to the push_front function? I'm asking this because I think that it is not correct. what mistake did I make here if it is not correct?.   . . |11|0|private|Have you tried writing test cases and stepping through with your visual debugger?||1
kvlq9nclxsq7i3|Autograder Valgrind bug|Hi does anybody know what's the meaning of this?. |115|0|active|This seems to be saying that you have a memory leak in your `push_front` and `push_back` functions. Make sure you're not accidentally causing a memory leak by losing track of one of your pointers.||1
kvlpnu01bs34r3|only on element in list|if there is only one element in the list, both first and last should be pointing to the same, but do we have to link them through next and prev?|79|0|active|I don't think so. I would think of it this way: if there is only one element in the list, does it have the previous and next node?||1
kvllw6hvgajzc|erase and insert|Can we use erase or insert functions in the implementations of pop/push functions or it should be the other way round?|200|2|active|I would not use erase/insert in the pop/push functions. Erase/insert are in the iterator class which builds off the list functions and creates a way to traverse the list. So it would be good to use pop/push in the iterator functions but not the other way around.||0
kvljqf4z8su5ev|Implementing Iterator erase|Is the double arrow a reasonable way to implement iterator erase here?. . |10|0|private|Yup!||0
kvljoqaqoxj5xo|Nested name specifier|I am getting the following error when I implement List member functions at the bottom of the file, I am not sure what the problem is. And I am kind of confused as to where I should implement different functions, because some functions in the list.h file look like they should implemented inside the class and others look like they should be implemented at the bottom of the file.. . |11|0|private|It looks like you put these declarations inside the List class, even though they are at the bottom of the file, which is causing the issue. If you move these functions outside of the list class, it should make these errors go away. To answer your second question, you can implement all of the functions inside or outside the class--it's up to you. I personally find it easier to implement them all inside the class. ||0
kvlg5d6x6cj27r|copy_all function|Hi. I'm getting the following errors in regards to my copy_all function. I originally made new Nodes in my function, but I went to OH and I was told I could just focus on the datum. Is my syntax incorrect for making new datum?. . . |13|0|private|You need to first set your new datum to a pointer. Then you can dereference that pointer and modify the datum.||1
kvlg54ze5884lf|Iterator functions|Do we need a copy function, assign function, and destructor for the Iterator class?|187|0|active|think about what it means to copy or destroy an iterator. Typically, a destructor would free the memory pointed to by any pointers in the class. Similarly, a copy constructor would copy the actual contents of the pointers to the new object. Is this what we want the behavior of copying or destroying an Iterator to be?edit: by typically, i mean typically this would be the reason to add a custom copy constructor/destructor. the default ones will shallow copy the pointer and not free the memory that the pointer refers to||0
kvldxr5aopd6x6|iterators in list_tests|How do I create iterators for testing in list_tests.cpp that are not nullptrs?. . It won't let me assign anything to the iterator, so I am unsure how to test the iterators.|180|0|active|You should be able to assign an iterator to list.begin(). Then, you would have to increment/decrement your iterator to get it where you desire. For example, if you had 3 elements in your list and you wanted your iterator to point to your third element, you would set your iterator to list.begin(), then increment it twice.||0
kvldwhep5nx3lf|Valgrind error|Hello! When I run Valgrind, I get the error: cannot find /usr/lib64/libubsan.so.1.0.0, but my code runs on my local computer and on Autograder. Why might Valgrind be showing this error? Thanks!. |94|0|active|"@7. . Q: I'm getting an error in CAEN when I try to compile my code that looks like. /usr/bin/ld: cannot find /usr/lib64/libasan.so.0.0.0. collect2: error: ld returned 1 exit status. make: *** [stats_tests.exe] Error 1. A: Try changing the gcc version by running the following command:.  . . . module load gcc/7.1.0 . . You can add the following command to automatically change the gcc version every time you log in:.  . . . echo ""module load gcc/7.1.0"" >> ~/.bash_profile. "||1
kvld0n9uqea1wr|#include files|Which #include files are allowed to include into our program?|68|0|active|||0
kvlc4lur4xs7ix|insert function if list is empty|since for this function, iterator needs to be a valid iterator, can insert work if the list is empty? as in, should you be able to call insert on an empty list instead of pushfront or push back...if so, what would the iterator be pointing to? null?|155|0|active|Insert can work on an empty list. The iterator would be pointing to nullptr.||2
kvlc26xyq0p8v|No Test Files Submitted|When I submit to the autograder, it tells me that no test file was submitted but I did include the file. Why is this?|91|0|active|You have a compile error in your test file.||1
kvlbxfvwkhb24t|Print function/testing|Is there a print function we can use to test our code, or are we allowed to define our own in List.h?|10|0|private|You may only make helper functions private, so you can make a private print function in your List class. You wouldn't be able to call this function from your test file, however.||0
kvlaz5aafzp15|Compile error: expected ‘;’ at end of member declaration|"I'm struggling with formatting our Iterator functions so that they compile right. Currently am getting the error ""expected ‘;’ at end of member declaration"" pointing at the line that the function is declared on. We aren't using function stubs for it, currently just declaring the function right away (I'm pretty sure I read that that was OK for this project). Any advice as to where to look?"|110|0|active|Based on your recent autograder submits, it looks like you've resolved this specific issue so I'm marking this post as resolved - feel free to make another post if you have questions on any other parts of the project!||2
kvlalermg5g29r|Failed to Debug|Hi, when I was trying to debug my List.h file, the error message says this:. . Here is the file I was trying to run, is that correct?. . |67|0|active|make sure you include List_tests.cpp if thats where you're trying to use breakpoints||1
kvl8qhw3pa93vb|Error Message About != and = operators|. I am getting the above error message when trying to make my List_tests executable. In the test case it is referring to, I am attempting to test my assignment operator when the thing you are assigning a list to is itself. I am not exactly sure what the message means/how to go about fixing it. |124|0|active|For the first error you get, it looks like you're trying to compare a pointer to a List with a List object.  These types are incompatible since you're cant compare a List pointer to a List object.  To fix the issue, make sure that you're comparing this with another List pointer.||0
kvl78y75u5o4h0|may invalidate list iterators|"What is meant by ""may invalidate list iterators"" in the RME of some the functions?"|86|0|active|The functions that have that statement in their RME are all functions that remove elements from the list. If there is an iterator pointing at a node in the list, and that node is removed from the list, that iterator is no longer valid (because the node it points to doesn't exist anymore).||0
kvl76qdv54s6yw|First and last|When there is only one element in the list, should first and last be the same pointer or two different pointers pointing to the same object?|95|0|active|First and last would be two different pointers pointing to the same object.. . @2858||1
kvl2p5eiq9wgx|Copy all vs Push All|Is a copy all function the same as push all?|180|0|active|`copy_all` requires that the list is empty before the function is called, so it's a little different that what a hypothetical push_all function would do because it is only ever used on an empty list. Their implementations would be almost identical, however.||1
kvl1vv9rb0g443|Error Message But Have Implementation of Function|. I am getting the error messages above, but I have implemented my overloaded operators in iterator for these two functions (one example below), so I am not really sure why that is happening. . |14|0|private|Reread the error again, especially the part “operand types are …” You are missing a const somewhere||0
kvkfk2h89sz1c9|Empty not declared in scope|Hi!. When attempting to implement my push all and pop all functions in the private area of my List template, my terminal throws me an error saying that empty is not declared within this function. Is there anything I can do to correct this?. Thanks,. Sara|127|0|active|maybe you forgot the parentheses after empty so it thinks it's a variable name and not a function? or maybe you forgot the `List::` in front of the function name and so it doesn't know that it's a `List` member function||0
kvkdvalx2zk2km|Nullptr|If we don't initialize prev and next are they automatically nullptrs|103|0|active|See @2840||0
kvkdjn2drk64mf|size() function|I am confused on what the RME is saying for this function. It is recommending that we do not traverse the list because it is slow, and we use a private member variable instead.. . Is this saying we should not use a loop to go through the list and increment a private int variable every time we move through it (then return that private int variable)?|145|0|active|Not sure exactly how much I am allowed to say here, however I am pretty sure that it is saying not to iterate or loop through the list.||0
kvkdigk1oti580|Error compiling list_compile_check|So I was debugging my List.h by cross checking with List_tests.cpp but I seem to have changed something that made the code go wrong.. . I am now unable to compile the list_compile_check due to this error below: . . . I am wondering if this has anything to do with the * operator? I'm not sure though, as there is a . in front. What exactly should I think about fixing in here? Thanks in advance.|117|0|active|It looks like your List_compile_check.cpp has been modified. Line 65 should be my_list.erase(my_list.begin());||0
kvkck89rnge3do|List Constructor|For the default constructor of list, I set first and last to nullptr and set the prev of first to nullptr and next of first to last. For last, I set the prev of last to first and the next of last to nullptr. The result is that I have gotten a infinite loop over nodes whose next and prev are all nullptr.|136|0|active|Student response was good, but just to further clarify, a nullptr cannot have a prev or next that is also null.||1
kvkc3ottr8b2n8|Project Partnership|If this is our second time taking the course are we allowed to partner with someone who has also taken the course before on a project because the auto grader gives me an option to add a partner.|102|0|active|Yes, you're allowed to||0
kvkbih3s7a73z3|Pointer freed error|Hi, here is the error message. . . . I am using Xcode, not sure how to fix this?|97|0|active|You're deleting something (probably a pointer) that wasn't allocated using the new operator.||1
kvkb65oqjmw73f|Iterator Tests|Should we be writing test cases for the Iterator class? Or are the 21 bugs we are suppose to expose exposable simply by creating lists alone?|120|0|active|In a way yes. When you make a List<T> in your test file, you can work with the list functions by declaring a List<T>::Iterator. You want to set this iterator to different parts of the List to test edge cases for List functions.||0
kvkakrnnm0rcb|autograder missing test cases|I submitted to autograder, but it says that no student List tests were submitted, even though I can see the downloadable file has the cases. How can I figure out what is wrong with my submission?|6|0|private|In the error output of Student List Tests on autograder, it shows that the code is not compiling. That might be why your List tests are getting a 0/21||0
kvka4sv72vm7no|Project 4 Walkthrough|Will there be a P4 walkthrough session? If yes, has it been decided when this will be?|114|1|active|We’re not planning on holding a project 4 walkthrough session since the lectures cover linked lists extensively and api.cpp is optional. Feel free to continue asking questions on Piazza or coming to Office Hours if you need any help!||0
kvk96uer32q2oi|Why Is This Incompatible?|. It says that the declaration is incompatible, does anyone know why? |100|0|active|I think this may be because you have a variable called size as well as a method called size.||0
kvk6vl0s2i63wi|Qualified name is not allowed Error|"Hey, I was getting this error in my iterator class for the operator functions:. . . . qualified name is not allowed -- detected during instantiation of class ""List<T>::Iterator [with T=int]"" at line 35 of ""/mnt/c/Users/Daniel/Desktop/eecs280/p4-web/List_compile_check.cpp"". . . . . . . . Here is my code:.  . . Could you explain what the error is here?. . Thanks,. Daniel"|10|0|private|Can you try implementing this function directly in the class and seeing if you get a similar error? ||0
kvk6bbjku3u21e|insert() function|I want to know whether my understanding about the insert function is correct:. . so the insert function basically inserts a certain value (datum in this case) BEFORE the element inside the node iterator points to.. For example, if iterator points to the first node, the insert function will insert datum before the first node;. if iterator points to the last node, the insert function will insert datum BEFORE the last node (unlike push_back(const & T datum) function).. . Is my understanding correct? If not, please point out where I got wrong, thank you.|139|0|active|Your interpretation appears to be correct.||0
kvk691a8tu02hi|copy constructor|what is the difference between the copy constructor we are supposed to make for list and the copy_all member function?|154|0|active|The student answer is correct. Primarily, you can think of copy_all as a helper function for performing a deep copy.||1
kvk5bnr4qsv5q4|List first/last clarification|"Just to clarify - when you initialize an empty list and push one piece of datum into the front, I understand that that value will become the ""front"" node, but will it also become the ""last"" node since it is the only piece of data? Or is it only the ""first"" node, and the ""last node"" is still a nullptr? "|115|0|active|If it's the only node in the list, it's both the first and last!. https://eecs280staff.github.io/notes/17_Linked_Lists.html#id12. . In the code block right below the link I sent:. . . . The same would apply with a push_front() function. ||0
kvk59355tfp4bv|Iterator &amp; operator-- and &#43;&#43;|Are we to assume that when the operator-- is called on an iterator that, this iterator is not pointing to first? and that when using the operator++, that the iterator is not pointing to last?|116|0|active|You have to consider if your current node is null or not. Incrementing/decrementing should not be allowed in that case.||0
kvk4igpsbcn58v|Xcode sense color/completion not working|I have tried lots of troubleshooting, but I can't get the code in my list.h to light up. I have put List_compile_check.cpp in my build phases but that doesn't seem to solve the issue. Any suggestions?|89|4|active|The most common cause of this is a missing curly brace. Post a follow up if you cannot find it. Also feel free to submit on autograder so I can take a look at your code.||1
kvjy9stc59j2fz|How to Test for Iterator Class?|Does anyone have any suggestions for how to test the Iterator class? Specifically how do we compare what an Iterator is supposed to return versus what the Iterator actually is? Syntax-wise, I'm very confused. I was looking over Prof. Beaumont's slides (for Presentation 17, Slide 18) and saw that one of the lines of code he used was Iterator end = L.end(); when I try to use that line there is an error that says unknown type name: Iterator. Did anyone else have that problem? |115|0|active|The iterator class is part of the List class. Try:List<int>::Iterator my_iterator;||0
kvjy3gj8um6k3|Confused how to test a private function|Not sure how to test copy_all since it is a private member function. Any advice?|147|0|active|Think about when and how copy_all is used within the List class. For example, when calling the copy constructor or assigning a new list, you’ll need copy_all to perform the operation.||0
kvjx01y74dk6ke|Invalid Operands to binary expression in list_compile_check|Hey there, so when I try to compile the list_compile_check, I get 6 errors, all of them being invalid operands to binary expression.. . Does this mean I have to create the operation itself in List.h order to compare the iterators? Thanks.. . . edit: wrote out the operator functions and they're working. |105|0|active|Resolved in edit comment.. For students with the same issue, be sure to implement the operator functions.||0
kvjvp4q4h3150q|Project 4|Are we allowed to base our functions for p4 on the examples given in lecture? Or would this be considered violating the honor code?|124|0|active|You are free to use the sample code given in lecture.||0
kvjuy5ih2bt3h1|Visual Studio Not Error-Checking|Hello! Visual Studio isn't error checking at all. This is a recent occurrence as, during the previous project, it did error check. They work when I open up other projects and make compile-time errors in them, but when I open p4-web, it isn't doing anything at all. The only error that's happening is 'Expected an Identifier', but none of the other compile errors I made are working in p4-web. I already went and changed something via tools -> options -> text editor -> C++ and did some stuff in advanced, but nothing is working.. . Thanks,. Alexander |99|0|active|See answers in followups. ||4
kvjq55m25ckw7|valgrind error for push_front/back|hi!. i know valgrind errors are memory errors, and i've been trying to figure out what im doing wrong to cause these errors because i've drawn out the situation, my code looks similar to the code in lecture, and address sanitizer hasn't specified where the memory leak is. we went to office hours as well, but we still couldn't figure out what was going wrong, so i was hoping for some guidance in the right direction. . the ia helping us said it could be that in our test cases we need to call clear, and the errors persisted even after doing so. . here are the errors:. . . .     void push_front(const T &datum){        Node* ptr = new Node;        ptr->datum = datum;        ptr->prev = nullptr;        if (!empty()){            ptr->next = first;            first->prev = ptr;            first = ptr;        }        else{           // ptr->prev = nullptr;            ptr->next = nullptr;            first = ptr;            last = ptr;        }                ++size_n;                    }. . push back function:.         Node* ptr = new Node;        ptr->datum = datum;        ptr->next = nullptr;                if (!empty()){            ptr->prev = last;            last->next = ptr;            last = ptr;        }                else{            ptr->prev = nullptr;            //ptr->next = nullptr;            first = ptr;            last = ptr;        }                                    ++size_n;. . and our test case causing the error looks like:. . |18|0|private|See follow-ups||1
kvjpndnyrzi4m3|P4 Erase() function|"From my understanding after having looked at http://www.cplusplus.com/reference/list/list/erase/ which we're trying to replicate, the erase function should ""increment"" the iterator passed in or set it equal to its next node, correct? Currently I'm doing this passing the iterator by reference using the signature: void erase(Iterator &i). This passes all my test cases but will not pass the compile check because of the error:. . ""List_compile_check.cpp:65:19: error: non-const lvalue reference to type 'List<int>::Iterator' cannot bind to a temporary of type 'List<int>::Iterator'    my_list.erase(my_list.begin());"". . If I try to modify the iterator's node_ptr to point to the next node without passing by reference, it will not actually update the iterator, so how should I get around this?"|232|0|active|We do not require that your iterator points at any particular or even valid node after erase is called. Since it's not specified in the spec, you don't have to worry about where it is pointing. You should clean up the data associated with the node that is being erased. ||2
kvjp5c69bs31l2|size function|I know that we can add a new private number to track the size but there is a return value of this function. I am confused about how that works? Is it true that we track the size by increasing the value every time we call the size function? If so, what does the return value do?. |163|0|active|You can see what the return value is based on the word to the left of the name of the function. In this case, it's an int, so this function returns an int, read effects clause also when in doubt. yes, the int you return should be the size of the linked list at the moment in time that you call it. ||1
kvjonwy8uy1158|List ctor|I am confused what the default constructor for List is supposed to do, create an empty list?|173|0|active|Constructors are meant to initialize any private members, think about what needs to be initialized (the student response has some tips).||1
kvjo051fi133of|Where does the iterator point after erase/insert?|Which node should the iterator point to after an insert or an erase is called? For insert, I'm not sure whether to point to the new node and for erase, I don't know whether to go back or forward. |173|1|active|To add to the student response, we don't specify where to point the iterator as a side effect of those functions in the RME, so it doesn't matter, as long as you're aware that it may invalidate the iterator.||0
kvjhdvv0bpdxa|Valgrind|I'm trying to run my List_tests on Valgrind, and when I try to make List_tests.exe on my CAEN, I ge t this message - . . [jameyc@caen-vnc-mi15 p4-web]$ make List_tests.exe. Makefile:87: *** multiple target patterns.  Stop.. . Does anyone know what this means, or I should fix it? |73|0|active|@604 ||0
kvjgq6jlsc56hz|Valgrind with new Node p4|"Every time I have Node *something = new Node{} I am getting a valgrind error even though I have a destructor that pops the elements from the list. Should I not be using ""new"" or is there another reason why I might be getting these memory issues? My uniqname is ekahana. Thanks! "|98|0|active|You'll need to use new to create new nodes that you're adding to your list, but if you're creating any temporary nodes within your functions, your destructor will not be able to see them and will not delete them. You can create temporary node pointers without pointing them to a new Node{}, for example:. . . // correct. Node *ptr;. ptr = first;. . // incorrect. Node *ptr = new Node{};. ptr = first; // we lost access to the node we created on the previous line||0
kvj5yxadu9b462|Question|Hi, I want to know if I am on the right track here, or not because It's very confusing to implement the functions in the header files: |10|0|private|Read the hint for the size function and see how you can use that also in the implementation of empty. ||1
kviy207fsc2j0|p4 stubs|![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkst6d658glz1cl%2F16993f254ec427cf58b6c665c8d6a01266e4abcad1b5ebf10e66d80cf90df77e%2Fimage.png). . This happens when I try to add in the stubs as shown in the specs:. ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fkst6d658glz1cl%2F4e663cab0a85b7f2222f931de39e2fe9f38db041b8b17188f4502f516aa8c027%2Fimage.png). . I don't actually understand why we have List:: in front of the example to start with, since we are defining these functions within the class, why do we need the scope resolution operator?. . . |160|0|active|The function stub provided in the spec is for you if you would like to implement the member functions **outside** of the class declaration. If you want to implement them inside the class declaration, just use `bool empty() const { ... }`.||0
kviv6s7wali4cx|Iterator end()?|"What exactly is meant by ""past the end"" for the Iterator end() function? I'm still trying to wrap my head around how the Iterator stuff is supposed to work."|150|0|active|"This is the subject of tomorrow/Thursday's lecture, so hopefully that clears things up a bit. But here's a preview:. . When I'm iterating through an array using a pointer:. . const int SIZE = 5;. int arr[SIZE] = {1,2,3,4,5};. for(int *p=arr; p<arr+SIZE; ++p) {.   cout << *p << endl;. }. We don't actually break when p is point at the last element. Instead, we break when p is pointing at one past the last element (i.e. &arr[5], an undefined memory location), so that the loop executes for every valid element of the array.. . We want the same behavior with an iterator:. . list<int> l;. list<int>::Iterator it;. for(it = l.begin(); i!=l.end(); ++it) {.   cout << *it << endl;. }. If l.end() returned an iterator pointing to the last element in the list, we would end up executing the loop one time too few. So it needs to be pointing ""one past the last element"", which just means its the iterator you get when iterating an iterator pointing at the last element one more time. We represent it by storing the null pointer internally, but that's an implementation detail."||0
kviqn1cu75t202|Iterator operator overloading arguments|https://eecs280staff.github.io/notes/18_Iterators.html#dereference-and-increment-operators. . In the above link, the signatures of the operator== and operator!= functions declare the argument as Iterator rhs. Shouldn't we be passing this in as const Iterator & rhs instead since neither function should modify rhs and there is no reason to copy the contents of the Iterator into a local rhs variable? If I were to change it to const Iterator & rhs instead, would it still successfully override the operator== and operator!= functions?. . |129|2|active|The memory required to pass an iterator by value vs by reference is pretty much the same because an iterator is just a pointer. The function should still work if you pass it by const reference, but I would keep it as pass by value.||1
kvipvh24cu33dw|List::Empty|"Are we supposed to use the List Iterator for list empty, I am confused what the RME means by ""May invalidate list iterators""?"|10|0|private|"I think you're referring to List::clear() because List::Empty doesn't have the RME you are mentioning. If you are, ""May invalidate list iterators"" means that when you clear the list, the list iterators that used to point to elements inside of your list will be invalid because they are no longer pointing at valid elements."||0
kvipnsygszx3mp|Question about Linked Functions|Hi!. I have a question in lecture, I remember that the professor said that the functions from Lecture 15 are not the same as the project 4. I am confused on the difference between the functions that were given to us during lecture and the ones in the project, since they both use the same Node struct and have the same RME.|83|0|active|The linked list in lecture is a singly linked list.  The one you have to implement in p4 is a doubly linked list.  The functions in lecture are similar but not the same as the ones you will implement||0
kvilz7rucp77g1|Size|Can I create a new private member variable that keeps track of the size of the list? Or is this changing the public interface which it says we're not allowed to do?|184|0|active|It's totally fine to do that. It's not modifying the public interface because it's a private member variable (hence the public private distinction).||1
kvilalyulxs3n5|Functions Stubs|Do the Iterator functions and the erase and insert functions need function stubs? We noticed that begin() already written and didn't know if we should make stubs.|170|1|active|You do not necessarily need function stubs. I personally believe it is easier to complete this project without using function stubs.||1
kvil4adthim1ms|doubly linked lists|Are doubly linked lists require to do P4 or are singly linked lists acceptable?|92|0|active|You're making a doubly linked list, so I'd say it's required that you understand how to make one.||0
kvikrhgdxt21df|constructor|Do we need to create a default constructor and where would we place that in .h file.|141|1|active|Yes you need one for Iterator and List. Think about what private members need to be initialized.||1
kvigwou08br7ju|Valgrind Memory Error|"Hello! I'm getting a Valgrind error on my insert() function. I think this is because I used ""new"" and not ""delete"". However, isn't that supposed to be the case? The insert() function makes and inserts a new Node, so it makes sense that there will be one more Node allocated in memory after the function is done running. Thanks!. "|12|0|private|Are you deleting your list somewhere after your file is completely done?||1
kviccs0zvko37q|confusion about iterator|For the iterator, is it true that the erase() and insert() functions of iterator are able to insert or delete elements in the middle of the list but not only in the head and tail? The spec says that the list is a queue that can only access tail and head elements, if this is correct, then why iterator is able to access the middle element? Are iterator and list two sets of interfaces?|249|2|active|To add to the student response, iterators are more abstract than just the ones we create for the list class! Iterators provide a common interface for navigating a variety of data structures from arrays, lists, maps, vectors, and since we know how to create iterators, we can create our own for custom data structures. You'll learn more about these cool benefits in eecs 281, but you can always check out the stl if you're interested in seeing what they can do.||2
kvi9fu92er117i|A few questions about iterator|"when comparing iterators with the == operator, are we comparing that they are pointing to the exact same item in the list (same address) or just pointing to items with the same datum. . . does the * operator for iterator return the address iterator is pointing to (Node *) or the value at the node ptr (datum)?. . what is a friend declaration? do we need to be able to construct an iterator at a specific position or have any other private member variables?. . what does iterator.end() mean by saying it returns an iterator pointing to ""past the end""? does it return the last element of the list or a nullptr?"|184|0|active|"1. `==` for iterators should return true if they point to the same item (same position) in the list.. 2. `*` for iterators should return the value (`datum`) at the current node. `Node` is a private type inside `List`, so outside users can't even access it and don't need to know it exists.. 3. I think friend declarations are going to be covered in a future lecture, but they're basically declarations that some function (free or member function) has access to all the private members of that class.. ```cpp. class ClassA {. private:.     int i;.     bool b;. .     // We could also do `friend void do_something_else(ClassA const &a)` for some free function `do_something_else`..     friend void ClassB::do_something(ClassA const &a);. };. . class ClassB {. public:.     void do_something(ClassA const &a) {.         // Without the friend declaration, this would not compile (a.i and a.b are private members of ClassA)..         std::cout << a.i << "" "" << a.b std::endl;.     }. };. ```. 4. `Iterator::end` returns an iterator that points to not the last element of list, but an imaginary location after the last element. How you represent this state is up to you."||0
kvi82dy0wc97bm|extra qualification on member ___|"I can't seem to declare my function stubs as bool List<T>::empty() const; for example. I get thrown an error that says ""extra qualification on member 'empty'"", but when I remove List<T> I don't get an error (ex. if the stub is just bool empty() const;). stackoverflow said this might just be an xcode thing because it works with VScode but not with xcode, is that true?"|122|2|active|resolved in followups||1
kvi7a89wldz43m|In Seek of a Partnership|Hey, my name is Chris and I am a recent transfer student at UMich. EECS 280 is my first ever programming class so learning the syntax of c++ in addition to the complex concepts is a vast task. To supplement this, I've watched hour-long tutorial videos breaking down various topics and attended a multitude of tutoring sessions/ SI sessions (which I continue to do). I was hoping to find a partner who has a bit more experience than me so that we may collaborate and learn from each other while completing the project(s). I am always available so you can reach out to me to discuss anything regarding class/ projects. If you're interested in forming a partnership, you can DM me on discord (chirstoogoated#5828) or email (chrisfx@umich.edu) and we can discuss it further.|190|0|active|You may get better results from using @5 to search for partners||0
kvi6qa77nzb44w|* Operator and Function ordering|What is the Iterator& operator*() supposed to be doing? Is it multiplication or dereferencing?. . Also, in our implementation of something like push front should that be calling insert on the iterator? Otherwise, what is the purpose of the node functions like insert, erase, and the operators. Like why? :)|207|0|active|`operator*()` overloads the deference operator (not mutliplication here).. . Project 4 doesn't implement a dereference operator overload for iterators that returns an iterator though. You might be thinking of the `T & operator*()` function, which overloads the dereference operator for Iterators and returns the datum from the node a dereferenced Iterator points to. On the other hand, the `Iterator & operator++()` function _does_ return an Iterator by reference after incrementing the Iterator's `node_ptr` member variable.. . While it's true that the insert and erase functions implemented in the Iterator class behave the exact same as List class' push and pop functions when they are called with a beginning or end Iterator (i.e. inserting or removing data from the front or back of a list), they also make it possible to insert nodes into the middle of a list with a single function call, and so introduce functionality beyond what the push and pop functions provide alone.||1
kvhdfioikub2mk|list.h implementation|I am trying to implement functions in list.h but the code will not light up/change color. I have list.h in my build phases and it still won't work. |192|2|active|If you're on xcode, I think you should remove List.h from your compile sources (never have header files in your compile sources) and instead have the compile check in your compile sources. I think that should enable syntax highlighting within List.h||1
kvhcudsu77q1fk|Project 4 Allowed Resources|Are we allowed to use the code snippets in the EECS 280 course notes in Project 4? https://eecs280staff.github.io/notes/18_Iterators.html |8|0|private|Yep!||0
kvhbz3gon195ub|Project 4 partner|If anyone is looking for a partner for project 4 please contact me. Uniqname is ejelneck|132|0|active|||0
kvhaxfx1ybf6mz|Erase function Iterator question|"In erase it just says it ""Removes a single element from the list container"". Does it matter which element we remove? Are we supposed to remove the element associated with Iterator i or can we just remove one from the beginning or end of the List?"|148|0|active|You must remove the element associated with the iterator that was passed in as an argument||0
kvh5n708wua5i9|p4 autograder error|I can someone explain to me what this means/what is going wrong with my code?. . 1In file included from List_public_test.cpp:3:0:2List.h: In instantiation of 'List<T>::List() [with T = int]':3List_public_test.cpp:10:15: required from here4List.h:147:9: error: 'List<int>::last' will be initialized after [-Werror=reorder]5Node *last; // points to last Node in list, or nullptr if list is empty6^7List.h:136:7: error: 'int List<int>::list_size' [-Werror=reorder]8int list_size;9^10List.h:20:1: error: when initialized here [-Werror=reorder]11List() : first(nullptr), last(nullptr), list_size(0) {}12^13cc1plus: all warnings being treated as errors14|8|0|private|It looks like you declared list_size first and then first and last were declared.  So to fix the issue, initialize the member variables in the order list_size, first, last in the default constructor||0
kvh31xdjjom3ar|Self assignment not allowed?|. `List_tests.cpp:139:15: error: explicitly assigning value of variable of type 'List<int>' to itself [-Werror,-Wself-assign-overloaded].     original4 = original4;`. I get this error when assigning a list of ints to itself. Is this expected? My assignment operator works fine in every other case.Update: I tried compiling on CAEN and it worked fine, so I guess its an issue with my local compiler. Any advice on how to fix?|12|0|private|I'm unsure why that's happening for you. My guess is that one of the compiler flags on macOS includes -Wself-assign-overloaded, whereas that doesn't happen on g++. You could try getting around it by making a pointer to original4 and assigning original4 to that instead. ||0
kvh1vt6ndpr60k|List Compiler Check not Working (issue with bool operators)|I have this problems with the list compiler check not compiling and mentioning an issue with the bool operators. I asked a few IA's about it today but no one has been able to figure it out and it was suggested I post on piazza. Attached are the errors in the list compiler check and the code for my bool operator functions.. . . . |12|0|private|Try passing your other parameter either by value or by const & in both overloaded operator functions||0
kvgw8bgviwp7av|How to test for memory error?|One reasonable bug for the functions that delete Nodes is forgetting to call delete on those Nodes. Is there a way to write test cases that can expose those bugs? I can use valgrind to make sure my code don't leak memory, but how can I write test cases that expose memory-related bugs on the autograder?|188|0|active|While that's a great idea for a test case, that's not something you can check for directly. I'd focus more on constructing various lists and modifying them in unique and interesting ways, then verifying your modifications were made as expected!||0
kvgu3la870f56u|P4-web setup error with pushing things into gitlab|When I tried to add things to my gitlab, my status came up as this:. . However I do not have a Derived Data file/folder in added to xcode. My files look like this on xcode:. . . But I noticed a folder labeled derived data was in my starter files (inside was a folder named p4-web. Inside the p4-web folder there was a folder named SymbolCache. Inside the SymbolCache folder there are two files named metadata.plist and project.plist) Do I need to add this derived folder into xcode or can I delete it from my starter files?|133|0|active|DerivedData is a folder generated by xcode. I'd recommend using a gitignore so you don't have to worry about it. .  ||1
kvgu2zhjnhjge|What does List mean?|. there is the prototype of the copy-all function. What is List<T>? List is the class name and T is the template name which could be any type of data, but what does this combination mean?|171|0|active|One of the uses of templating is to make it so a single class can handle data of multiple different types. For example, you might want to make a List object that can contain integers, or strings, or whatever else. The way you make the List class generalized to storing those different types is with a template. We have seen examples of this in class already with vectors. You can make a vector that contains ints (vector<int>) or strings (vector<string>). Same idea applies here. So this copy_all function should work with any List of type T, where T can be any type. . . Edit: if this is part a member function of a class, the type passed into this function for T must be the same as the T of the class that owns the copy_all member function being used. ex. If I make an object List<int> my_list, and I do my_list.copy_all(your_list), your_list must also be List<int> (as opposed to List<string> or any other type).||0
kvgrgfpx6925hp|prev pointer|"this is the Node in private:. . struct Node {.     Node *next;.     Node *prev;.     T datum;.   };. . I knew ""next"" pointer points to the next datum in the linked list. But I am not very sure about the prev pointer. Does ""prev"" pointer point to the previous node, in the opposite direction of next? If it is the first node in the list, is ""prev"" the same as ""first"" pointer, or points to NULL?"|123|0|active|"Yes, the prev pointer will point to the previous node in the list (the node right behind your current node).. . To answer your other question: regardless of whether there is one node, no nodes, or 100 nodes in the list, does ""first"" ever have a node behind it?"||1
kvg5f05p2332wz|list.h copying function prototypes|Are we implementing all of the List class functions in the same List.h file? Why are we not using a .cpp file?|167|1|active|"Yep, everything has to be done in `List.h`.. . `List` is a template class, meaning that it parameterizes over other types. When the user instantiates, for example, an object of `List` type, the compiler performs something called ""monomorphization"": a `List` class implementation is generated from the polymorphic `List` class. Because monomorphization happens when some client code instantiates a `List`, the compiler has to know everything about `List` from there to generate the `List` implementation. If we implemented the `List` member functions in a separate `.cpp` file, the compiler would be unable to generate the monomorphized type, because it can only see the header file from the file that included it."||0
kvg38ev87bqtr|size function|Here is the size function in List.h file:. . I researched that if we want to use std::list, we should add <list> at the top. But the spec said we should use <list> in api.cpp but List.h. So how can we use std::list in size function?|158|0|active|You should not be using std::list in your List.h. This is a hint on how the size function is implemented in the standard library list data structure. You might want to consider using a similar implementation in your list as well.||0
kvfzvljz1un1er|is the Iterator::insert() able to take in null iterators?|I noticed that the RME does not require a dereferenceable iterator, so I assume we need to allow for nullptr iterators?|128|0|active|Yes it can take in non-dereferenceable iterators.||1
kvfplfks92u1fo|Problem with debugger when I have breakpoint in api.cpp|"I have an issue with my debugger for this portion and got an answer that this would be answered in detail later once the midterm was finished..  it says in the terminal  . . . &""warning: GDB: Failed to set controlling terminal: Operation not permitted\n""/bin/bash: main_test.in: No such file or directory[1] + Done                       ""/usr/bin/gdb"" --interpreter=mi --tty=${DbgTerm} 0<""/tmp/Microsoft-MIEngine-In-r4rgupmx.ew1"" 1>""/tmp/Microsoft-MIEngine-Out-yj0vlut4.xj3"". . When I try to run it, it says in the debug console ERROR: Unable to start debugging. Unexpected GDB output from command ""-exec-run"". During startup program exited with code 1.. . Is there any solution to this problem?. "|145|1|active|"I'm not sure why that's occurring. First: Are you in the correct directory? It seems like it can't find the ""main_test.in"" file in the directory you're in when debugging. Maybe post your launch.json below. "||1
kvfp0sr1vew23i|Expectations for List.h|I see that we are not providing the api.cpp file. I am confused on what is expected to be contained in our List.h file.. . Do we only need to provide implementation for only the functions listed? More specifically, do we not need to provide new functions to handle errors, use cout and cin to do our requests and responses , etc?. . |252|0|active|You are not required to code anything related to the driver or api.cpp for this project. You're not supposed to modify the public interface of List.h other than to add the big three, however you will need to add some operator overloads to `Iterator`.||1
kvfoo4wnqba6uh|Question on Templates|"Is the ""T"" here in ""typename List<T>"" the same as the ""T"" in ""Iterator List<T>::end()""? The compiler suggested I add ""typename"" in front of ""List<T>::Iterator List<T>::end() const"" which is how I ended up with the code below. . . . template<typename T>. typename List<T>::Iterator List<T>::end() const{.   assert(false);. }"|142|0|active|"Yes, those two ""T""'s are the same. I'm not sure why it recommended adding a typename there--the typename keyword can be pretty confusing with its rules. "||0
kvfojwk6dgaqa|Are we supposed to use iterators inside the main pop, push, copy implementations of List?|Or are the Iterators just there to interact with the List better? Kind of like a wrapper/additional API to the List?|142|0|active|I wouldn't recommending using the iterators there, they're there as an additional API to interact with an traverse the list.||0
kvfnhuvs5ez2tp|copy_all function|Is the copy_all member function of the List template class asking us to append the nodes of other to this or to just create a copy of other?|135|0|active|Note that the requires clause of `copy_all` says that this list must be empty, so appending and making a copy that you store in `this` are the same thing.||0
kvfm1nxmx9m30g|Private constructor|In project4, I am wondering why the constructor for Iterator is private here. Then how can the begin() function access the constructor for Iterator? Am we meant to write some helper function?|168|1|active|You may find a friend declaration helpful! https://eecs280staff.github.io/notes/18_Iterators.html#friend-declarations||0
kvfjz5ubexa9u|undefined symbol|I have added the function stub after the list class in list.h. But when I try to make public_test.exe. It shows me an undefined symbol of empty() error.|115|0|active|It looks like the error was due to a missing main function in api.cpp.  Try doing the command make List_public_test.exe instead if you want to run the list public test||0
kvfjf7olavr48x|Project 4 Concepts|What concepts/topics do we need to know to fully complete Project 4?|243|1|active|Containers, Dynamic Memory + Big Three, Linked Lists, and Iterators||1
kven84dtl7f4p8|List works for compile check but fails at construction in public test|"I use this line to construct my linked list (len is a private member I added to the list class):. . List() : first(nullptr), last(nullptr), len(0) {}. It works fine with compile check and was able to print all the values (though I'm not sure about the correcteness), but it fails at ""constructing an empty list"" with segmentation fault in public test. I'm not sure why this is happening. "|77|0|private|I made this post private since you shared some code. It's not too much, but generally try to avoid sharing code in public piazza posts. . . To see why it might be failing that test, I'd recommend stepping through with your debugger and seeing what line causes that segmentation fault. Maybe you'll be able to figure out what's going wrong after that!||1
kvei99ahxl36dj|Iterator question|Should we code our iterators so that the following code works? And if so, how would we do that without changing the implementation of `operator--`?. . ```cpp. List list;. list.push_back(1);. auto iter = list.end();. -- iter;. assert(*iter == 1);. ```|127|0|active|The operator-- of Iterator requires that the iterator be dereferencable.  Since iter is an iterator equal to list.end(), iter is not dereferencable so this is code violates the requirement for operator--.||0
kvegi9nhotu4jp|Iterator default constructor|I'm confused as to why a default constructor for `Iterator` is necessary, as it seems that the only way you should be able to get an iterator is from an existing list. Should it have the same behavior as the end iterator (e.g. `List list; List::Iterator it; assert(it == list.end())`)? Currently, I have written it so that the assertion fails (i.e. a default constructed Iterator is not equal to the end iterator), and I think that's what's causing a false positive in one of my test cases.|238|1|active|Yes https://eecs280staff.github.io/notes/18_Iterators.html#creating-iterators. . Though it may seem unnecessary to create a default constructor for Iterator, a user may want to create an iterator associated with the list without needing a copy of another iterator.||1
kvea91e6vsx377|api.cpp clarification|I understand that api.cpp is optional and ungraded. I still wanted to clarify, if someone were to successfully write and submit this file, they wouldn't gain any advantage in terms of their grade, correct? In other words, working on this file is good for coding practice, but wouldn't be effective if someone were looking for an extra points opportunity to raise their grade?|148|2|active|That is correct!||0
kvdy52b7gqo339|Is api.cpp required or not?|The spec says that it is both ungraded and not required, and also that it is required for submission to the autograder, so just wondering for some clarification! |215|0|active|It's not required. Thanks for asking about this!. . There must be a mistake in the spec somewhere - could you let us know specifically where it says it's required for submission to the AG? We'll get that fixed right away.||3
kvdxaabhspt6nr|expected initializer before ‘&lt;’ token|I just copy and paste the  example of a function stub at the top of my List.h. How can I solve this problem?. . |132|0|active|Did you include the template<typename T> declaration on the line above the function signature?. . If you put the function stubs at the top of List.h (before the class definition), this error will occur because the compiler doesn't know what a List<T> yet. Instead, try pasting your function stubs at the bottom of the file, after the class definition.. . . Pro-tip: Start by copy-pasting each function prototype from the class declaration at the top of List.h to the bottom of the same file.. ||1
kvcymhg73k57nv|Unable to Connect to Remote Repo|I had this same problem when starting P3 and I got it fixed in office hours, but it took a few minutes of random commands which I do not remember that my professor told me to enter. . Now that P4 is out, I wanted to setup my directory and connect it to my remote repo but I got the same error again.. . I entered git init, and I have the starter files, and I created the repo and I used git remote add origin with my HTTPS link. git remote -v works. . . After that, I am unable to make my initial push (and I already added and tried committing changes, but it does not let me commit).. The error mentions refspec not matching. . Thanks!|130|0|active|". $ pwd. /path/to/your/eecs280/folder/p4-web. . $ git remote -v. origin https://gitlab.eecs.umich.edu/UNIQNAME/p4-web.git (fetch). origin https://gitlab.eecs.umich.edu/UNIQNAME/p4-web.git (push). . $ git add .. $ git commit -m ""initial commit"". $ git push -u origin main. . Are these the commands you're using right now? Without a screenshot of your error message it's hard to say exactly what the problem is, but I think refspec errors are often a sign you've used a branch name that git doesn't recognize."||2
kvcukpuu4seev|Project 4 FAQ|"This is the thread for P4 FAQ's.  Reminder P4 is due on Friday, Nov 12 at 8pm!  Please add your uniqnames on Piazza (the post @6 gives you instructions on how to do so).  This really saves us so much time when helping you whether it be looking up your code on the AG or doing anything exam related.. . There will not be a p4 intro session overview as api.cpp is optional and the linked list coding portion is mostly covered in lecture.  If you want to do api.cpp (for fun) please see @2903..  . Q: What is a linked list/iterator?. A: A linked list is another kind of container and an iterator is an object used to traverse and access elements in a container. You can refer to the lecture slides or the class notes (https://eecs280staff.github.io/notes/) if you have any questions..  . Q: Why am I getting an error related to accessing a private member of Iterator in a List function?. A: By default private members of the nested Iterator class are not accessible to the List class. The solution is friendship! We'll be covering friend declarations in the Iterator lecture. .  . Q: Should I test the destructor/How do I test the destructor?. A: You should write tests for every function that you can. You're not responsible for testing the destructor in your test cases, but you should use a tool like valgrind to ensure that your code isn't leaking memory. You shouldn't call the destructor explicitly! The compiler does so automatically when the object dies..  . Q: Why am I getting a segfault/undefined behavior?. A: Valgrind can be a helpful tool for tracking memory related errors. In general, a common cause for segfaults and undefined behavior in this project is uninitialized pointers. Make sure whenever you create a pointer variable (like first, last, or the members of a Node) that it is given a clear value. Valgrind tutorial: https://eecs280staff.github.io/p1-stats/setup_valgrind.html .  . Q: Why does my test case compile on CAEN, but not on the Autograder?. A: Double check that you haven't added any public functions or made one that was originally declared private, public. Also, double check that you've not put using namespace std in a header file. Also, you can't compare an Iterator with a pointer.  Also double check you've run your code in your terminal and on CAEN in case you accidentally created an unused variable.. . Q: How do I start api.cpp? What should the program look like?. A: Be sure to check out the project intro slides here.  They include information that you may find useful when implementing api.cpp.  Think about where you need to take input from, and what different things your program needs to be able to do with it. Then, break your code up into different functions or a class or whatever structure you'd like - just try and keep things organized, and don't just use one giant function.. . Q: On the style check I'm getting a ""memory is allocated but not initialized"" error whenever I create a Node.  But I'm initializing my Node data member variables in the lines directly following.  How do I fix this?. A:  This occurs because the style checker sees that you create your Node on one line, but is not smart enough to check the following lines to see that you initialize the members of the newly created Node. This can be solved in a few different ways.. . Default constructing your members then initializing them.. . Node* n = new Node{};. n->datum = datum;. .... . Using brace intialization to create the new node.. . Node* n = new Node{next_in, prev_in, datum};. . Creating a default constructor for Node.. . We recommend options 1 or 2, since they are easiest to implement and integrate into your existing code. Option 3 is a little more complex, but good practice.. . Happy coding!"|643|2|active|||0
kvcs0z7ox2g37|Partners|Hi this isn't really related to cs, but is it recommended at all to work with a partner on projects? Would it make any noticeable difference? I guess it does depend on what type of partner you get but I just want to get some input because I haven't been working with a partner for the past three projects.|15|0|private|"In my opinion there's two sides to working with a partner:. . 1. You learn teamwork and Git group skills that are helpful for future CS classes that require partnerships. Such skills can also be applied to many job opportunities and industry work. Personally, when asked in an interview about a time when I experienced ""leadership"" or a ""challenge,"" I typically reflect on the times I worked with partners.. . 2. If you end up splitting up project work in a partnership, you may not learn as much. Say your partner does part A and you do part B. You may come out of the project not understanding the ins and outs of part A.. . If other instructors have more insight, feel free to edit this answer!"||0
kvcgalxfukq4h|When will project 4 be released?|I want to start early on project 4 but it doesn’t seem to have been released yet, and I’m not sure if p4 will be any different from previous terms .|201|5|active|"I've heard from students in previous terms that generally project 4 is easier to handle than euchre. If you need somewhere to start, maybe go through the lecture notes/runestones and look at templates, container adts, polymorphism, etc so that you can go into the project feeling confident. Or code something for fun! I know that part of the burnout I've been feeling lately has had a lot to do with figuring out if I really enjoy computer science, or if someone told me ""It's the highest paying engineering job out of UMich!"" and I just went with it. The stuff we're learning now is going to enable us to do really neat stuff in the future, but it's going to be very frustrating right now when you spend 30+ hours on a project just to get a grade that makes you go ""huuuHHhuh."" What's most important is that you're learning the skills. So don't worry too much, you got this!"||1
kv5qfgvu3ne32c|Problem with debugger when I have breakpoint in api.cpp|"I have an issue with my debugger for this portion, it says in the terminal  . &""warning: GDB: Failed to set controlling terminal: Operation not permitted\n""/bin/bash: main_test.in: No such file or directory[1] + Done                       ""/usr/bin/gdb"" --interpreter=mi --tty=${DbgTerm} 0<""/tmp/Microsoft-MIEngine-In-r4rgupmx.ew1"" 1>""/tmp/Microsoft-MIEngine-Out-yj0vlut4.xj3"". . When I try to run it, it says in the debug console ERROR: Unable to start debugging. Unexpected GDB output from command ""-exec-run"". During startup program exited with code 1.. . Is there any solution to this problem?"|13|0|private|It's possible you have set up the input redirection or the passing of arguments incorrectly. We'll answer more p4 questions once it is released after the midterm.  ||0
kv319cu0oj2521|p4 opening|just wondering when does project 4 open?|181|0|active|. . We want students to focus on studying for the midterm, so we will not release the project until later this week.||0
